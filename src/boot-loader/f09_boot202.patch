Only in f09_tmp: app.cfg
diff --unidirectional-new-file -ru f09_tmp/bl_autobaud.c f09_bootloader_202/bl_autobaud.c
--- f09_tmp/bl_autobaud.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_autobaud.c	2017-08-23 13:37:40.640000000 +0800
@@ -0,0 +1,283 @@
+//*****************************************************************************
+//
+// bl_autobaud.c - Automatic baud rate detection code.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include "inc/hw_gpio.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_types.h"
+#include "bl_uart.h"
+#include "bmc_blcfg.h"
+
+#define UART_ENABLE_UPDATE
+
+//*****************************************************************************
+//
+// If using auto-baud, make sure that the data buffer is large enough.
+//
+//*****************************************************************************
+#if defined(UART_ENABLE_UPDATE) && defined(UART_AUTOBAUD) && (BUFFER_SIZE < 20)
+#error ERROR: BUFFER_SIZE must be >= 20!
+#endif
+
+//*****************************************************************************
+//
+//! \addtogroup bl_autobaud_api
+//! @{
+//
+//*****************************************************************************
+#if defined(UART_ENABLE_UPDATE) && defined(UART_AUTOBAUD) || defined(DOXYGEN)
+
+//*****************************************************************************
+//
+// This define holds the multiplier for the pulse detection algorithm.  The
+// value is used to generate a fractional difference detection of
+// 1 / PULSE_DETECTION_MULT.
+//
+//*****************************************************************************
+#define PULSE_DETECTION_MULT    3
+
+//*****************************************************************************
+//
+// This define holds the minimum number of edges to successfully sync to a
+// pattern of 2 bytes.
+//
+//*****************************************************************************
+#define MIN_EDGE_COUNT          18
+
+//*****************************************************************************
+//
+// This global holds the number of edges that have been stored in the global
+// buffer g_pui32DataBuffer.
+//
+//*****************************************************************************
+static volatile uint32_t g_ui32TickIndex;
+
+//*****************************************************************************
+//
+// The data buffer that is used for receiving packets is used to hold the edge
+// times during auto-baud.  The buffer is not used for receiving packets while
+// auto-baud is in progress, so this does not present problems.
+//
+//*****************************************************************************
+extern uint32_t g_pui32DataBuffer[];
+
+//*****************************************************************************
+//
+//! Handles the UART Rx GPIO interrupt.
+//!
+//! When an edge is detected on the UART Rx pin, this function is called to
+//! save the time of the edge.  These times are later used to determine the
+//! ratio of the UART baud rate to the processor clock rate.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+GPIOIntHandler(void)
+{
+    uint32_t ui32Temp;
+
+    //
+    // Clear the GPIO interrupt source.
+    //
+    HWREG(GPIO_PORTA_BASE + GPIO_O_ICR) = UART_RX;
+
+    //
+    // While we still have space in our buffer, store the current system tick
+    // count and return from interrupt.
+    //
+    if(g_ui32TickIndex < 20)
+    {
+        ui32Temp = HWREG(NVIC_ST_CURRENT);
+        g_pui32DataBuffer[g_ui32TickIndex++] = ui32Temp;
+    }
+}
+
+//*****************************************************************************
+//
+//! Performs auto-baud on the UART port.
+//!
+//! \param pui32Ratio is the ratio of the processor's crystal frequency to the
+//! baud rate being used by the UART port for communications.
+//!
+//! This function attempts to synchronize to the updater program that is trying
+//! to communicate with the boot loader.  The UART port is monitored for edges
+//! using interrupts.  Once enough edges are detected, the boot loader
+//! determines the ratio of baud rate and crystal frequency needed to program
+//! the UART.
+//!
+//! \return Returns a value of 0 to indicate that this call successfully
+//! synchronized with the other device communicating over the UART, and a
+//! negative value to indicate that this function did not successfully
+//! synchronize with the other UART device.
+//
+//*****************************************************************************
+int
+UARTAutoBaud(uint32_t *pui32Ratio)
+{
+    int32_t i32Pulse, i32ValidPulses, i32Temp, i32Total;
+    volatile int32_t i32Delay;
+
+    //
+    // Configure and enable SysTick.  Set the reload value to the maximum;
+    // there are only 24 bits in the register but loading 32 bits of ones is
+    // more efficient.
+    //
+    HWREG(NVIC_ST_RELOAD) = 0xffffffff;
+    HWREG(NVIC_ST_CTRL) = NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_ENABLE;
+
+    //
+    // Reset the counters that control the pulse detection.
+    //
+    i32ValidPulses = 0;
+    i32Total = 0;
+    g_ui32TickIndex = 0;
+
+    //
+    // Set the pad(s) for standard push-pull operation.
+    //
+    //HWREG(GPIO_PORTK_BASE + GPIO_O_PUR) |= UART_RX;
+    //HWREG(GPIO_PORTK_BASE + GPIO_O_DEN) |= UART_RX;
+    HWREG(0x40061000 + GPIO_O_PUR) |= UART_RX;
+    HWREG(0x40061000 + GPIO_O_DEN) |= UART_RX;
+
+    //
+    // Interrupt on both edges.
+    //
+    HWREG(GPIO_PORTK_BASE + GPIO_O_IBE) = UART_RX;
+
+    //
+    // Clear out all of the gpio interrupts in this register.
+    //
+    HWREG(GPIO_PORTK_BASE + GPIO_O_ICR) = UART_RX;
+
+    //
+    // Enable the GPIO pin corresponding to the UART RX pin.
+    //
+    HWREG(GPIO_PORTK_BASE + GPIO_O_IM) = UART_RX;
+
+    //
+    // Enable GPIOA Interrupt.
+    //
+    HWREG(NVIC_EN0) = 1;
+
+    //
+    // Wait for MIN_EDGE_COUNT to pass to collect enough edges.
+    //
+    while(g_ui32TickIndex < MIN_EDGE_COUNT)
+    {
+    }
+
+    //
+    // Disable GPIOA Interrupt.
+    //
+    HWREG(NVIC_DIS0) = 1;
+
+    //
+    // Calculate the pulse widths from the array of tick times.
+    //
+    for(i32Pulse = 0; i32Pulse < (MIN_EDGE_COUNT - 1); i32Pulse++)
+    {
+        i32Temp = (((int32_t)g_pui32DataBuffer[i32Pulse] -
+                    (int32_t)g_pui32DataBuffer[i32Pulse + 1]) & 0x00ffffff);
+        g_pui32DataBuffer[i32Pulse] = i32Temp;
+    }
+
+    //
+    // This loops handles checking for consecutive pulses that have pulse
+    // widths that are within an acceptable margin.
+    //
+    for(i32Pulse = 0; i32Pulse < (MIN_EDGE_COUNT - 1); i32Pulse++)
+    {
+        //
+        // Calculate the absolute difference between two consecutive pulses.
+        //
+        i32Temp = (int32_t)g_pui32DataBuffer[i32Pulse];
+        i32Temp -= (int32_t)g_pui32DataBuffer[i32Pulse + 1];
+        if(i32Temp < 0)
+        {
+            i32Temp *= -1;
+        }
+
+        //
+        // This pulse detection code uses the following algorithm:
+        // If the following is true then we have consecutive acceptable pulses
+        // abs(Pulse[n] - Pulse[n + 1]) < Pulse[n + 1] / PULSE_DETECTION_MULT
+        // or
+        // PULSE_DETECTION_MULT * abs(Pulse[n] - Pulse[n + 1]) < Pulse[n + 1]
+        //
+        if((i32Temp * PULSE_DETECTION_MULT) <
+           (int32_t)g_pui32DataBuffer[i32Pulse + 1])
+        {
+            i32Total += (int32_t)g_pui32DataBuffer[i32Pulse];
+            i32ValidPulses++;
+        }
+        else
+        {
+            i32ValidPulses = 0;
+            i32Total = 0;
+        }
+
+        //
+        // Once we have 7 pulses calculate the ratio needed to program the
+        // UART.
+        //
+        if(i32ValidPulses == 7)
+        {
+            //
+            // Add in the last pulse and calculate the ratio.
+            //
+            i32Total += (int32_t)g_pui32DataBuffer[i32Pulse];
+            *pui32Ratio = i32Total >> 1;
+
+            //
+            // Wait for at least 2 UART clocks since we only wait for 18 of 20
+            // that are coming from the host.  If we don't wait, we can turn
+            // on the UART while the last two pulses come down.
+            //
+            for(i32Delay = i32Total; i32Delay; i32Delay--)
+            {
+            }
+
+            //
+            // Indicate a successful auto baud operation.
+            //
+            return(0);
+        }
+    }
+
+    //
+    // Automatic baud rate detection failed.
+    //
+    return(-1);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+#endif
diff --unidirectional-new-file -ru f09_tmp/bl_commands.h f09_bootloader_202/bl_commands.h
--- f09_tmp/bl_commands.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_commands.h	2017-08-23 13:37:40.643000000 +0800
@@ -0,0 +1,230 @@
+//*****************************************************************************
+//
+// bl_commands.h - The list of commands and return messages supported by the
+//                 boot loader.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __BL_COMMANDS_H__
+#define __BL_COMMANDS_H__
+
+//*****************************************************************************
+//
+// This command is used to receive an acknowledge from the the boot loader
+// proving that communication has been established.  This command is a single
+// byte.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[1];
+//
+//     ui8Command[0] = COMMAND_PING;
+//
+//*****************************************************************************
+#define COMMAND_PING            0x20
+
+//*****************************************************************************
+//
+// This command is sent to the boot loader to indicate where to store data and
+// how many bytes will be sent by the COMMAND_SEND_DATA commands that follow.
+// The command consists of two 32-bit values that are both transferred MSB
+// first.  The first 32-bit value is the address to start programming data
+// into, while the second is the 32-bit size of the data that will be sent.
+// This command also triggers an erasure of the full application area in the
+// flash or possibly the entire flash depending on the address used.  This
+// causes the command to take longer to send the ACK/NAK in response to the
+// command.  This command should be followed by a COMMAND_GET_STATUS to ensure
+// that the program address and program size were valid for the microcontroller
+// running the boot loader.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[9];
+//
+//     ui8Command[0] = COMMAND_DOWNLOAD;
+//     ui8Command[1] = Program Address [31:24];
+//     ui8Command[2] = Program Address [23:16];
+//     ui8Command[3] = Program Address [15:8];
+//     ui8Command[4] = Program Address [7:0];
+//     ui8Command[5] = Program Size [31:24];
+//     ui8Command[6] = Program Size [23:16];
+//     ui8Command[7] = Program Size [15:8];
+//     ui8Command[8] = Program Size [7:0];
+//
+//*****************************************************************************
+#define COMMAND_DOWNLOAD        0x21
+
+//*****************************************************************************
+//
+// This command is sent to the boot loader to transfer execution control to the
+// specified address.  The command is followed by a 32-bit value, transferred
+// MSB first, that is the address to which execution control is transferred.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[5];
+//
+//     ui8Command[0] = COMMAND_RUN;
+//     ui8Command[1] = Run Address [31:24];
+//     ui8Command[2] = Run Address [23:16];
+//     ui8Command[3] = Run Address [15:8];
+//     ui8Command[4] = Run Address [7:0];
+//
+//*****************************************************************************
+#define COMMAND_RUN             0x22
+
+//*****************************************************************************
+//
+// This command returns the status of the last command that was issued.
+// Typically this command should be received after every command is sent to
+// ensure that the previous command was successful or, if unsuccessful, to
+// properly respond to a failure.  The command requires one byte in the data of
+// the packet and the boot loader should respond by sending a packet with one
+// byte of data that contains the current status code.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[1];
+//
+//     ui8Command[0] = COMMAND_GET_STATUS;
+//
+// The following are the definitions for the possible status values that can be
+// returned from the boot loader when <tt>COMMAND_GET_STATUS</tt> is sent to
+// the microcontroller.
+//
+//     COMMAND_RET_SUCCESS
+//     COMMAND_RET_UNKNOWN_CMD
+//     COMMAND_RET_INVALID_CMD
+//     COMMAND_RET_INVALID_ADD
+//     COMMAND_RET_FLASH_FAIL
+//
+//*****************************************************************************
+#define COMMAND_GET_STATUS      0x23
+
+//*****************************************************************************
+//
+// This command should only follow a COMMAND_DOWNLOAD command or another
+// COMMAND_SEND_DATA command, if more data is needed.  Consecutive send data
+// commands automatically increment the address and continue programming from
+// the previous location.  The transfer size is limited by the size of the
+// receive buffer in the boot loader (as configured by the BUFFER_SIZE
+// parameter).  The command terminates programming once the number of bytes
+// indicated by the COMMAND_DOWNLOAD command has been received.  Each time this
+// function is called, it should be followed by a COMMAND_GET_STATUS command to
+// ensure that the data was successfully programmed into the flash.  If the
+// boot loader sends a NAK to this command, the boot loader will not increment
+// the current address to allow retransmission of the previous data.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[9];
+//
+//     ui8Command[0] = COMMAND_SEND_DATA;
+//     ui8Command[1] = Data[0];
+//     ui8Command[2] = Data[1];
+//     ui8Command[3] = Data[2];
+//     ui8Command[4] = Data[3];
+//     ui8Command[5] = Data[4];
+//     ui8Command[6] = Data[5];
+//     ui8Command[7] = Data[6];
+//     ui8Command[8] = Data[7];
+//
+//*****************************************************************************
+#define COMMAND_SEND_DATA       0x24
+
+//*****************************************************************************
+//
+// This command is used to tell the boot loader to reset.  This is used after
+// downloading a new image to the microcontroller to cause the new application
+// or the new boot loader to start from a reset.  The normal boot sequence
+// occurs and the image runs as if from a hardware reset.  It can also be used
+// to reset the boot loader if a critical error occurs and the host device
+// wants to restart communication with the boot loader.
+//
+// The format of the command is as follows:
+//
+//     uint8_t ui8Command[1];
+//
+//     ui8Command[0] = COMMAND_RESET;
+//
+// The boot loader responds with an ACK signal to the host device before
+// actually executing the software reset on the microcontroller running the
+// boot loader.  This informs the updater application that the command was
+// received successfully and the part will be reset.
+//
+//*****************************************************************************
+#define COMMAND_RESET           0x25
+
+//*****************************************************************************
+//
+// This is returned in response to a COMMAND_GET_STATUS command and indicates
+// that the previous command completed successful.
+//
+//*****************************************************************************
+#define COMMAND_RET_SUCCESS     0x40
+
+//*****************************************************************************
+//
+// This is returned in response to a COMMAND_GET_STATUS command and indicates
+// that the command sent was an unknown command.
+//
+//*****************************************************************************
+#define COMMAND_RET_UNKNOWN_CMD 0x41
+
+//*****************************************************************************
+//
+// This is returned in response to a COMMAND_GET_STATUS command and indicates
+// that the previous command was formatted incorrectly.
+//
+//*****************************************************************************
+#define COMMAND_RET_INVALID_CMD 0x42
+
+//*****************************************************************************
+//
+// This is returned in response to a COMMAND_GET_STATUS command and indicates
+// that the previous download command contained an invalid address value.
+//
+//*****************************************************************************
+#define COMMAND_RET_INVALID_ADR 0x43
+
+//*****************************************************************************
+//
+// This is returned in response to a COMMAND_GET_STATUS command and indicates
+// that an attempt to program or erase the flash has failed.
+//
+//*****************************************************************************
+#define COMMAND_RET_FLASH_FAIL  0x44
+
+//*****************************************************************************
+//
+// This is the value that is sent to acknowledge a packet.
+//
+//*****************************************************************************
+#define COMMAND_ACK             0xcc
+
+//*****************************************************************************
+//
+// This is the value that is sent to not-acknowledge a packet.
+//
+//*****************************************************************************
+#define COMMAND_NAK             0x33
+
+#endif // __BL_COMMANDS_H__
diff --unidirectional-new-file -ru f09_tmp/bl_enet.c f09_bootloader_202/bl_enet.c
--- f09_tmp/bl_enet.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_enet.c	2017-08-23 13:37:40.364000000 +0800
@@ -0,0 +1,2016 @@
+//*****************************************************************************
+//
+// bl_enet.c - Functions to update via Ethernet.
+//
+// Copyright (c) 2007-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include "inc/hw_emac.h"
+#include "inc/hw_flash.h"
+#include "inc/hw_gpio.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_types.h"
+#include "bmc_blcfg.h"
+#include "boot_loader/bl_flash.h"
+#include "boot_loader/bl_hooks.h"
+#include "bl_enet_drv.h"
+#include "driverlib/eeprom.h"
+#include "driverlib/sysctl.h"
+//#include "ncsi/ncsi.h"
+
+
+//*****************************************************************************
+//
+// TFTP packets contain 512 bytes of data and a packet shorter than this
+// indicates the end of the transfer.
+//
+//*****************************************************************************
+#define TFTP_BLOCK_SIZE         512
+
+//*****************************************************************************
+//
+// The prototype for the function that is used to call the application.
+//
+//*****************************************************************************
+extern void CallApplication(uint32_t ui32StartAddr);
+
+//*****************************************************************************
+//
+// Directly include the uIP code if using Ethernet for the update.  This allows
+// non-Ethernet boot loader builds to not have to supply the uip-conf.h file
+// that would otherwise be required.
+//
+//*****************************************************************************
+void *my_memset(void *pvDest, int32_t i32Char, size_t lLength);
+void *my_memcpy(void *pvDest, const void *pvSrc, size_t lLength);
+#define memcpy my_memcpy
+#define memset my_memset
+#include "third_party/uip-1.0/uip/pt.h"
+#include "third_party/uip-1.0/uip/uip_arp.c"
+#undef BUF
+#include "third_party/uip-1.0/uip/uip.c"
+
+//*****************************************************************************
+//
+// A prototype for the function (in the startup code) for a predictable length
+// delay.
+//
+//*****************************************************************************
+extern void Delay(uint32_t ui32Count);
+
+//*****************************************************************************
+//
+// Defines for setting up the system clock.
+//
+//*****************************************************************************
+#define SYSTICKHZ               100
+#define SYSTICKMS               (1000 / SYSTICKHZ)
+
+//*****************************************************************************
+//
+// UIP Timers (in ms)
+//
+//*****************************************************************************
+#define UIP_PERIODIC_TIMER_MS   50
+#define UIP_ARP_TIMER_MS        10000
+
+#define UIP_DHCP_DELAY        	2400  //15 secs
+
+
+//extern _UINT8 PackageID;
+//extern _UINT8 ChannelID;
+
+uint32_t dhcpexist = 0;
+
+//*****************************************************************************
+//
+// This structure defines the fields in a BOOTP/DHCP request/reply packet.
+//
+//*****************************************************************************
+typedef struct
+{
+    //
+    // The operation; 1 is a request, 2 is a reply.
+    //
+    uint8_t ui8Op;
+
+    //
+    // The hardware type; 1 is Ethernet.
+    //
+    uint8_t ui8HType;
+
+    //
+    // The hardware address length; for Ethernet this will be 6, the length of
+    // the MAC address.
+    //
+    uint8_t ui8HLen;
+
+    //
+    // Hop count, used by gateways for cross-gateway booting.
+    //
+    uint8_t ui8Hops;
+
+    //
+    // The transaction ID.
+    //
+    uint32_t ui32XID;
+
+    //
+    // The number of seconds elapsed since the client started trying to boot.
+    //
+    uint16_t ui16Secs;
+
+    //
+    // The BOOTP flags.
+    //
+    uint16_t ui16Flags;
+
+    //
+    // The client's IP address, if it knows it.
+    //
+    uint32_t ui32CIAddr;
+
+    //
+    // The client's IP address, as assigned by the BOOTP server.
+    //
+    uint32_t ui32YIAddr;
+
+    //
+    // The TFTP server's IP address.
+    //
+    uint32_t ui32SIAddr;
+
+    //
+    // The gateway IP address, if booting cross-gateway.
+    //
+    uint32_t ui32GIAddr;
+
+    //
+    // The hardware address; for Ethernet this is the MAC address.
+    //
+    uint8_t pui8CHAddr[16];
+
+    //
+    // The name, or nickname, of the server that should handle this BOOTP
+    // request.
+    //
+    char pcSName[64];
+
+    //
+    // The name of the boot file to be loaded via TFTP.
+    //
+    char pcFile[128];
+
+    //
+    // Optional vendor-specific area; used only by DHCP.
+    //
+    uint8_t pui8Vend[64];
+}
+tEnetPacket;
+
+//*****************************************************************************
+//
+// The BOOTP commands (DHCP is an extension of BOOTP).
+//
+//*****************************************************************************
+#define BOOTP_REQUEST           1
+#define BOOTP_REPLY             2
+
+//*****************************************************************************
+//
+// The DHCP option/type category indicators.
+//
+//*****************************************************************************
+#define DHCP_OPTION_SUBNET_MASK 1
+#define DHCP_OPTION_ROUTER      3
+#define DHCP_OPTION_DNS_SERVER  6
+#define DHCP_OPTION_REQ_IPADDR  50
+#define DHCP_OPTION_LEASE_TIME  51
+#define DHCP_OPTION_MSG_TYPE    53
+#define DHCP_OPTION_SERVER_ID   54
+#define DHCP_OPTION_REQ_LIST    55
+#define DHCP_OPTION_CLIENT_ID   61
+#define DHCP_OPTION_END         255
+
+//*****************************************************************************
+//
+// The DHCP option sub-indicators.
+//
+//*****************************************************************************
+#define DHCP_DISCOVER           1
+#define DHCP_OFFER              2
+#define DHCP_REQUEST            3
+#define DHCP_ACK                5
+
+//*****************************************************************************
+//
+// The TFTP commands.
+//
+//*****************************************************************************
+#define TFTP_RRQ                1
+#define TFTP_WRQ                2
+#define TFTP_DATA               3
+#define TFTP_ACK                4
+#define TFTP_ERROR              5
+
+//*****************************************************************************
+//
+// The UDP ports used by the BOOTP protocol.
+//
+//*****************************************************************************
+#define BOOTP_SERVER_PORT       67
+#define BOOTP_CLIENT_PORT       68
+
+//*****************************************************************************
+//
+// The UDP port for the TFTP server.
+//
+//*****************************************************************************
+#define TFTP_PORT               69
+
+//*****************************************************************************
+//
+// The MAC address of the Ethernet interface.
+//
+//*****************************************************************************
+#ifdef ENET_MAC_ADDR0
+static struct uip_eth_addr g_sMACAddr =
+{
+    {
+        ENET_MAC_ADDR0,
+        ENET_MAC_ADDR1,
+        ENET_MAC_ADDR2,
+        ENET_MAC_ADDR3,
+        ENET_MAC_ADDR4,
+        ENET_MAC_ADDR5
+    }
+};
+#else
+static struct uip_eth_addr g_sMACAddr;
+#endif
+
+//*****************************************************************************
+//
+// The number of SysTick interrupts since the start of the boot loader.
+//
+//*****************************************************************************
+static uint32_t g_ui32Ticks;
+
+//*****************************************************************************
+//
+// The number of SysTick interrupts since the DHCP discover or DHCP request
+//
+//*****************************************************************************
+static uint32_t g_ui32DCHPTicks;
+
+//*****************************************************************************
+//
+// The seed for the random number generator.
+//
+//*****************************************************************************
+//static uint32_t g_ui32RandomSeed;
+
+//*****************************************************************************
+//
+// The number of milliseconds since the last call to uip_udp_periodic().
+//
+//*****************************************************************************
+static volatile uint32_t g_ui32PeriodicTimer;
+
+//*****************************************************************************
+//
+// The number of milliseconds since the last call to uip_arp_timer().
+//
+//*****************************************************************************
+static volatile uint32_t g_ui32ARPTimer;
+
+//*****************************************************************************
+//
+// The transaction ID of the most recently sent out BOOTP request.
+//
+//*****************************************************************************
+//static uint32_t g_ui32XID;
+
+//*****************************************************************************
+//
+// The state for the proto-thread that handles the BOOTP process.
+//
+//*****************************************************************************
+//static struct pt g_sThread;
+
+//*****************************************************************************
+//
+// The amount of time to wait for a BOOTP reply before sending out a new BOOTP
+// request.
+//
+//*****************************************************************************
+//static uint32_t g_ui32Delay;
+
+//*****************************************************************************
+//
+// The target time (relative to g_ui32Ticks) when the next timeout occurs.
+//
+//*****************************************************************************
+//static uint32_t g_ui32Target;
+
+//*****************************************************************************
+//
+// The IP address of the TFTP server.
+//
+//*****************************************************************************
+//static uip_ipaddr_t g_sDHCPAddr;
+
+//*****************************************************************************
+//
+// The IP address of the TFTP server.
+//
+//*****************************************************************************
+uip_ipaddr_t g_sTFTPAddr;
+
+//*****************************************************************************
+//
+// The name of the file to be read from the TFTP server.
+//
+//*****************************************************************************
+char g_pcFilename[128];
+
+//*****************************************************************************
+//
+// The end of flash.  If there is not a reserved block at the end of flash,
+// this is the real end of flash.  If there is a reserved block, this is the
+// start of the reserved block (i.e. the virtual end of flash).
+//
+//*****************************************************************************
+//static uint32_t g_ui32FlashEnd;
+
+//*****************************************************************************
+//
+// The current block being read from the TFTP server.
+//
+//*****************************************************************************
+//static uint32_t g_ui32TFTPBlock;
+
+//*****************************************************************************
+//
+// The UDP socket used to communicate with the BOOTP and TFTP servers (in
+// sequence).
+//
+//*****************************************************************************
+struct uip_udp_conn *g_pConn;
+
+//*****************************************************************************
+//
+// uIP uses memset, so a simple one is provided here.  This is not as efficient
+// as the one in the C library (from an execution time perspective), but it is
+// much smaller.
+//
+//*****************************************************************************
+void *
+my_memset(void *pvDest, int32_t i32Char, size_t lLength)
+{
+    char *pcBuf = (char *)pvDest;
+
+    //
+    // Fill the buffer with the given character.
+    //
+    while(lLength--)
+    {
+        *pcBuf++ = i32Char;
+    }
+
+    //
+    // Return a pointer to the beginning of the buffer.
+    //
+    return(pvDest);
+}
+
+//*****************************************************************************
+//
+// uIP uses memcpy, so a simple one is provided here.  This is not as efficient
+// as the one in the C library (from an execution time perspective), but it is
+// much smaller.
+//
+//*****************************************************************************
+void *
+my_memcpy(void *pvDest, const void *pvSrc, size_t lLength)
+{
+    const char *pcSrc = (const char *)pvSrc;
+    char *pcDest = (char *)pvDest;
+
+    //
+    // Copy bytes from the source buffer to the destination buffer.
+    //
+    while(lLength--)
+    {
+        *pcDest++ = *pcSrc++;
+    }
+
+    //
+    // Return a pointer to the beginning of the destination buffer.
+    //
+    return(pvDest);
+}
+
+void  Hal_eeprom_read( uint8_t *buffer, uint16_t offset ,  uint16_t len)
+{
+	uint16_t start_align_offset = 0 ;
+	uint16_t new_len = 0 ;
+	uint8_t temp_buffer[32] ;
+	uint8_t start_index = 0 ;
+	uint8_t i = 0 ;
+	uint32_t * pdata;
+	
+
+//	System_printf("%s %d   offset=%x length=%d\n",__FILE__,__LINE__,offset,len);
+
+	start_align_offset = offset & 0xfffc ;
+
+	start_index = offset % 4 ;
+	if ( (len % 4) > 0)
+		new_len = len / 4 * 4 + 0x04 ;
+	else
+		new_len = len;
+
+	if ((start_index %4 + len) > 4) 
+			new_len += 4 ;		
+
+	pdata = (uint32_t *)temp_buffer ;
+
+	while(EEPROMStatusGet()!=0)
+	{
+		SysCtlDelay(120);
+	}
+
+
+	EEPROMRead(pdata, start_align_offset, new_len );
+	for( i = 0 ; i < len ; i++ ){
+		buffer[i] =(uint8_t) temp_buffer[ i+ start_index ];
+
+	}
+
+}
+
+int Hal_eeprom_write( uint8_t *buffer, uint16_t offset ,  uint16_t len)
+{
+	uint16_t start_align_offset = 0 ;
+	uint16_t new_len = 0 ;
+	uint8_t old_buffer[32] ;
+	uint8_t start_index = 0 ;
+	uint8_t i = 0 ;
+	uint32_t * pdata;
+	uint32_t status=0 ;
+	
+
+	start_align_offset = offset & 0xfffc ;
+	start_index = offset % 4 ;
+
+	if ( (len % 4) > 0){
+
+		new_len = len / 4 * 4 + 0x04 ;
+	}else
+	{
+
+		new_len = len ;
+	}
+
+
+	if ((start_index % 4 + len) > 4)
+			new_len += 4 ;
+
+	while(EEPROMStatusGet()!=0)
+	{
+		SysCtlDelay(120);
+	}
+
+	EEPROMRead((uint32_t *)old_buffer, start_align_offset, new_len );
+
+
+
+
+	for(i = 0 ; i < len ; i++){
+		old_buffer[start_index + i] = (* (uint8_t *) buffer) & 0xff;
+		buffer++;
+	}
+
+
+	pdata =(uint32_t *) old_buffer ;
+	while(EEPROMStatusGet()!=0)
+	{
+		SysCtlDelay(120);
+	}
+	status = EEPROMProgram(pdata,start_align_offset, new_len);
+	
+	return status ;
+
+}
+
+//*****************************************************************************
+//
+//! Handles the SysTick interrupt.
+//!
+//! This function is called when the SysTick interrupt occurs.  It simply
+//! keeps a running count of interrupts, used as a time basis for the BOOTP and
+//! TFTP protocols.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SysTickIntHandler(void)
+{
+    //
+    // Increment the tick count.
+    //
+    g_ui32Ticks++;
+    g_ui32PeriodicTimer += SYSTICKMS;
+    g_ui32ARPTimer += SYSTICKMS;
+    
+    g_ui32DCHPTicks++;
+}
+
+//*****************************************************************************
+//
+//! Computes a new random number.
+//!
+//! This function computes a new pseudo-random number, using a linear
+//! congruence random number generator.  Note that if the entire 32-bits of the
+//! produced random number are not being used, the upper N bits should be used
+//! instead of the lower N bits as they are much more random (for example, use
+//! ``RandomNumber() >> 28'' instead of ``RandomNumber() & 15'').
+//!
+//! \return Returns a 32-bit pseudo-random number.
+//
+//*****************************************************************************
+#if 0
+static uint32_t
+RandomNumber(void)
+{
+    //
+    // Generate a new pseudo-random number with a linear congruence random
+    // number generator.  This new random number becomes the seed for the next
+    // random number.
+    //
+    g_ui32RandomSeed = (g_ui32RandomSeed * 1664525) + 1013904223;
+
+    //
+    // Return the new random number.
+    //
+    return(g_ui32RandomSeed);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Constructs and sends a DHCP discovery packet.
+//!
+//! This function constructs a DHCP discovery packet and sends it as a
+//! broadcast message to the network.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if 0
+static void
+SendDHCPDiscover(void)
+{
+    uint8_t *pui8Packet = (uint8_t *)uip_appdata;
+    tEnetPacket *psDHCP = (tEnetPacket *)uip_appdata;
+    uint32_t ui32Idx;
+    
+    //
+    // Zero fill the DHCP discover packet.
+    //
+    for(ui32Idx = 0; ui32Idx < sizeof(tEnetPacket); ui32Idx++)
+    {
+        pui8Packet[ui32Idx] = 0;
+    }
+
+    //
+    // Construct a DHCP request (as this is an extension of BOOTP, the base
+    // commands are the same).
+    //
+    psDHCP->ui8Op = BOOTP_REQUEST;
+
+    //
+    // Set the hardware type to Ethernet.
+    //
+    psDHCP->ui8HType = 0x01;
+
+    //
+    // Set the hardware address length to 6.
+    //
+    psDHCP->ui8HLen = 0x06;
+
+    //
+    // Choose a random number for the transaction ID.
+    //
+    psDHCP->ui32XID = g_ui32XID = RandomNumber();
+
+    //
+    // Set the number of seconds since we started.
+    //
+    psDHCP->ui16Secs = HTONS(g_ui32Ticks / SYSTICKHZ);
+
+    //
+    // Fill in the Ethernet MAC address.
+    //
+    for(ui32Idx = 0; ui32Idx < 6; ui32Idx++)
+    {
+        psDHCP->pui8CHAddr[ui32Idx] = g_sMACAddr.addr[ui32Idx];
+    }
+
+    //
+    // Set the cookie.
+    //
+    psDHCP->pui8Vend[0] = 99;
+    psDHCP->pui8Vend[1] = 130;
+    psDHCP->pui8Vend[2] = 83;
+    psDHCP->pui8Vend[3] = 99;
+
+    //
+    // Set the options to indicate this packet is a DHCP discovery.
+    //
+    psDHCP->pui8Vend[4] = DHCP_OPTION_CLIENT_ID;
+    psDHCP->pui8Vend[5] = 7;
+    psDHCP->pui8Vend[6] = 1;
+    psDHCP->pui8Vend[7] = g_sMACAddr.addr[0];
+    psDHCP->pui8Vend[8] = g_sMACAddr.addr[1];
+    psDHCP->pui8Vend[9] = g_sMACAddr.addr[2];
+    psDHCP->pui8Vend[10] = g_sMACAddr.addr[3];
+    psDHCP->pui8Vend[11] = g_sMACAddr.addr[4];
+    psDHCP->pui8Vend[12] = g_sMACAddr.addr[5];
+    
+    psDHCP->pui8Vend[13] = DHCP_OPTION_MSG_TYPE;
+    psDHCP->pui8Vend[14] = 1;
+    psDHCP->pui8Vend[15] = DHCP_DISCOVER;
+
+    //
+    // Add request option flags.
+    //
+    psDHCP->pui8Vend[16] = DHCP_OPTION_REQ_LIST;
+    psDHCP->pui8Vend[17] = 3;
+    psDHCP->pui8Vend[18] = DHCP_OPTION_SUBNET_MASK;
+    psDHCP->pui8Vend[19] = DHCP_OPTION_ROUTER;
+    psDHCP->pui8Vend[20] = DHCP_OPTION_DNS_SERVER;
+
+    //
+    // Flag the end of the options sent.
+    //
+    psDHCP->pui8Vend[21] = DHCP_OPTION_END;
+
+    //
+    // Send the DHCP discovery packet.
+    //
+    uip_udp_send(sizeof(tEnetPacket));
+}
+#endif
+//*****************************************************************************
+//
+//! Constructs and sends a DHCP lease request packet.
+//!
+//! This function constructs a DHCP lease request packet and sends it to the
+//! server that responded.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if 0
+static void
+SendDHCPRequest(void)
+{
+    uint8_t *pui8Packet = (uint8_t *)uip_appdata;
+    tEnetPacket *psDHCP = (tEnetPacket *)uip_appdata;
+    uint32_t ui32Idx;
+
+    //
+    // Zero fill the DHCP discover packet.
+    //
+    for(ui32Idx = 0; ui32Idx < sizeof(tEnetPacket); ui32Idx++)
+    {
+        pui8Packet[ui32Idx] = 0;
+    }
+
+    //
+    // Construct a DHCP request (as this is an extension of BOOTP, the base
+    // commands are the same).
+    //
+    psDHCP->ui8Op = BOOTP_REQUEST;
+
+    //
+    // Set the hardware type to Ethernet.
+    //
+    psDHCP->ui8HType = 0x01;
+
+    //
+    // Set the hardware address length to 6.
+    //
+    psDHCP->ui8HLen = 0x06;
+
+    //
+    // Choose a random number for the transaction ID.
+    //
+    psDHCP->ui32XID = g_ui32XID = RandomNumber();
+
+    //
+    // Set the number of seconds since we started.
+    //
+    psDHCP->ui16Secs = HTONS(g_ui32Ticks / SYSTICKHZ);
+
+    //
+    // Fill in the Ethernet MAC address.
+    //
+    for(ui32Idx = 0; ui32Idx < 6; ui32Idx++)
+    {
+        psDHCP->pui8CHAddr[ui32Idx] = g_sMACAddr.addr[ui32Idx];
+    }
+
+    //
+    // Set the cookie.
+    //
+    psDHCP->pui8Vend[0] = 99;
+    psDHCP->pui8Vend[1] = 130;
+    psDHCP->pui8Vend[2] = 83;
+    psDHCP->pui8Vend[3] = 99;
+
+    //
+    // Set the options to indicate this packet is a DHCP request.
+    //
+    psDHCP->pui8Vend[4] = DHCP_OPTION_CLIENT_ID;
+    psDHCP->pui8Vend[5] = 7;
+    psDHCP->pui8Vend[6] = 1;
+    psDHCP->pui8Vend[7] = g_sMACAddr.addr[0];
+    psDHCP->pui8Vend[8] = g_sMACAddr.addr[1];
+    psDHCP->pui8Vend[9] = g_sMACAddr.addr[2];
+    psDHCP->pui8Vend[10] = g_sMACAddr.addr[3];
+    psDHCP->pui8Vend[11] = g_sMACAddr.addr[4];
+    psDHCP->pui8Vend[12] = g_sMACAddr.addr[5];
+    
+    psDHCP->pui8Vend[13] = DHCP_OPTION_MSG_TYPE;
+    psDHCP->pui8Vend[14] = 1;
+    psDHCP->pui8Vend[15] = DHCP_REQUEST;
+
+    //
+    // Add the responding server's ID.
+    // This is formatted as flag/size/data.
+    //
+    psDHCP->pui8Vend[16] = DHCP_OPTION_SERVER_ID;
+    psDHCP->pui8Vend[17] = 4;
+    *((uint32_t *)&psDHCP->pui8Vend[18]) = *((uint32_t *)&g_sDHCPAddr[0]);
+
+    //
+    // Add the IP address to request.
+    // This is formatted as flag/size/data.
+    //
+    psDHCP->pui8Vend[22] = DHCP_OPTION_REQ_IPADDR;
+    psDHCP->pui8Vend[23] = 4;
+    *((uint32_t *)&psDHCP->pui8Vend[24]) = *((uint32_t *)&uip_hostaddr[0]);
+
+    //
+    // Flag the end of the options sent.
+    //
+    psDHCP->pui8Vend[28] = DHCP_OPTION_END;
+
+    //
+    // Send the DHCP discovery packet.
+    //
+    uip_udp_send(sizeof(tEnetPacket));
+}
+#endif
+//*****************************************************************************
+//
+//! Parses a packet checking for a DHCP reply message.
+//!
+//! This function parses a packet to determine if it is a DHCP reply to our
+//! currently outstanding DHCP requests.  If a valid reply is found, the
+//! appropriate information from the packet is extracted and saved.
+//!
+//! \return Returns the DHCP reply type if a valid DHCP reply message was found
+//!         and 0 otherwise.
+//
+//*****************************************************************************
+#if 0
+static uint32_t
+ParseDHCPReply(void)
+{
+    tEnetPacket *psDHCP = (tEnetPacket *)uip_appdata;
+    uint32_t ui32Idx, ui32DataLength;
+    uint8_t ui8ReplyType;
+	
+    //
+    // See if this is a reply for our current DHCP request.
+    //
+    if((psDHCP->ui8Op != BOOTP_REPLY) ||
+       (psDHCP->ui32XID != g_ui32XID) ||
+       (*(uint32_t *)psDHCP->pui8CHAddr !=
+        *(uint32_t *)g_sMACAddr.addr) ||
+       (*(uint16_t *)(psDHCP->pui8CHAddr + 4) !=
+        *(uint16_t *)(g_sMACAddr.addr + 4)))
+    {
+        return(0);
+    }
+
+    //
+    // Extract our IP address from the response.
+    //
+    *((uint32_t *)(void *)(&uip_hostaddr)) = psDHCP->ui32YIAddr;
+
+    //
+    // Extract the server address from the response.
+    //
+    *((uint32_t *)(void *)(&g_sDHCPAddr)) = psDHCP->ui32SIAddr;
+
+    //
+    // Setup the option data start and limit.
+    //
+    ui32Idx = 4;
+    ui32DataLength = uip_datalen();
+
+    //
+    // Default return type is 'not valid'.
+    //
+    ui8ReplyType = 0;
+
+    //
+    // Parse the option data for relevant items.
+    //
+    while((ui32Idx < ui32DataLength) &&
+          (psDHCP->pui8Vend[ui32Idx] != DHCP_OPTION_END))
+    {
+        switch(psDHCP->pui8Vend[ui32Idx])
+        {
+            case DHCP_OPTION_SUBNET_MASK:
+            case DHCP_OPTION_ROUTER:
+            case DHCP_OPTION_DNS_SERVER:
+            case DHCP_OPTION_LEASE_TIME:
+            {
+                //
+                // Not processed in this implementation.
+                //
+                break;
+            }
+            case DHCP_OPTION_MSG_TYPE:
+            {
+              ui8ReplyType = psDHCP->pui8Vend[ui32Idx + 2];
+              break;
+            }
+            case DHCP_OPTION_SERVER_ID:
+            {
+                //
+                // Use this data if provided.
+                //
+              *((uint32_t *)(void *)(&g_sDHCPAddr)) =
+                               *((uint32_t *)(&psDHCP->pui8Vend[ui32Idx + 2]));
+              break;
+            }
+        }
+
+        //
+        // Index advance for all cases.
+        //
+        ui32Idx += psDHCP->pui8Vend[ui32Idx + 1] + 2;
+    }
+
+    //
+    // Return the reply type value.
+    //
+    return(ui8ReplyType);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Constructs and sends a TFTP error packet.
+//!
+//! This function constructs a TFTP read request packet (RRQ) and sends it to
+//! the server.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if 0
+static void
+SendTFTPError(uint16_t ui16Error, char *pcString)
+{
+    uint8_t *pui8Packet = (uint8_t *)uip_appdata;
+    int32_t i32Len;
+
+    pui8Packet[0] = (TFTP_ERROR >> 8) & 0xff;
+    pui8Packet[1] = TFTP_ERROR & 0xff;
+    pui8Packet[2] = (ui16Error >> 8) & 0xFF;
+    pui8Packet[3] = ui16Error & 0xFF;
+
+    //
+    // Get ready to copy the error string.
+    //
+    i32Len = 4;
+    pui8Packet += 4;
+
+    //
+    // Copy as much of the string as we can fit.
+    //
+    while((i32Len < (UIP_APPDATA_SIZE - 1)) && *pcString)
+    {
+        *pui8Packet++ = *pcString++;
+        i32Len++;
+    }
+
+    //
+    // Write the terminating 0.
+    //
+    *pui8Packet = (uint8_t)0;
+
+    //
+    // Send the error packet.
+    //
+    uip_udp_send(i32Len + 1);
+}
+#endif
+//*****************************************************************************
+//
+//! Constructs and sends a TFTP read packet.
+//!
+//! This function constructs a TFTP read request packet (RRQ) and sends it to
+//! the server.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if 0
+static void
+SendTFTPGet(void)
+{
+    uint8_t *pui8Packet = (uint8_t *)uip_appdata;
+    uint32_t ui32Idx;
+    char *pcFilename;
+
+    //
+    // The TFTP RRQ packet should be sent to the TFTP server port.
+    //
+    g_pConn->rport = HTONS(TFTP_PORT);
+
+    //
+    // Set the TFTP packet opcode to RRQ.
+    //
+    pui8Packet[0] = (TFTP_RRQ >> 8) & 0xff;
+    pui8Packet[1] = TFTP_RRQ & 0xff;
+
+    //
+    // Copy the file name into the RRQ packet.
+    //
+    for(ui32Idx = 2, pcFilename = g_pcFilename;
+        (pui8Packet[ui32Idx++] = *pcFilename++) != 0; )
+    {
+    }
+
+    //
+    // Set the transfer mode to binary.
+    //
+    for(pcFilename = "octet"; (pui8Packet[ui32Idx++] = *pcFilename++) != 0;)
+    {
+    }
+
+    //
+    // Send the TFTP read packet.
+    //
+    uip_udp_send(ui32Idx);
+}
+#endif
+//*****************************************************************************
+//
+//! Parses a packet checking for a TFTP data packet.
+//!
+//! This function parses a packet to determine if it is a TFTP data packet for
+//! out current TFTP transfer.  If a valid packet is found, the contents of the
+//! packet are programmed into flash.
+//!
+//! \return Returns 1 if this packet was the last packet of the TFTP data
+//! transfer and 0 otherwise.
+//
+//*****************************************************************************
+#if 0
+static uint32_t
+ParseTFTPData(void)
+{
+
+	uint8_t *pui8Packet = (uint8_t *)uip_appdata;
+    uint32_t ui32FlashAddr, ui32Idx,ui32flashclear;
+
+    //
+    // See if this is a TFTP data packet.
+    //
+    if((pui8Packet[0] != ((TFTP_DATA >> 8) && 0xff)) ||
+       (pui8Packet[1] != (TFTP_DATA & 0xff)))
+    {
+        return(0);
+    }
+
+    //
+    // If the remote port on our connection is still the TFTP server port (i.e.
+    // this is the first data packet), then copy the transaction ID for the
+    // TFTP data connection into our connection.  This will ensure that our
+    // response will be sent to the correct port.
+    //
+    if(g_pConn->rport == HTONS(TFTP_PORT))
+    {
+        g_pConn->rport =
+            ((struct uip_udpip_hdr *)&uip_buf[UIP_LLH_LEN])->srcport;
+    }
+
+    //
+    // See if this is the correct data packet.
+    //
+    if((pui8Packet[2] != ((g_ui32TFTPBlock >> 8) & 0xff)) ||
+       (pui8Packet[3] != (g_ui32TFTPBlock & 0xff)))
+    {
+        //
+        // Since the wrong data packet was sent, resend the ACK for it since
+        // we've already processed it.
+        //
+        pui8Packet[0] = (TFTP_ACK >> 8) & 0xff;
+        pui8Packet[1] = TFTP_ACK & 0xff;
+        uip_udp_send(4);
+   
+        //
+        // Ignore this packet.
+        //
+        return(0);
+    }
+
+    //
+    // What address are we about to program to?
+    //
+    ui32FlashAddr = ((g_ui32TFTPBlock - 1) * TFTP_BLOCK_SIZE) +
+                    APP_START_ADDRESS;
+
+    //
+    // Do not program this data into flash if it is beyond the end of flash.
+    //
+    if(ui32FlashAddr < g_ui32FlashEnd)
+    {
+        //
+        // If this is the first block and we have been provided with a start
+        // hook function, call it here to indicate that we are about to begin
+        // flashing a new image.
+        //
+#ifdef BL_START_FN_HOOK
+        if(g_ui32TFTPBlock == 1)
+        {
+            BL_START_FN_HOOK();
+        }
+#endif
+
+        //
+        // Clear any flash error indicator.
+        //
+        BL_FLASH_CL_ERR_FN_HOOK();
+
+        //
+        // If this is the first data packet and code protection is enabled,
+        // then erase the entire flash.
+        //
+#ifdef FLASH_CODE_PROTECTION
+        if(g_ui32TFTPBlock == 1)
+        {
+            //
+            // Loop through the pages in the flash, excluding the pages that
+            // contain the boot loader and the optional reserved space.
+            //
+            for(ui32Idx = APP_START_ADDRESS; ui32Idx < g_ui32FlashEnd;
+                ui32Idx += FLASH_PAGE_SIZE)
+            {
+                //
+                // Erase this block of the flash.
+                //
+                BL_FLASH_ERASE_FN_HOOK(ui32Idx);
+            }
+        }
+#else
+        //
+        // Flash code protection is not enabled, so see if the data in this
+        // packet will be programmed to the beginning of a flash block.  We
+        // assume that the flash block size is always a multiple of 1KB so,
+        // since each TFTP packet is 512 bytes and that the start must always
+        // be on a flash page boundary, we can be sure that we will hit the
+        // start of each page as we receive packets.
+        //
+        if(!(ui32FlashAddr & (FLASH_PAGE_SIZE - 1)))
+        {
+            //
+            // Erase this block of the flash.
+            //
+            EEPROMRead(&ui32flashclear,EEPROM_FLASH_CLEAR_FLAG,0x04);
+        	ui32flashclear = (ui32flashclear & 0xFFFFFF00) | 0x00000001 ;
+    		EEPROMProgram(&ui32flashclear,EEPROM_FLASH_CLEAR_FLAG,0x04);
+            
+            BL_FLASH_ERASE_FN_HOOK(ui32FlashAddr);
+        }
+#endif
+
+        //
+        // Decrypt the data if required.
+        //
+#ifdef BL_DECRYPT_FN_HOOK
+        BL_DECRYPT_FN_HOOK(pui8Packet + 4, uip_len - 4);
+#endif
+
+        //
+        // Program this block of data into flash.
+        //
+        BL_FLASH_PROGRAM_FN_HOOK(ui32FlashAddr,
+                                 (pui8Packet + 4),
+                                 (uip_len - 4));
+
+        //
+        // If a progress reporting hook function has been provided, call it
+        // here.  The TFTP protocol doesn't let us know how large the image is
+        // before it starts the transfer so we pass 0 as the ulTotal parameter
+        // to indicate this.
+        //
+#ifdef BL_PROGRESS_FN_HOOK
+        BL_PROGRESS_FN_HOOK(((ui32FlashAddr - APP_START_ADDRESS) +
+                            (uip_len - 4)), 0);
+#endif
+    }
+
+    if(g_ui32TFTPBlock == 1)
+    {
+    	/* Enable ARP Broaccast filter */
+    	if (NCSI_Issue_EnableBcastFilter(PackageID,ChannelID,0,0,0,0) != 0)
+    		DPRINTF(("TFTP:%d.%d Enable ARP Filter Failed\n",PackageID, ChannelID));
+    }
+
+
+    //
+    // Increment to the next block.
+    //
+    g_ui32TFTPBlock++;
+
+    //
+    // Save the packet length.
+    //
+    ui32Idx = uip_len;
+
+    //
+    // Did we see any error?
+    //
+    if(BL_FLASH_ERROR_FN_HOOK())
+    {
+        //
+        // Yes - send back an error packet.
+        //
+        SendTFTPError(2, "Error programming flash.");
+    }
+    else
+    {
+        //
+        // No errors reported so construct an ACK packet.  The block number
+        // field is already correct, so it does not need to be set.
+        //
+        pui8Packet[0] = (TFTP_ACK >> 8) & 0xff;
+        pui8Packet[1] = TFTP_ACK & 0xff;
+
+        //
+        // Send the ACK packet to the TFTP server.
+        //
+        uip_udp_send(4);
+    }
+
+    //
+    // If the packet was shorter than TFTP_BLOCK_SIZE bytes then this was the
+    // last packet in the file.
+    //
+    if(ui32Idx != (TFTP_BLOCK_SIZE + 4))
+    {
+        //
+        // If an end signal hook function has been provided, call it here.
+        //
+#ifdef BL_END_FN_HOOK
+        BL_END_FN_HOOK();
+#endif
+        return(1);
+    }
+
+    //
+    // There is more data to be read.
+    //
+
+    return(0);
+}
+#endif
+
+//*****************************************************************************
+//
+//! Handles the DHCPC process.
+//!
+//! This function contains the proto-thread for handling the DHCPC process.  It
+//! first communicates with the DHCPC server to get necessary network data for
+//! the system (IP address), then it communicates with the TFTP server based
+//! on information supplied from the application to read the firmware image
+//! file.
+//!
+//! \return None.
+//
+//*****************************************************************************
+#if 0
+#ifdef DOXYGEN
+char
+DHCPCThread(void)
+#else
+PT_THREAD(DHCPCThread(void))
+#endif
+{
+
+	static unsigned char timeout_flag=0;
+    static uint32_t g_ui32Delay,res;
+    static unsigned char g_ui8Count = 0;
+    uint32_t ui32failReason ,ui32retrycount = 0; 
+   
+    static unsigned char gComparePass = 0;
+    
+    
+    PT_BEGIN(&g_sThread);
+
+    //
+    // Set the initial delay between BOOTP requests to 1 second.
+    //
+    
+    g_ui32Delay = UIP_DHCP_DELAY;
+    
+    //
+    // Loop forever.  This loop is explicitly exited when a valid DHCP
+    // offer is received.
+    //
+    
+    while(1)
+    {
+        //
+        // Look for DHCP servers.
+        //
+        SendDHCPDiscover();
+         
+        //
+        // Set the amount of time to wait for the DHCP reply message.
+        //
+        //g_ui32Target = g_ui32Ticks + g_ui32Delay;
+         
+        g_ui32DCHPTicks = 0;
+        g_ui32Target = g_ui32DCHPTicks + g_ui32Delay;
+        
+        //
+        // Wait until a packet is received or the timeout has occurred.
+        //
+        do{
+        	
+        	PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+                      (g_ui32DCHPTicks > g_ui32Target));
+        	
+        	
+        	if(uip_newdata())
+        	{
+        		dhcpexist++;
+        		uip_flags &= ~(UIP_NEWDATA);
+				
+            	//
+            	// See if this is the expected DHCP reply.
+            	//
+            	res = ParseDHCPReply();
+            	if(res == DHCP_OFFER)
+            	{
+                	g_ui8Count =0;
+                	gComparePass = 1;
+                	
+                	break;
+            	}
+        	}
+        		
+    	}while(g_ui32DCHPTicks < g_ui32Target);
+    	
+    	
+    	if(gComparePass == 1)
+    	{		
+    		gComparePass = 0;
+    		break;
+    	}
+    	
+        
+//        PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+//                      (g_ui32DCHPTicks > g_ui32Target));
+//
+//        
+//        //
+//        // See if a packet has been received.
+//        //
+//        if(uip_newdata())
+//        {
+//        	
+//        	//
+//            // Clear the new data flag so that this packet will only be
+//            // examined one time.
+//            //
+//            uip_flags &= ~(UIP_NEWDATA);
+//
+//            //
+//            // See if this is the expected DHCP reply.
+//            //
+//            res = ParseDHCPReply();
+//            if(res == DHCP_OFFER)
+//            {
+//                g_ui8Count =0;
+//                break;
+//            }
+//            else
+//            {	
+//            	g_ui32DCHPTicks = 0;
+//        		g_ui32Target = g_ui32DCHPTicks + g_ui32Delay;
+//            	PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+//                      (g_ui32DCHPTicks > g_ui32Target));
+//                if(uip_newdata())
+//        		{
+//        			
+//        			//
+//            		// Clear the new data flag so that this packet will only be
+//            		// examined one time.
+//            		//
+//            		uip_flags &= ~(UIP_NEWDATA);
+//
+//            		//
+//            		// See if this is the expected DHCP reply.
+//            		//
+//            		res = ParseDHCPReply();
+//            		if(res == DHCP_OFFER)
+//            		{
+//                		g_ui8Count =0;
+//                		break;
+//            		}
+//            		
+//        		}
+//        	}	
+//        }
+//        else
+//        	dhcpexist++;
+    	
+    	
+    	
+    	
+        //
+        // If the delay between DHCP requests is less than 60 seconds, double
+        // the delay time.  This avoids constantly slamming the network with
+        // requests.
+        //
+        
+        if(g_ui8Count < UIP_DHCP_DISCOVER_TIMES)
+        {
+            g_ui8Count++;
+        }
+        else    ////Jerry130807   handle DHCPDiscover timeout
+        {
+        		DPRINTF(("DHCPDiscover Timeout.\n"));
+        		
+        		EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+        		ui32failReason = (ui32failReason & 0xFF00FFFF) | 0xFF010000 ;
+    			EEPROMProgram(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+        		
+    				//bit[16:23] update fail reason,0x01: dhcp fail,0x02: tftp fail, bit[24:31] update status, 0x01 success,0xFF fail 
+//    				ui32failReason = HWREG(FLASH_ADDR_UPDATE);
+//    				FlashErase(FLASH_ADDR_UPDATE);
+//    				ui32failReason = (ui32failReason & 0xFF00FFFF) | (0xFF01<<16);
+//    				FlashProgram(&ui32failReason, FLASH_ADDR_UPDATE, 4);
+    				
+    				
+        		EEPROMRead(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+    			ui32retrycount = (ui32retrycount & 0xFF) + 1; 		  
+    			EEPROMProgram(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+    			
+        		HWREG(NVIC_ST_CTRL) = 0x0;
+				CallApplication(APP_START_ADDRESS);
+        }	
+        // timeout handling? PT_RESTART(&g_sThread);
+    }
+	
+    //
+    // A server responded, now try to get a lease. This loop is explicitly
+    // exited when a valid DHCP configuration is received.
+    //
+    while(1)
+    {
+        //
+        // Request a lease from the DHCP server.
+        //
+        SendDHCPRequest();
+
+        //
+        // Set the amount of time to wait for the DHCP reply message.
+        //
+        //g_ui32Target = g_ui32Ticks + g_ui32Delay;
+       
+        g_ui32DCHPTicks = 0;
+        g_ui32Target = g_ui32DCHPTicks + g_ui32Delay;
+       
+        do{
+        	PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+                      (g_ui32DCHPTicks > g_ui32Target));
+        	
+        	if(uip_newdata())
+        	{
+        		uip_flags &= ~(UIP_NEWDATA);
+
+            	//
+            	// See if this is the expected DHCP reply.
+            	//
+            	res = ParseDHCPReply();
+            	if(res == DHCP_ACK)
+            	{
+                	
+                	ui32retrycount = 0x00; 		  
+    				EEPROMProgram(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+                	gComparePass = 1;
+                	break;
+            	}
+        	}	
+    		
+    	}while(g_ui32DCHPTicks < g_ui32Target);
+    	if(gComparePass == 1)
+    	{	
+    		gComparePass = 0;
+    		break;
+    	}
+    	
+
+        //
+        // Wait until a packet is received or the timeout has occurred.
+       	 //
+//        PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+//                      (g_ui32DCHPTicks > g_ui32Target));
+//		
+//        //
+//        // See if a packet has been received.
+//        //
+//        if(uip_newdata())
+//        {
+//            //
+//            // Clear the new data flag so that this packet will only be
+//            // examined one time.
+//            //
+//            uip_flags &= ~(UIP_NEWDATA);
+//
+//            //
+//            // See if this the expected DHCP reply.
+//            //
+//            res = ParseDHCPReply();
+//            	
+//            if(res == DHCP_ACK)
+//            {
+//    			ui32retrycount = 0x00; 		  
+//    			EEPROMProgram(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+//                break;
+//            }
+//            else
+//            {	
+//            	g_ui32DCHPTicks = 0;
+//        		g_ui32Target = g_ui32DCHPTicks + g_ui32Delay;
+//            	PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+//                      (g_ui32DCHPTicks > g_ui32Target));
+//                if(uip_newdata())
+//        		{
+//        			
+//        			//
+//            		// Clear the new data flag so that this packet will only be
+//            		// examined one time.
+//            		//
+//            		uip_flags &= ~(UIP_NEWDATA);
+//
+//            		//
+//            		// See if this is the expected DHCP reply.
+//            		//
+//            		res = ParseDHCPReply();
+//            		if(res == DHCP_ACK)
+//            		{
+//                		ui32retrycount = 0x00; 		  
+//    					EEPROMProgram(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+//                		break;
+//            		}
+//            		
+//        		}
+//        	}	
+//        }
+        
+		
+        //
+        // If the delay between DHCP requests is less than 60 seconds, double
+        // the delay time.  This avoids constantly slamming the network with
+        // requests.
+        //
+         if(g_ui8Count < UIP_DHCP_DISCOVER_TIMES)
+        {
+            g_ui8Count++;
+        }
+        else  //Jerry130807   handle DHCPRequest timeout
+        {
+        		DPRINTF(("DHCPRequest Timeout.\n"));
+        		
+        		EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+    				//bit[16:23] update fail reason,0x01: dhcp fail,0x02: tftp fail, bit[24:31] update status, 0x01 success,0xFF fail 
+    			ui32failReason = (ui32failReason & 0xFF00FFFF) | 0xFF010000; 
+    			EEPROMProgram(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+//    				ui32failReason = HWREG(FLASH_ADDR_UPDATE);
+//    				FlashErase(FLASH_ADDR_UPDATE);
+//    				ui32failReason = (ui32failReason & 0xFF00FFFF) | (0xFF01<<16);
+//    				FlashProgram(&ui32failReason, FLASH_ADDR_UPDATE, 4);
+    				
+        		EEPROMRead(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+    			ui32retrycount = (ui32retrycount & 0xFF) + 1;; 		  
+    			EEPROMProgram(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+        		
+        		HWREG(NVIC_ST_CTRL) = 0x0;
+				CallApplication(APP_START_ADDRESS);
+        }	
+        // timeout handling? PT_RESTART(&g_sThread);
+    }
+
+    //
+    // Reconfigure the UDP socket to target the TFTP port on the server.
+    //
+    uip_ipaddr_copy(&g_pConn->ripaddr, g_sTFTPAddr);
+    uip_udp_bind(g_pConn, HTONS(13633));
+
+    //
+    // Send a TFTP read request.
+    //
+    SendTFTPGet();
+
+    //
+    // Since the first TFTP read request will result in an ARP request, delay
+    // for just a bit and then re-issue the TFTP read request.
+    //
+    PT_YIELD(&g_sThread);
+
+    //
+    // Resend the TFTP read request.  If the ARP request has already been
+    // answered, this will go out as is and avoid the two second timeout below.
+    //
+    SendTFTPGet();
+
+    //
+    // Start the TFTP transfer from block one.
+    //
+    g_ui32TFTPBlock = 1;
+
+    //
+    // Loop forever.  This loop is explicitly exited when the TFTP transfer has
+    // completed.
+    //
+    while(1)
+    {
+        //
+        // Set the amount of time to wait for the TFTP data packet.
+        //
+        g_ui32Target = g_ui32Ticks + (SYSTICKHZ * 8);
+
+        //
+        // Wait until a packet is received or the timeout has occurred.
+        //
+        PT_WAIT_UNTIL(&g_sThread, uip_newdata() ||
+                      (g_ui32Ticks > g_ui32Target));
+
+        
+        //
+        // See if a packet has been received.
+        //
+        if(uip_newdata())
+        {
+            
+            //
+            // Clear the new data flag so that this packet will only be
+            // examined one time.
+            //
+            uip_flags &= ~(UIP_NEWDATA);
+
+            //
+            // See if this is a TFTP data packet.
+            //
+            if(ParseTFTPData() == 1)
+            {
+                break;
+            }
+        }
+        else
+        {
+            //
+            // The transfer timed out, so send a new TFTP read request.
+            //
+            
+            /* Disable ARP Broaccast filter */
+            if (NCSI_Issue_EnableBcastFilter(PackageID,ChannelID,1,0,0,0) != 0)
+                DPRINTF(("!TFTP:%d.%d Enable ARP Filter Failed\n",PackageID, ChannelID));
+            SendTFTPGet();
+
+            //
+            // Start the TFTP transfer from block one.
+            //
+            g_ui32TFTPBlock = 1;
+            
+            //Jerry130807   handle tftp timeout
+            timeout_flag++;
+            if(timeout_flag >=10)   //wait 10 sec
+            {
+            	DPRINTF(("TFTP Timeout.\n"));
+            	  
+            	EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+            	//bit[16:23] update fail reason,0x01: dhcp fail,0x02: tftp fail, bit[24:31] update status, 0x01 success,0xFF fail 
+    			ui32failReason = (ui32failReason & 0xFF00FFFF) | 0xFF020000; 		  
+    			EEPROMProgram(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+    						
+//    						ui32failReason = HWREG(FLASH_ADDR_UPDATE);
+//    						FlashErase(FLASH_ADDR_UPDATE);
+//    						ui32failReason = (ui32failReason & 0xFF00FFFF) | (0xFF02<<16);
+//    						FlashProgram(&ui32failReason, FLASH_ADDR_UPDATE, 4);
+            	  
+    			
+            	HWREG(NVIC_ST_CTRL) = 0x0;
+				CallApplication(APP_START_ADDRESS);
+            }	
+        }
+    }
+
+    //
+    // Wait for a bit to make sure that the final ACK packet is transmitted.
+    //
+    g_ui32Target = g_ui32Ticks + (SYSTICKHZ / 4);
+    while(g_ui32Ticks < g_ui32Target)
+    {
+        PT_YIELD(&g_sThread);
+    }
+
+    //
+    // Disable SysTick.
+    //
+    HWREG(NVIC_ST_CTRL) = 0x0;
+
+    
+    
+    EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+    //bit[24:31] 0x01:success tftp update bit[15:23] 0x00:clear tftp update fail reason code,bit[0:7] 0x00 clear update flag
+    ui32failReason = (ui32failReason & 0x0000FFFF) | 0x01000000;   
+    EEPROMProgram(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+//    ui32failReason = HWREG(FLASH_ADDR_UPDATE);
+//    FlashErase(FLASH_ADDR_UPDATE);
+//    ui32failReason = (ui32failReason & 0x0000FFFF) | 0x01<<24;
+//    FlashProgram(&ui32failReason, FLASH_ADDR_UPDATE, 4);
+    
+    //
+    // Launch the loaded application.
+    //
+    CallApplication(APP_START_ADDRESS);
+
+    //
+    // The microcontroller should never return, so this should never be
+    // reached.
+    //
+    while(1)
+    {
+    }
+
+    //
+    // End the proto-thread.
+    //
+
+    PT_END(&g_sThread);
+
+}
+#endif
+
+
+//*****************************************************************************
+//
+//! Starts the update process.
+//!
+//! This function starts the Ethernet firmware update process.  The DHCP (as
+//! defined by RFC2131 at http://www.ietf.org/rfc/rfc2131.txt) and TFTP (as
+//! defined by RFC1350 at http://tools.ietf.org/html/rfc1350) protocols are
+//! used to transfer the firmware image over Ethernet.
+//!
+//! \return Never returns.
+//
+//*****************************************************************************
+void
+TFTPUpdate(void)
+{   
+#if 0
+	uint32_t ui32Temp,ui32Idx;
+    uint8_t ui8Port;
+    uip_ipaddr_t sAddr;
+    uint16_t bmc_mac_offset=0x0548;
+    int retval=0;
+    uint8_t count=0;
+    uint32_t ui32failReason=0;
+    
+    //
+    // Do any setup required to configure the Ethernet controller
+    // appropriately for boot loader use.
+    //
+    ConfigureEnet();
+    
+    //
+    // Set a size of flash used in a application update.
+    //
+    g_ui32FlashEnd = MCU_FLASH_SIZE - APP_START_ADDRESS;
+    
+    //
+    // Setup SysTick.
+    //
+    HWREG(NVIC_ST_RELOAD) = ((200000000 / 16) / SYSTICKHZ) - 1;
+    
+    HWREG(NVIC_ST_CTRL) = (NVIC_ST_CTRL_CLK_SRC | NVIC_ST_CTRL_INTEN |
+                           NVIC_ST_CTRL_ENABLE);
+    
+    
+    //
+    // If a static MAC address is not being used, then get the MAC address from
+    // the flash user registers.
+    //
+    
+//		ui32Temp0 = HWREG(FLASH_USERREG0);
+//		ui32Temp1 = HWREG(FLASH_USERREG1);
+//		if((ui32Temp0 != 0xffffffff) && (ui32Temp1 != 0xffffffff))
+//		{
+//			g_sMACAddr.addr[0] = ui32Temp0 & 0xff;
+//    	g_sMACAddr.addr[1] = (ui32Temp0 >> 8) & 0xff;
+//    	g_sMACAddr.addr[2] = (ui32Temp0 >> 16) & 0xff;
+//    
+//   		g_sMACAddr.addr[3] = ui32Temp1 & 0xff;
+//    	g_sMACAddr.addr[4] = (ui32Temp1 >> 8) & 0xff;
+//    	g_sMACAddr.addr[5] = (ui32Temp1 >> 16) & 0xff;		
+//		}	
+    
+    Hal_eeprom_read(g_sMACAddr.addr,bmc_mac_offset,6);
+    //DPRINTF(("mac=%x %x %x %x %x %x \n",g_sMACAddr.addr[0],g_sMACAddr.addr[1],g_sMACAddr.addr[2],g_sMACAddr.addr[3],g_sMACAddr.addr[4],g_sMACAddr.addr[5]));
+
+    //
+    // Seed the random number generator from the MAC address.
+    //
+    g_ui32RandomSeed = *(uint32_t *)(g_sMACAddr.addr + 2);
+
+    //
+    // Initialize the uIP stack.
+    //
+    uip_init();
+    *((uint32_t *)(void *)(&sAddr)) = 0x00000000;
+    uip_sethostaddr(sAddr);
+    uip_arp_init();
+    
+    //
+    // Program the MAC address.
+    //
+    SetMACAddr((const uint8_t *)g_sMACAddr.addr);
+    uip_setethaddr(g_sMACAddr);
+    
+    //
+    // Initialize the proto-thread used by the protocol handler.
+    //
+    PT_INIT(&g_sThread);
+
+    //
+    // Create a UDP socket for sending requests to the server.  After the
+    // BOOTP/DHCP portion of the protocol has been handled, this socket will be
+    // reused to communicate with the TFTP server.
+    //
+    *((uint32_t *)(void *)(&sAddr)) = 0xffffffff;
+    g_pConn = uip_udp_new(&sAddr, HTONS(BOOTP_SERVER_PORT));
+    uip_udp_bind(g_pConn, HTONS(BOOTP_CLIENT_PORT));
+    
+    //
+    // Reset the counters that are incremented by SysTick.
+    //
+    g_ui32Ticks = 0;
+    g_ui32PeriodicTimer = 0;
+    g_ui32ARPTimer = 0;
+    
+    //Jerry130721 Initial NCSI
+#if 1
+		extern int NCSI_Start(uint8_t ui8Port);
+		
+		
+		EEPROMRead(&ui32Idx,EEPROM_ADDR_UPDATE,0x04);
+		//ui32Idx = HWREG(FLASH_ADDR_UPDATE);
+		ui8Port = (ui32Idx >> 8) &0xFF;
+		//DPRINTF(("!!. ui8Port=%x ,%x\n",ui32Idx,ui8Port));  //jerry debug
+		do
+		{
+
+			retval = NCSI_Start(ui8Port);
+			count++;
+			
+		}while(retval!=0 && count<10);
+		if(count == 10)
+		{
+				EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+      	//bit[16:23] update fail reason,0x01: dhcp fail,0x02: tftp fail,0x03:NCSI fail bit[24:31] update status, 0x01 success,0xFF fail 
+    		ui32failReason = (ui32failReason & 0xFF00FFFF) | 0xFF030000; 		  
+    		EEPROMProgram(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+    		DPRINTF(("NCSI Retry Fail \n"));
+		}	
+	  
+#endif 
+    
+
+    //
+    // Main Application Loop.
+    //
+    while(1)
+    {
+        //
+        // See if there is a packet waiting to be read.
+        //
+        if(EnetPacketAvailable())
+        {
+            //
+            // Read the packet from the Ethernet controller.
+            //
+            EnetReadPacket(uip_buf, sizeof(uip_buf), &uip_len);
+            //DPRINTF((" %d\n",((struct uip_udpip_hdr *)&uip_buf[14])->proto));
+            //DPRINTF((" %x\n",((struct uip_eth_hdr *)&uip_buf[0])->type));
+            
+
+            //
+            // See if this is an IP packet.
+            //
+            if((uip_len != 0) &&
+               (((struct uip_eth_hdr *)&uip_buf[0])->type ==
+                HTONS(UIP_ETHTYPE_IP)))
+            {
+                //
+                // Update the ARP tables based on this packet.
+                //
+                if(((struct uip_udpip_hdr *)&uip_buf[14])->proto != 1)  //Ignore ICMP packet
+                {	
+                	uip_arp_ipin();
+
+                	//
+                	// Process this packet.
+                	//
+                	uip_input();
+
+                	//
+                	// See if the processing of this packet resulted in a packet to
+                	// be sent.
+                	//
+                	if(uip_len > 0)
+                	{
+                    	//
+                    	// Update the ARP tables based on the packet to be sent.
+                   	 	//
+                    	
+                    	uip_arp_out();
+
+                    	//
+                    	// Send the packet.
+                    	//
+                    	EnetWritePacket(uip_buf, uip_len);
+
+                    	//
+                    	// Indicate that the packet has been sent.
+                    	//
+                    	uip_len = 0;
+                	}
+                }	
+            }
+
+            //
+            // See if this is an ARP packet.
+            //
+            else if((uip_len != 0) &&
+                    (((struct uip_eth_hdr *)&uip_buf[0])->type ==
+                     HTONS(UIP_ETHTYPE_ARP)))
+            {
+                 
+                //
+                // Process this packet.
+                //
+                uip_arp_arpin();
+
+                //
+                // See if the processing of this packet resulted in a packet to
+                // be sent.
+                //
+                if(uip_len > 0)
+                {
+                    //
+                    // Send the packet.
+                    //
+                    EnetWritePacket(uip_buf, uip_len);
+
+                    //
+                    // Indicate that the packet has been sent.
+                    //
+                    uip_len = 0;
+                }
+            }
+        }
+
+        //
+        // See if the periodic timer has expired.
+        //
+        if(g_ui32PeriodicTimer > UIP_PERIODIC_TIMER_MS)
+        {
+            //
+            // Reset the periodic timer.
+            //
+            g_ui32PeriodicTimer = 0;
+
+            //
+            // Loop through the UDP connections.
+            //
+            for(ui32Temp = 0; ui32Temp < UIP_UDP_CONNS; ui32Temp++)
+            {
+                //
+                // Perform the periodic processing on this UDP connection.
+                //
+                uip_udp_periodic(ui32Temp);
+
+                //
+                // See if the periodic processing of this connection resulted
+                // in a packet to be sent.
+                //
+                if(uip_len > 0)
+                {
+                    //
+                    // Update the ARP tables based on the packet to be sent.
+                    //
+                    uip_arp_out();
+
+                    //
+                    // Send the packet.
+                    //
+                    EnetWritePacket(uip_buf, uip_len);
+
+                    //
+                    // Indicate that the packet has been sent.
+                    //
+                    uip_len = 0;
+                }
+            }
+        }
+
+        //
+        // See if the ARP timer has expired.
+        //
+        if(g_ui32ARPTimer > UIP_ARP_TIMER_MS)
+        {
+            //
+            // Reset the ARP timer.
+            //
+            g_ui32ARPTimer = 0;
+
+            //
+            // Perform periodic processing on the ARP table.
+            //
+            uip_arp_timer();
+        }
+    }
+#endif
+}
+
+//*****************************************************************************
+//
+// Return the MAC address for NCSI handshake purpose 
+//
+//
+//*****************************************************************************
+void 
+GetMACAddr(unsigned char *MACAddr)
+{
+//Jerry add need to modify	
+	MACAddr[5] = g_sMACAddr.addr[0];
+	MACAddr[4] = g_sMACAddr.addr[1];
+	MACAddr[3] = g_sMACAddr.addr[2];
+	MACAddr[2] = g_sMACAddr.addr[3];
+	MACAddr[1] = g_sMACAddr.addr[4];
+	MACAddr[0] = g_sMACAddr.addr[5];
+	
+	return;
+}
diff --unidirectional-new-file -ru f09_tmp/bl_enet_drv.h f09_bootloader_202/bl_enet_drv.h
--- f09_tmp/bl_enet_drv.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_enet_drv.h	2017-08-23 13:37:40.971000000 +0800
@@ -0,0 +1,45 @@
+//*****************************************************************************
+//
+// bl_enet_drv.h - Public header for the lo level, hardware specific Ethernet
+//                 functions used by the boot loader.
+//
+// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#ifndef __BL_ENET_DRV_H__
+#define __BL_ENET_DRV_H__
+
+//*****************************************************************************
+//
+// Functions called from bl_enet.c.
+//
+//*****************************************************************************
+void EnetReadPacket(uint8_t *pui8Buf, uint32_t ui32BufLen,
+                    uint16_t *pui16PktLen);
+void EnetWritePacket(uint8_t *pui8Buf, uint32_t ui32Len);
+void ConfigureEnet(void);
+void SetMACAddr(const unsigned char *pcAddr);
+void ReconfigureEnet(void);
+bool EnetPacketAvailable(void);
+
+#endif
diff --unidirectional-new-file -ru f09_tmp/bl_enet_drv_tm4c.c f09_bootloader_202/bl_enet_drv_tm4c.c
--- f09_tmp/bl_enet_drv_tm4c.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_enet_drv_tm4c.c	2017-08-23 13:37:40.582000000 +0800
@@ -0,0 +1,776 @@
+//*****************************************************************************
+//
+// bl_enet_drv_tm4c.c - Low level, hardware specific Ethernet functions used
+//                      the Ethernet boot loader for Snowflake-class devices.
+//
+// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <string.h>
+#include "inc/hw_types.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_emac.h"
+#include "inc/hw_flash.h"
+#include "inc/hw_gpio.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "driverlib/cpu.h"
+#include "driverlib/emac.h"
+#include "driverlib/rom.h"
+#include "driverlib/sysctl.h"
+#include "bmc_blcfg.h"
+
+//*****************************************************************************
+//
+//! \addtogroup bl_enet_api
+//! @{
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// A prototype for the function (in the startup code) for a predictable length
+// delay.
+//
+//*****************************************************************************
+extern void Delay(uint32_t ui32Count);
+
+//*****************************************************************************
+//
+// Ethernet DMA descriptors.
+//
+// Although uIP uses a single buffer, the MAC hardware needs a minimum of
+// 3 receive descriptors to operate.
+//
+//*****************************************************************************
+#define NUM_TX_DESCRIPTORS      12
+#define NUM_RX_DESCRIPTORS      12
+
+//Jerry130806 add volatile
+volatile tEMACDMADescriptor g_pRxDescriptor[NUM_TX_DESCRIPTORS];   
+volatile tEMACDMADescriptor g_pTxDescriptor[NUM_RX_DESCRIPTORS];
+
+uint32_t g_ui32RxDescIndex;
+uint32_t g_ui32TxDescIndex;
+
+//*****************************************************************************
+//
+// Transmit and receive buffers.
+//
+//*****************************************************************************
+#define RX_BUFFER_SIZE          1536
+#define TX_BUFFER_SIZE          1536
+uint8_t g_pucRxBuffer[RX_BUFFER_SIZE];
+uint8_t g_pucTxBuffer[TX_BUFFER_SIZE];
+
+#define MAC_ADDR_OFFSET         (EMAC_O_ADDR1L - EMAC_O_ADDR0L)
+#define EMAC_O_ADDRL(n)         (EMAC_O_ADDR0L + (MAC_ADDR_OFFSET * (n)))
+#define EMAC_O_ADDRH(n)         (EMAC_O_ADDR0H + (MAC_ADDR_OFFSET * (n)))
+
+
+//*****************************************************************************
+//
+// System clock frequency.
+//
+//*****************************************************************************
+static uint32_t g_ui32ClkFreq;
+
+//*****************************************************************************
+//
+//! Reads a packet from the Ethernet controller.
+//!
+//! This function reads a packet from the Ethernet controller into the uIP
+//! packet buffer.  It assumes that a packet is available to be read.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EnetReadPacket(uint8_t *pucBuf, uint32_t ui32BufLen,
+               uint16_t *pui16PktLen)
+{
+    uint32_t ui32FrameLen, ui32Loop;
+
+    //
+    // By default, we assume we got a bad frame.
+    //
+    ui32FrameLen = 0;
+
+    //
+    // Make sure that we own the receive descriptor.
+    //
+    if(!(g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus & DES0_RX_CTRL_OWN))
+    {
+        //
+        // We own the receive descriptor so check to see if it contains a valid
+        // frame.  Look for a descriptor error, indicating that the incoming
+        // packet was truncated or, if this is the last frame in a packet,
+        // the receive error bit.
+        //
+        if(!(g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus &
+             DES0_RX_STAT_ERR))
+        {
+            //
+            // We have a valid frame so copy the content to the supplied
+            // buffer. First check that the "last descriptor" flag is set.  We
+            // sized the receive buffer such that it can always hold a valid
+            // frame so this flag should never be clear at this point but...
+            //
+            if(g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus &
+                    DES0_RX_STAT_LAST_DESC)
+            {
+                ui32FrameLen = 
+                            (g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus
+                             & DES0_RX_STAT_FRAME_LENGTH_M)
+                             >> DES0_RX_STAT_FRAME_LENGTH_S;
+
+                //
+                // Is the frame too big for the supplied buffer?  If so, we
+                // skip it.
+                //
+                if(ui32FrameLen <= ui32BufLen)
+                {
+                    //
+                    // The buffer can contain the frame so copy the data from
+                    // the DMA receive buffer into the provided frame buffer.
+                    //
+                    for(ui32Loop = 0; ui32Loop < ui32FrameLen; ui32Loop++)
+                    {
+                        pucBuf[ui32Loop] = g_pucRxBuffer[ui32Loop];
+                    }
+                }
+            }
+        }
+
+        //
+        // Move on to the next descriptor in the chain.
+        //
+        g_ui32RxDescIndex++;
+        if(g_ui32RxDescIndex == NUM_RX_DESCRIPTORS)
+        {
+            g_ui32RxDescIndex = 0;
+        }
+
+        //
+        // Mark the next descriptor in the ring as available for the receiver
+        // to write into.
+        //
+        g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus = DES0_RX_CTRL_OWN;
+    }
+
+    //
+    // Tell the caller how many bytes were written into the buffer.
+    //
+    *pui16PktLen = (uint16_t)ui32FrameLen;
+}
+
+//*****************************************************************************
+//
+//! Writes a packet to the Ethernet controller.
+//!
+//! This function writes a packet from the uIP packet buffer into the Ethernet
+//! controller and requests that the packet be transmitted.  It will busy wait
+//! until there is space in the transmit FIFO.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+EnetWritePacket(uint8_t *pucBuf, uint32_t ui32Len)
+{
+    uint32_t ui32Loop;
+
+    //
+    // Wait for the previous packet to be transmitted.
+    //
+    while(g_pTxDescriptor[g_ui32TxDescIndex].ui32CtrlStatus & DES0_TX_CTRL_OWN)
+    {
+        //
+        // Spin and waste time.
+        //
+    }
+
+    //
+    // Check that we're not going to overflow the transmit buffer.  This
+    // shouldn't be necessary since the uIP buffer is smaller than our DMA
+    // transmit buffer but, just in case...
+    //
+    if(ui32Len > TX_BUFFER_SIZE)
+    {
+        ui32Len = TX_BUFFER_SIZE;
+    }
+
+    //
+    // Copy the packet data into the transmit buffer.
+    //
+    for(ui32Loop = 0; ui32Loop < ui32Len; ui32Loop++)
+    {
+        g_pucTxBuffer[ui32Loop] = pucBuf[ui32Loop];
+    }
+
+    //
+    // Move to the next descriptor.
+    //
+    g_ui32TxDescIndex++;
+    if(g_ui32TxDescIndex == NUM_TX_DESCRIPTORS)
+    {
+        g_ui32TxDescIndex = 0;
+    }
+
+    //
+    // Fill in the packet size and tell the transmitter to start work.
+    //
+    g_pTxDescriptor[g_ui32TxDescIndex].ui32Count = (uint32_t)ui32Len;
+    g_pTxDescriptor[g_ui32TxDescIndex].ui32CtrlStatus = DES0_TX_CTRL_LAST_SEG
+            | DES0_TX_CTRL_FIRST_SEG | DES0_TX_CTRL_INTERRUPT
+            | DES0_TX_CTRL_IP_ALL_CKHSUMS | DES0_TX_CTRL_CHAINED
+            | DES0_TX_CTRL_OWN;
+
+    //
+    // Tell the DMA to re-acquire the descriptor now that we've filled it in.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_TXPOLLD) = 0;
+}
+
+//*****************************************************************************
+//
+//! Configures the Ethernet controller DMA engine and descriptors.
+//!
+//! This function configures the Ethernet DMA engine and initializes the
+//! transmit and receive descriptor and buffers.
+//!
+//! \return None.
+//
+//*****************************************************************************
+static void
+ConfigureEnetDMA(void)
+{
+    uint32_t ui32Loop;
+
+    //
+    // Start from the beginning of the descriptor ring.
+    //
+    g_ui32RxDescIndex = 0;
+    g_ui32TxDescIndex = 0;
+
+    //
+    // Initialize each of the transmit descriptors.  Note that we leave the OWN
+    // bit clear here since we have not set up any transmissions yet.
+    //
+    for(ui32Loop = 0; ui32Loop < NUM_TX_DESCRIPTORS; ui32Loop++)
+    {
+        g_pTxDescriptor[ui32Loop].ui32Count = DES1_TX_CTRL_SADDR_INSERT
+                | (TX_BUFFER_SIZE << DES1_TX_CTRL_BUFF1_SIZE_S);
+        g_pTxDescriptor[ui32Loop].pvBuffer1 = g_pucTxBuffer;
+        g_pTxDescriptor[ui32Loop].DES3.pLink =
+                             (ui32Loop == NUM_TX_DESCRIPTORS - 1) ?
+                             g_pTxDescriptor : &g_pTxDescriptor[ui32Loop + 1];
+        g_pTxDescriptor[ui32Loop].ui32CtrlStatus = DES0_TX_CTRL_LAST_SEG |
+                DES0_TX_CTRL_FIRST_SEG | DES0_TX_CTRL_INTERRUPT |
+                DES0_TX_CTRL_CHAINED | DES0_TX_CTRL_IP_ALL_CKHSUMS;
+    }
+
+    //
+    // Initialize each of the receive descriptors.  We clear the OWN bit here
+    // to make sure that the receiver doesn't start writing anything
+    // immediately.
+    //
+    for(ui32Loop = 0; ui32Loop < NUM_RX_DESCRIPTORS; ui32Loop++)
+    {
+        g_pRxDescriptor[ui32Loop].ui32CtrlStatus = 0;
+        g_pRxDescriptor[ui32Loop].ui32Count = DES1_RX_CTRL_CHAINED |
+                (RX_BUFFER_SIZE << DES1_RX_CTRL_BUFF1_SIZE_S);
+        g_pRxDescriptor[ui32Loop].pvBuffer1 = g_pucRxBuffer;
+        g_pRxDescriptor[ui32Loop].DES3.pLink =
+                (ui32Loop == NUM_RX_DESCRIPTORS - 1) ?
+                g_pRxDescriptor : &g_pRxDescriptor[ui32Loop + 1];
+    }
+
+    //
+    // Set the descriptor pointers in the hardware.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_RXDLADDR) = (uint32_t)g_pRxDescriptor;
+    HWREG(EMAC0_BASE + EMAC_O_TXDLADDR) = (uint32_t)g_pTxDescriptor;
+
+    //
+    // Start from the beginning of both descriptor chains.  We actually set
+    // the transmit descriptor index to the last descriptor in the chain
+    // since it will be incremented before use and this means the first
+    // transmission we perform will use the correct descriptor.
+    //
+    g_ui32RxDescIndex = 0;
+    g_ui32TxDescIndex = (NUM_TX_DESCRIPTORS - 1);
+
+    //
+    // Mark the first receive descriptor as available to the DMA to start
+    // the receive processing.
+    //
+    g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus |= DES0_RX_CTRL_OWN;
+
+    //
+    // Enable the transmitter and receiver.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_DMAOPMODE) |= (EMAC_DMAOPMODE_ST |
+                                             EMAC_DMAOPMODE_SR);
+    HWREG(EMAC0_BASE + EMAC_O_CFG) |= (EMAC_CFG_TE | EMAC_CFG_RE);
+}
+
+
+//*****************************************************************************
+//
+//! Configures the RMII external
+//!
+//! This function configures the RMII PHY preparing it for use by
+//! the boot loader.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void Configure_RMII_PHY(void)      //Jerry130806
+{
+    volatile uint32_t ui32Reg;
+
+    ROM_SysCtlDelay(g_ui32ClkFreq / (10 * 3));
+
+#if (EMAC_PHY_ADDRESS == 0x19) //skip Ext PHY initial
+    ui32Reg = (EMAC_CFG_FES |
+    		   EMAC_CFG_DUPM |
+    		   EMAC_CFG_IPC | EMAC_CFG_PRELEN_7 | EMAC_CFG_IFG_96);
+
+    HWREG(EMAC0_BASE + EMAC_O_CFG) = ui32Reg | EMAC_CFG_PS;
+#else
+    uint16_t ui16Val;
+
+    //
+    // When using an external RMII PHY, we need to acquire link before we can
+    // determine how to configure the MAC.  Unfortunately, the bit signalling
+    // on RMII changes depending upon whether the PHY is configured to use
+    // 10Mbps or 100Mbps and we need to tell the MAC which signalling method
+    // to use. To that end, setup the indexed PHY data register for BMCR
+    // auto-negotiation.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_MIIDATA) = EPHY_BMCR_ANEN | EPHY_BMCR_RESTARTAN;
+
+    //
+    // Tell the MAC to write to the BMCR PHY register.
+    //
+    ui32Reg = HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_CR_M;
+    ui32Reg |= (EPHY_BMCR << EMAC_MIIADDR_MII_S) |
+               (EMAC_PHY_ADDRESS << EMAC_MIIADDR_PLA_S) | EMAC_MIIADDR_MIIW |
+               EMAC_MIIADDR_MIIB;
+    HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = ui32Reg;
+
+    //
+    // Wait for the write to complete.
+    //
+    while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+    {
+    }
+
+    //
+    // Wait for auto-negotiation to complete.
+    //
+    do
+    {
+        //
+        // Make sure the MII is idle.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Tell the MAC to read the given PHY register.
+        //
+        ui32Reg = (HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_CR_M);
+        ui32Reg |= (EPHY_BMSR << EMAC_MIIADDR_MII_S) |
+                   (EMAC_PHY_ADDRESS << EMAC_MIIADDR_PLA_S) |
+                    EMAC_MIIADDR_MIIB;
+        HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = ui32Reg;
+
+        //
+        // Wait for the read to complete.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Get the result.
+        //
+        ui16Val = HWREG(EMAC0_BASE + EMAC_O_MIIDATA) & EMAC_MIIDATA_DATA_M;
+        ROM_SysCtlDelay(g_ui32ClkFreq / (10 * 3));
+    }
+    while (!(ui16Val & EPHY_BMSR_ANC));
+
+    //
+    // Wait for link to be acquired.
+    //
+    while(!(ui16Val & EPHY_BMSR_LINKSTAT))
+    {
+        //
+        // Make sure the MII is idle.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Tell the MAC to read the given PHY register.
+        //
+        ui32Reg = (HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_CR_M);
+        ui32Reg |= (EPHY_BMSR << EMAC_MIIADDR_MII_S) |
+                   (EMAC_PHY_ADDRESS << EMAC_MIIADDR_PLA_S) |
+                    EMAC_MIIADDR_MIIB;
+        HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = ui32Reg;
+
+        //
+        // Wait for the read to complete.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Get the result.
+        //
+        ui16Val = HWREG(EMAC0_BASE + EMAC_O_MIIDATA) & EMAC_MIIDATA_DATA_M;
+    }
+
+    //
+    // Get the link speed.
+    // Make sure the MII is idle.
+    //
+    while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+    {
+    }
+
+    //
+    // Tell the MAC to read the given PHY register.
+    //
+    ui32Reg = (HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_CR_M);
+    ui32Reg |= (EPHY_STS << EMAC_MIIADDR_MII_S) |
+               (EMAC_PHY_ADDRESS << EMAC_MIIADDR_PLA_S) |
+                EMAC_MIIADDR_MIIB;
+    HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = ui32Reg;
+
+    //
+    // Wait for the read to complete.
+    //
+    while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+    {
+    }
+
+    //
+    // Get the result.
+    //
+    ui16Val = HWREG(EMAC0_BASE + EMAC_O_MIIDATA) & EMAC_MIIDATA_DATA_M;
+
+    //
+    // Set the configuration flags as specified.  Note that we unconditionally
+    // OR in the EMAC_CFG_PS bit here since this implementation supports only
+    // MII and RMII interfaces to the PHYs.
+    //
+    ui32Reg = ((ui16Val & EPHY_STS_SPEED) ? 0 : EMAC_CFG_FES) |
+              ((ui16Val & EPHY_STS_DUPLEX) ? EMAC_CFG_DUPM : 0) |
+              EMAC_CFG_IPC | EMAC_CFG_PRELEN_7 | EMAC_CFG_IFG_96;
+
+    HWREG(EMAC0_BASE + EMAC_O_CFG) = ui32Reg | EMAC_CFG_PS;
+#endif
+}
+
+//*****************************************************************************
+//
+//! Configures the Ethernet controller.
+//!
+//! This function configures the Ethernet controller, preparing it for use by
+//! the boot loader.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ConfigureEnet(void)
+{
+    volatile uint32_t ui32Reg;
+    
+    //
+    // Set the system clocking to run at 20MHz from the PLL.
+    // This is the minimum system clock needed for the EMAC peripheral.
+    //
+    ROM_SysCtlMOSCConfigSet(SYSCTL_MOSC_HIGHFREQ);
+    g_ui32ClkFreq = ROM_SysCtlClockFreqSet(
+            (SYSCTL_OSC_INT | SYSCTL_USE_PLL | SYSCTL_CFG_VCO_320), 20000000);
+
+    //
+    // Enable the uDMA module.
+    //
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UDMA);
+
+    //
+    // Enable and reset the Ethernet modules.
+    //
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EMAC);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EPHY);
+    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_EMAC);
+    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_EPHY);
+
+    //
+    // Wait for the MAC to be ready.
+    //
+    while(ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_EMAC) != true)
+    {
+    }
+
+#ifdef ENET_ENABLE_LEDS
+    //
+    // Configure the Ethernet LEDs if requested.
+    //
+
+    // TODO
+
+#endif
+
+    //
+    // Configure PHY and PHY clocking as needed.
+    //
+#ifdef EMAC_EXTERNAL_PHY_RMII
+    HWREG(EMAC0_BASE + EMAC_O_PC) = (EMAC_PC_PHYEXT | EMAC_PC_PINTFS_RMII);
+    HWREG(EMAC0_BASE + EMAC_O_CC) = (EMAC_CC_ECEXT | EMAC_CC_CLKEN |
+                                     EMAC_CC_CS_PA7);
+#endif
+
+#ifdef EMAC_EXTERNAL_PHY_MII
+    HWREG(EMAC0_BASE + EMAC_O_PC) = EMAC_PC_PINTFS_IMII;
+    HWREG(EMAC0_BASE + EMAC_O_CC) = (EMAC_CC_ECEXT | EMAC_CC_CLKEN);    
+#endif
+
+#ifdef EMAC_INTERNAL_PHY
+    HWREG(EMAC0_BASE + EMAC_O_PC) = EMAC_PC_PINTFS_IMII;
+    
+    //
+    // Reset the internal PHY to latch changes.
+    //
+    ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_EPHY);
+    while(!ROM_SysCtlPeripheralReady(SYSCTL_PERIPH_EPHY))
+    {
+    }
+    ROM_SysCtlDelay(1000);
+#endif
+
+    //
+    // Now that the PHY is setup, issue a software reset via the EMAC
+    // peripheral's control and wait for it to complete.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_DMABUSMOD) |= EMAC_DMABUSMOD_SWR;
+    while(HWREG(EMAC0_BASE + EMAC_O_DMABUSMOD) & EMAC_DMABUSMOD_SWR)
+    {
+    }
+
+    //
+    // Burst lengths of 4, 8 word descriptors, mixed burst, fixed priority.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_DMABUSMOD) = (4 << EMAC_DMABUSMOD_PBL_S) |
+                                           (8 << EMAC_DMABUSMOD_DSL_S) |
+                                           EMAC_DMABUSMOD_ATDS |
+                                           EMAC_DMABUSMOD_MB |
+                                           EMAC_DMABUSMOD_DA;
+    //
+    // Max PHY clock reference frequency for a 20MHz system.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = (HWREG(EMAC0_BASE + EMAC_O_MIIADDR) &
+                               ~(EMAC_MIIADDR_CR_M)) | EMAC_MIIADDR_CR_CSRDIV8;
+
+#ifdef EMAC_EXTERNAL_PHY_RMII
+    Configure_RMII_PHY();
+#else
+    //
+    // With MII, the signalling is the same for both speeds so we don't need to
+    // include code to wait for the link to be acquired prior to setting up.
+    // Set MAC configuration options.
+    //
+    ui32Reg = EMAC_CFG_DUPM | EMAC_CFG_IPC | EMAC_CFG_PRELEN_7 |
+              EMAC_CFG_IFG_96;
+
+    HWREG(EMAC0_BASE + EMAC_O_CFG) = ui32Reg | EMAC_CFG_PS;
+#endif
+
+    //
+    // Use the default maximum frame size. Turn off the override.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_WDOGTO) &= ~EMAC_WDOGTO_PWE;
+
+    //
+    // Set the operating mode register.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_DMAOPMODE) = (EMAC_DMAOPMODE_RSF |
+                                            EMAC_DMAOPMODE_TSF |
+                                            EMAC_DMAOPMODE_TTC_64 |
+                                            EMAC_DMAOPMODE_RTC_64);
+#ifndef EMAC_EXTERNAL_PHY_RMII
+    //
+    // Wait for the link to become active.  If we are using an external
+    // RMII PHY, we already waited for link to be acquired prior to
+    // configuring the MAC so don't wait again here.
+    //
+    while(!(ui16Val & EPHY_BMSR_LINKSTAT))
+    {
+        //
+        // Make sure the MII is idle.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Tell the MAC to read the given PHY register.
+        //
+        ui32Reg = (HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_CR_M);
+        ui32Reg |= (EPHY_BMSR << EMAC_MIIADDR_MII_S) |
+                   (EMAC_PHY_ADDRESS << EMAC_MIIADDR_PLA_S) |
+                    EMAC_MIIADDR_MIIB;
+        HWREG(EMAC0_BASE + EMAC_O_MIIADDR) = ui32Reg;
+
+        //
+        // Wait for the read to complete.
+        //
+        while(HWREG(EMAC0_BASE + EMAC_O_MIIADDR) & EMAC_MIIADDR_MIIB)
+        {
+        }
+
+        //
+        // Get the result.
+        //
+        ui16Val = HWREG(EMAC0_BASE + EMAC_O_MIIDATA) & EMAC_MIIDATA_DATA_M;
+    }
+#endif
+
+    //
+    // Set MAC filtering options.  We receive all broadcast and multicast
+    // packets along with those addressed specifically for us.
+    //
+    ui32Reg = HWREG(EMAC0_BASE + EMAC_O_FRAMEFLTR) & ~(0x8001073F);
+    ui32Reg |= (EMAC_FRAMEFLTR_SAF | EMAC_FRAMEFLTR_PM);
+
+    //
+    // Clear any pending interrupts.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_DMARIS) |= HWREG(EMAC0_BASE + EMAC_O_DMARIS);
+    HWREG(EMAC0_BASE + EMAC_O_EPHYMISC) |= HWREG(EMAC0_BASE + EMAC_O_EPHYMISC);
+
+    //
+    // Configure the MAC DMA controller.
+    //
+    ConfigureEnetDMA();
+}
+
+//*****************************************************************************
+//
+//! Sets the Ethernet MAC address.
+//!
+//! This function sets the Ethernet MAC address for this board.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+SetMACAddr(const uint8_t *pui8Addr)
+{
+    //
+    // Set the high 2 bytes of the MAC address.  Note that we must set the
+    // registers in this order since the address is latched internally
+    // on the write to EMAC_O_ADDRL.
+    //
+    HWREG(EMAC0_BASE + EMAC_O_ADDRH(0)) =
+          ((HWREG(EMAC0_BASE + EMAC_O_ADDRH(0)) & 0xFFFF0000) |
+           pui8Addr[4] | (pui8Addr[5] << 8));
+
+    //
+    // Set the first 4 bytes of the MAC address
+    //
+    HWREG(EMAC0_BASE + EMAC_O_ADDRL(0)) = (pui8Addr[0] | (pui8Addr[1] << 8) |
+                                          (pui8Addr[2] << 16) |
+                                          (pui8Addr[3] << 24));
+}
+
+//*****************************************************************************
+//
+//! Performs any required configuration when the boot loader is invoked by an
+//! application.
+//!
+//! This function is called in cases where the boot loader is invoked from a
+//! running application rather than from a system reset.  It performs any
+//! configuration requires to get the hardware into the state expected to allow
+//! operation of the Ethernet boot loader.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ReconfigureEnet(void)
+{
+    //
+    // TODO: Tidy up clock settings and configure the MAC.
+    //
+
+    //
+    // Configure the MAC DMA controller.
+    //
+    ConfigureEnetDMA();
+}
+
+//*****************************************************************************
+//
+//! Checks whether a packet is available to be read.
+//!
+//! This function determines whether or not a packet has been received by the
+//! Ethernet controller and is available to be read.
+//!
+//! \return Returns \b true if a packet is available or \b false otherwise.
+//
+//*****************************************************************************
+bool
+EnetPacketAvailable(void)
+{
+    //
+    // If the current receive descriptor is no longer owned by the hardware,
+    // we have a packet waiting to be received.
+    //
+    if(!(g_pRxDescriptor[g_ui32RxDescIndex].ui32CtrlStatus & DES0_RX_CTRL_OWN))
+    {
+        return(true);
+    }
+    else
+    {
+        return(false);
+    }
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
diff --unidirectional-new-file -ru f09_tmp/bl_flash.c f09_bootloader_202/bl_flash.c
--- f09_tmp/bl_flash.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_flash.c	2017-08-23 13:37:40.578000000 +0800
@@ -0,0 +1,221 @@
+//*****************************************************************************
+//
+// bl_flash.c - Flash programming functions used by the boot loader.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include "inc/hw_types.h"
+#include "inc/hw_flash.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_memmap.h"
+#include "boot_loader/bl_flash.h"
+
+//*****************************************************************************
+//
+//! Erases a single 1KB block of internal flash.
+//!
+//! \param ui32Address is the address of the block of flash to erase.
+//!
+//! This function erases a single 1KB block of the internal flash, blocking
+//! until the erase has completed.
+//!
+//! \return None
+//
+//*****************************************************************************
+void
+BLInternalFlashErase(uint32_t ui32Address)
+{
+    //
+    // Erase this block of the flash.
+    //
+    HWREG(FLASH_FMA) = ui32Address;
+    HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
+
+    //
+    // Wait until the flash has been erased.
+    //
+    while(HWREG(FLASH_FMC) & FLASH_FMC_ERASE)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+//! Programs a block of data at a given address in the internal flash.
+//!
+//! \param ui32DstAddr is the address of the first word to be programmed in
+//! flash.
+//! \param pui8SrcData is a pointer to the first byte to be programmed.
+//! \param ui32Length is the number of bytes to program.  This must be a
+//! multiple of 4.
+//!
+//! This function writes a block of data to the internal flash at a given
+//! address.  Since the flash is written a word at a time, the data must be a
+//! multiple of 4 bytes and the destination address, ui32DstAddr, must be on a
+//! word boundary.
+//!
+//! \return None
+//
+//*****************************************************************************
+void
+BLInternalFlashProgram(uint32_t ui32DstAddr, uint8_t *pui8SrcData,
+                       uint32_t ui32Length)
+{
+    uint32_t ui32Loop;
+
+    for(ui32Loop = 0; ui32Loop < ui32Length; ui32Loop += 4)
+    {
+        //
+        // Program this word into flash.
+        //
+        HWREG(FLASH_FMA) = ui32DstAddr + ui32Loop;
+        HWREG(FLASH_FMD) = *(uint32_t *)(pui8SrcData + ui32Loop);
+        HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;
+
+        //
+        // Wait until the flash has been programmed.
+        //
+        while(HWREG(FLASH_FMC) & FLASH_FMC_WRITE)
+        {
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Returns the size of the internal flash in bytes.
+//!
+//! This function returns the total number of bytes of internal flash in the
+//! current part.  No adjustment is made for any sections reserved via
+//! options defined in bl_config.h.
+//!
+//! \return Returns the total number of bytes of internal flash.
+//
+//*****************************************************************************
+uint32_t
+BLInternalFlashSizeGet(void)
+{
+    return(((HWREG(SYSCTL_DC0) & SYSCTL_DC0_FLASHSZ_M) + 1) << 11);
+}
+
+//*****************************************************************************
+//
+//! Checks whether a given start address is valid for a download.
+//!
+//! This function checks to determine whether the given address is a valid
+//! download image start address given the options defined in bl_config.h.
+//!
+//! \return Returns non-zero if the address is valid or 0 otherwise.
+//
+//*****************************************************************************
+uint32_t
+BLInternalFlashStartAddrCheck(uint32_t ui32Addr, uint32_t ui32ImgSize)
+{
+    uint32_t ui32FlashSize;
+
+    //
+    // Determine the size of the flash available on the part in use.
+    //
+    //ui32FlashSize = ((HWREG(SYSCTL_DC0) & SYSCTL_DC0_FLASHSZ_M) + 1) << 11;
+    //Mini
+    ui32FlashSize = 0x100000;
+
+    //
+    // If we are reserving space at the top of flash then this space is not
+    // available for application download but it is availble to be updated
+    // directly.
+    //
+#ifdef FLASH_RSVD_SPACE
+    if((ui32FlashSize - FLASH_RSVD_SPACE) != ui32Addr)
+    {
+        ui32FlashSize -= FLASH_RSVD_SPACE;
+    }
+#endif
+
+    //
+    // Is the address we were passed a valid start address?  We allow:
+    //
+    // 1. Address 0 if configured to update the boot loader.
+    // 2. The start of the reserved block if parameter space is reserved (to
+    //    allow a download of the parameter block contents).
+    // 3. The application start address specified in bl_config.h.
+    //
+    // The function fails if the address is not one of these, if the image
+    // size is larger than the available space or if the address is not word
+    // aligned.
+    //
+    if((
+#ifdef ENABLE_BL_UPDATE
+        (ui32Addr != 0) &&
+#endif
+#ifdef FLASH_RSVD_SPACE
+        (ui32Addr != (ui32FlashSize - FLASH_RSVD_SPACE)) &&
+#endif
+
+
+        (ui32Addr != APP_START_ADDRESS)) ||
+       ((ui32Addr + ui32ImgSize) > ui32FlashSize) || ((ui32Addr & 3) != 0))
+    {
+        return(0);
+    }
+    else
+    {
+        return(1);
+    }
+}
+
+//*****************************************************************************
+//
+//! Checks whether a flash access violation occurred.
+//!
+//! This function checks whether an access violation error occurred during
+//! the previous program or erase operation.
+//!
+//! \return Returns 0 if no error occurred or a non-zero value if an error was
+//! reported.
+//
+//*****************************************************************************
+void
+BLInternalFlashErrorClear(void)
+{
+    //
+    // Clear the flash controller access interrupt.
+    //
+    HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC;
+}
+
+//*****************************************************************************
+//
+//! Checks whether a flash access violation occurred.
+//!
+//! This function checks whether an access violation error occurred since the
+//! last call to BLInternalFlashErrorClear().
+//!
+//! \return Returns 0 if no error occurred or a non-zero value if an error was
+//! reported.
+//
+//*****************************************************************************
+uint32_t
+BLInternalFlashErrorCheck(void)
+{
+    return(HWREG(FLASH_FCRIS) & FLASH_FCRIS_ARIS);
+}
diff --unidirectional-new-file -ru f09_tmp/bl_i2c.c f09_bootloader_202/bl_i2c.c
--- f09_tmp/bl_i2c.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_i2c.c	2017-08-23 13:37:40.984000000 +0800
@@ -0,0 +1,868 @@
+//*****************************************************************************
+//
+// bl_i2c.c - This file contains the function used to transfer data via the I2C
+//            port.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <time.h>
+
+
+
+#include "inc/hw_gpio.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_types.h"
+
+#include "driverlib/gpio.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/eeprom.h"
+
+#include "boot_loader/bl_flash.h"
+#include "bmc_blcfg.h"
+#include "bl_packet.h"
+#include "inc/hw_i2c.h"
+#include "bl_i2c.h"
+#include "bl_commands.h"
+
+
+
+
+
+#define TIMEOUT (9803921*15/2)  /*   5 seconds  */
+
+//*****************************************************************************
+//
+//! \addtogroup bl_i2c_api
+//! @{
+//
+//*****************************************************************************
+#if defined(I2C_ENABLE_UPDATE) || defined(DOXYGEN)
+
+extern void CallApplication(uint32_t);
+extern uint32_t CheckImage(uint32_t ui32Address);
+extern uint32_t SwapWord(uint32_t x);
+extern void Timeout_reset();
+//*****************************************************************************
+//
+// Holds the current status of the last command that was issued to the boot
+// loader.
+//
+//*****************************************************************************
+uint8_t g_ui8Statusi2c;
+
+//*****************************************************************************
+//
+// This holds the current remaining size in bytes to be downloaded.
+//
+//*****************************************************************************
+uint32_t g_ui32TransferSizei2c;
+
+//*****************************************************************************
+//
+// This holds the current address that is being written to during a download
+// command.
+//
+//*****************************************************************************
+uint32_t g_ui32TransferAddressi2c;
+
+//*****************************************************************************
+//
+// This is the data buffer used during transfers to the boot loader.
+//
+//*****************************************************************************
+uint32_t g_pui32DataBufferi2c[BUFFER_SIZEi2c];
+
+//*****************************************************************************
+//
+// This is an specially aligned buffer pointer to g_pui32DataBuffer to make
+// copying to the buffer simpler.  It must be offset to end on an address that
+// ends with 3.
+//
+//*****************************************************************************
+uint8_t *g_pui8DataBufferi2c;
+
+//*****************************************************************************
+//
+// Clock configuration.
+//
+//*****************************************************************************
+#define I2CBOOT_SYSCTL_CLOCK    (SYSCTL_OSC_INT | SYSCTL_USE_PLL |            \
+                                 SYSCTL_CFG_VCO_480)
+#define I2CBOOT_CLOCK_HZ        120000000
+
+//*****************************************************************************
+//
+//! Configures the microcontroller.
+//!
+//! This function configures the peripherals and GPIOs of the microcontroller,
+//! preparing it for use by the boot loader.  The interface that has been
+//! selected as the update port will be configured, and auto-baud will be
+//! performed if required.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ConfigureI2CDevice(void)
+{
+#ifdef I2C_ENABLE_UPDATE
+
+
+	/*  set cpu frequency 120 MHZ  */
+	MAP_SysCtlMOSCConfigSet(SYSCTL_MOSC_HIGHFREQ);
+	MAP_SysCtlClockFreqSet(I2CBOOT_SYSCTL_CLOCK,I2CBOOT_CLOCK_HZ);
+
+
+	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
+	ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_I2C8);
+	ROM_GPIOPinConfigure(GPIO_PD2_I2C8SCL);
+	ROM_GPIOPinConfigure(GPIO_PD3_I2C8SDA);
+
+	//
+    // Enable the clocks to the I2C and GPIO modules.
+    //
+    HWREG(SYSCTL_RCGC2) |= SYSCTL_RCGC2_GPIOD;
+    //HWREG(SYSCTL_RCGC1) |= SYSCTL_RCGC1_I2C2;
+
+    //
+    // Configure the GPIO pins for hardware control, open drain with pull-up,
+    // and enable them.
+    //
+    HWREG(GPIO_PORTD_BASE + GPIO_O_AFSEL) |= (1 << 7) | I2C_PINS;
+    HWREG(GPIO_PORTD_BASE + GPIO_O_DEN) |= (1 << 7) | I2C_PINS;
+    HWREG(GPIO_PORTD_BASE + GPIO_O_ODR) |= I2C_PINS;
+
+// Mini -------------------------------------------------------
+    ROM_GPIOPinTypePWM(GPIO_PORTD_BASE, GPIO_PIN_2);
+    ROM_GPIOPinTypeI2C(GPIO_PORTD_BASE, GPIO_PIN_3);
+
+    GPIOPadConfigSet(GPIO_PORTD_BASE ,GPIO_PIN_2, GPIO_STRENGTH_12MA, GPIO_PIN_TYPE_STD);
+    GPIOPadConfigSet(GPIO_PORTD_BASE ,GPIO_PIN_3, GPIO_STRENGTH_12MA, GPIO_PIN_TYPE_OD);
+//---------------------------------------------------------
+    //
+    // Enable the I2C Slave Mode.
+    //
+    HWREG(I2C8_BASE + I2C_O_MCR) = /*I2C_MCR_MFE | */I2C_MCR_SFE;
+    //
+    // Setup the I2C Slave Address.
+    //
+    HWREG(I2C8_BASE + I2C_O_SOAR) = I2C_SLAVE_ADDR;
+    //
+    // Enable the I2C Slave Device on the I2C bus.
+    //
+    HWREG(I2C8_BASE + I2C_O_SCSR) = I2C_SCSR_DA;
+#endif
+
+}
+
+//*****************************************************************************
+//
+//! This function performs the update on the selected port.
+//!
+//! This function is called directly by the boot loader or it is called as a
+//! result of an update request from the application.
+//!
+//! \return Never returns.
+//
+//*****************************************************************************
+void
+I2C_Updater(void)
+{
+    uint32_t ui32Size, ui32Temp, ui32FlashSize;
+
+    //
+    // This ensures proper alignment of the global buffer so that the one byte
+    // size parameter used by the packetized format is easily skipped for data
+    // transfers.
+    //
+    g_pui8DataBufferi2c = ((uint8_t *)g_pui32DataBufferi2c) + 3;
+
+    //
+    // Insure that the COMMAND_SEND_DATA cannot be sent to erase the boot
+    // loader before the application is erased.
+    //
+    g_ui32TransferAddressi2c = 0xffffffff;
+
+    //
+    // Read any data from the serial port in use.
+    //
+    while(1)
+    {
+        //
+        // Receive a packet from the port in use.
+        //
+        ui32Size = sizeof(g_pui32DataBufferi2c) - 3;
+        if(ReceivePacket(g_pui8DataBufferi2c, &ui32Size, I2C_UPDATE) != 0)
+        {
+            continue;
+        }
+        //
+        // The first byte of the data buffer has the command and determines
+        // the format of the rest of the bytes.
+        //
+        switch(g_pui8DataBufferi2c[0])
+        {
+            //
+            // This was a simple ping command.
+            //
+            case COMMAND_PING:
+            {
+                //
+                // This command always sets the status to COMMAND_RET_SUCCESS.
+                //
+                g_ui8Statusi2c = COMMAND_RET_SUCCESS;
+
+                //
+                // Just acknowledge that the command was received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command indicates the start of a download sequence.
+            //
+            case COMMAND_DOWNLOAD:
+            {
+                //
+                // Until determined otherwise, the command status is success.
+                //
+                g_ui8Statusi2c = COMMAND_RET_SUCCESS;
+
+                //
+                // A simple do/while(0) control loop to make error exits
+                // easier.
+                //
+                do
+                {
+                    //
+                    // See if a full packet was received.
+                    //
+                    if(ui32Size != 9)
+                    {
+                        //
+                        // Indicate that an invalid command was received.
+                        //
+                        g_ui8Statusi2c = COMMAND_RET_INVALID_CMD;
+                    	DPRINTF(("COMMAND_RET_INVALID_CMD\n"));
+
+                        //
+                        // This packet has been handled.
+                        //
+                        break;
+                    }
+
+                    //
+                    // Get the address and size from the command.
+                    //
+                    g_ui32TransferAddressi2c = SwapWord(g_pui32DataBufferi2c[1]);
+                    g_ui32TransferSizei2c = SwapWord(g_pui32DataBufferi2c[2]);
+#ifdef BL_PROGRESS_FN_HOOK
+                    g_ui32ImageSize = g_ui32TransferSizei2c;
+#endif
+
+                    //
+                    // Check for a valid starting address and image size.
+                    //
+                    if(!BL_FLASH_AD_CHECK_FN_HOOK(g_ui32TransferAddressi2c,
+                                                  g_ui32TransferSizei2c))
+                    {
+                        //
+                        // Set the code to an error to indicate that the last
+                        // command failed.  This informs the updater program
+                        // that the download command failed.
+                        //
+                        g_ui8Statusi2c = COMMAND_RET_INVALID_ADR;
+                    	DPRINTF(("COMMAND_RET_INVALID_ADR\n"));
+
+                        //
+                        // This packet has been handled.
+                        //
+                        break;
+                    }
+
+
+                    //
+                    // Only erase the space that we need if we are not
+                    // protecting the code, otherwise erase the entire flash.
+                    //
+#ifdef FLASH_CODE_PROTECTION
+                    ui32FlashSize = BL_FLASH_SIZE_FN_HOOK();
+#ifdef FLASH_RSVD_SPACE
+                    if((ui32FlashSize - FLASH_RSVD_SPACE) !=
+                       g_ui32TransferAddressi2c)
+                    {
+                        ui32FlashSize -= FLASH_RSVD_SPACE;
+                    }
+#endif
+#else
+                    ui32FlashSize = g_ui32TransferAddressi2c + g_ui32TransferSizei2c;
+#endif
+
+                    //
+                    // Clear the flash access interrupt.
+                    //
+                    BL_FLASH_CL_ERR_FN_HOOK();
+
+                    //
+                    // Leave the boot loader present until we start getting an
+                    // image.
+                    //
+                    for(ui32Temp = g_ui32TransferAddressi2c;
+                        ui32Temp < ui32FlashSize; ui32Temp += FLASH_PAGE_SIZE)
+                    {
+                        //
+                        // Erase this block.
+                        //
+                        BL_FLASH_ERASE_FN_HOOK(ui32Temp);
+                    }
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        g_ui8Statusi2c = COMMAND_RET_FLASH_FAIL;
+                    }
+                }
+                while(0);
+
+                //
+                // See if the command was successful.
+                //
+                if(g_ui8Statusi2c != COMMAND_RET_SUCCESS)
+                {
+                    //
+                    // Setting g_ui32TransferSizei2c to zero makes
+                    // COMMAND_SEND_DATA fail to accept any data.
+                    //
+                    g_ui32TransferSizei2c = 0;
+                }
+
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // If we have a start notification hook function, call it
+                // now if everything is OK.
+                //
+#ifdef BL_START_FN_HOOK
+                if(g_ui32TransferSizei2c)
+                {
+                    BL_START_FN_HOOK();
+                }
+#endif
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command indicates that control should be transferred to
+            // the specified address.
+            //
+            case COMMAND_RUN:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // See if a full packet was received.
+                //
+                if(ui32Size != 5)
+                {
+                    //
+                    // Indicate that an invalid command was received.
+                    //
+                    g_ui8Statusi2c = COMMAND_RET_INVALID_CMD;
+                	DPRINTF(("run - COMMAND_RET_INVALID_CMD\n"));
+
+                    //
+                    // This packet has been handled.
+                    //
+                    break;
+                }
+
+                //
+                // Get the address to which control should be transferred.
+                //
+                g_ui32TransferAddressi2c = SwapWord(g_pui32DataBufferi2c[1]);
+
+                //
+                // This determines the size of the flash available on the
+                // device in use.
+                //
+                //Mini
+                //ui32FlashSize = BL_FLASH_SIZE_FN_HOOK();
+                ui32FlashSize = 0x100000;
+                //
+                // Test if the transfer address is valid for this device.
+                //
+                if(g_ui32TransferAddressi2c >= ui32FlashSize)
+                {
+                    //
+                    // Indicate that an invalid address was specified.
+                    //
+                    g_ui8Statusi2c = COMMAND_RET_INVALID_ADR;
+                	DPRINTF(("run - COMMAND_RET_INVALID_ADR\n"));
+
+                    //
+                    // This packet has been handled.
+                    //
+                    break;
+                }
+
+                //
+                // Make sure that the ACK packet has been sent.
+                //
+                I2CFlush();
+
+                //
+                // Reset and disable the peripherals used by the boot loader.
+                //
+                HWREG(SYSCTL_RCGC1) &= ~SYSCTL_RCGC1_UART4;
+                HWREG(SYSCTL_SRCR1) = SYSCTL_RCGC1_UART4;
+                HWREG(SYSCTL_SRCR1) = 0;
+
+//Mini : Start image from 0x8000 ---------------------------------------------------------
+            	if (CheckImage(APP_START_ADDRESS) == 0)
+            	{
+                	//uint32_t ui32delData;
+                	//EEPROMRead(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+                	//ui32delData = (ui32delData & 0x0000FFFF) | 0x01<<24;
+                	//EEPROMProgram(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+
+            	    //
+            	    // Pass control to the application.
+            	    //
+            	    DPRINTF(("There is a valid image in the flash.\n"));
+
+            	    CallApplication(APP_START_ADDRESS);
+            	}
+//----------------------------------------------------------------------------------------
+
+                //
+                // Branch to the specified address.  This should never return.
+                // If it does, very bad things will likely happen since it is
+                // likely that the copy of the boot loader in SRAM will have
+                // been overwritten.
+                //
+
+                ((void (*)(void))g_ui32TransferAddressi2c)();
+
+                //
+                // In case this ever does return and the boot loader is still
+                // intact, simply reset the device.
+                //
+                DPRINTF(("reset nvic_apint.\n"));
+                //HWREG(NVIC_APINT) = (NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ);
+
+                //only do the core reset , doesn't reset the peripherals
+                HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+
+                //
+                // The microcontroller should have reset, so this should
+                // never be reached.  Just in case, loop forever.
+                //
+                while(1)
+                {
+                }
+            }
+
+            //
+            // This command just returns the status of the last command that
+            // was sent.
+            //
+            case COMMAND_GET_STATUS:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // Return the status to the updater.
+                //
+                SendPacket(&g_ui8Statusi2c, 1, I2C_UPDATE);
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command is sent to transfer data to the device following
+            // a download command.
+            //
+            case COMMAND_SEND_DATA:
+            {
+                //
+                // Until determined otherwise, the command status is success.
+                //
+                g_ui8Statusi2c = COMMAND_RET_SUCCESS;
+
+                //
+                // If this is overwriting the boot loader then the application
+                // has already been erased so now erase the boot loader.
+                //
+                if(g_ui32TransferAddressi2c == 0)
+                {
+                    //
+                    // Clear the flash access interrupt.
+                    //
+                    BL_FLASH_CL_ERR_FN_HOOK();
+
+                    //
+                    // Erase the boot loader.
+                    //
+                    for(ui32Temp = 0; ui32Temp < APP_START_ADDRESS;
+                        ui32Temp += FLASH_PAGE_SIZE)
+                    {
+                        //
+                        // Erase this block.
+                        //
+                        BL_FLASH_ERASE_FN_HOOK(ui32Temp);
+                    }
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        //
+                        // Setting g_ui32TransferSizei2c to zero makes
+                        // COMMAND_SEND_DATA fail to accept any more data.
+                        //
+                        g_ui32TransferSizei2c = 0;
+
+                        //
+                        // Indicate that the flash erase failed.
+                        //
+                        g_ui8Statusi2c = COMMAND_RET_FLASH_FAIL;
+                    	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_FLASH_FAIL\n"));
+                    }
+                }
+
+                //
+                // Take one byte off for the command.
+                //
+                ui32Size = ui32Size - 1;
+
+                //
+                // Check if there are any more bytes to receive.
+                //
+                if(g_ui32TransferSizei2c >= ui32Size)
+                {
+                    //
+                    // If we have been provided with a decryption hook function
+                    // call it here.
+                    //
+#ifdef BL_DECRYPT_FN_HOOK
+                    BL_DECRYPT_FN_HOOK(g_pui8DataBufferi2c + 1, ui32Size);
+#endif
+
+                    //
+                    // Write this block of data to the flash
+                    //
+                    BL_FLASH_PROGRAM_FN_HOOK(g_ui32TransferAddressi2c,
+                                             (uint8_t *) &g_pui32DataBufferi2c[1],
+                                             ((ui32Size + 3) & ~3));
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        //
+                        // Indicate that the flash programming failed.
+                        //
+                        g_ui8Statusi2c = COMMAND_RET_FLASH_FAIL;
+                    	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_FLASH_FAIL\n"));
+                    }
+                    else
+                    {
+                        //
+                        // Now update the address to program.
+                        //
+                        g_ui32TransferSizei2c -= ui32Size;
+                        g_ui32TransferAddressi2c += ui32Size;
+
+                        //
+                        // If a progress hook function has been provided, call
+                        // it here.
+                        //
+#ifdef BL_PROGRESS_FN_HOOK
+                        BL_PROGRESS_FN_HOOK(g_ui32ImageSize -
+                                            g_ui32TransferSizei2c,
+                                            g_ui32ImageSize);
+#endif
+                    }
+                }
+                else
+                {
+                    //
+                    // This indicates that too much data is being sent to the
+                    // device.
+                    //
+                    g_ui8Statusi2c = COMMAND_RET_INVALID_ADR;
+                	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_INVALID_ADR\n"));
+                }
+
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // If we have an end notification hook function, and we've
+                // reached the end, call it now.
+                //
+#ifdef BL_END_FN_HOOK
+                if(g_ui32TransferSizei2c == 0)
+                {
+                    BL_END_FN_HOOK();
+                }
+#endif
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command is used to reset the device.
+            //
+            case COMMAND_RESET:
+            {
+                //
+                // Send out a one-byte ACK to ensure the byte goes back to the
+                // host before we reset everything.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // Make sure that the ACK packet has been sent.
+                //
+                I2CFlush();
+
+                //
+                // Perform a software reset request.  This will cause the
+                // microcontroller to reset; no further code will be executed.
+                //
+                //HWREG(NVIC_APINT) = (NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ);
+
+                //only do the core reset , doesn't reset the peripherals
+                HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+
+                //
+                // The microcontroller should have reset, so this should never
+                // be reached.  Just in case, loop forever.
+                //
+                while(1)
+                {
+                }
+            }
+
+            //
+            // Just acknowledge the command and set the error to indicate that
+            // a bad command was sent.
+            //
+            default:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(I2C_UPDATE);
+
+                //
+                // Indicate that a bad comand was sent.
+                //
+                g_ui8Statusi2c = COMMAND_RET_UNKNOWN_CMD;
+            	DPRINTF(("default - COMMAND_RET_UNKNOWN_CMD\n"));
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Sends data over the I2C port.
+//!
+//! \param pui8Data is the buffer containing the data to write out to the I2C
+//! port.
+//! \param ui32Size is the number of bytes provided in \e pui8Data buffer that
+//! will be written out to the I2C port.
+//!
+//! This function sends \e ui32Size bytes of data from the buffer pointed to by
+//! \e pui8Data via the I2C port.  The function will wait till the I2C Slave
+//! port has been properly addressed by the I2C Master device before sending
+//! the first byte.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+I2CSend(const uint8_t *pui8Data, uint32_t ui32Size)
+{
+	uint32_t Timeout=TIMEOUT; //5 seconeds
+	//
+    // Transmit the number of bytes requested on the UART port.
+    //
+    while(ui32Size--)
+    {
+        //
+        // Wait for request to come in at slave.
+        //
+        while(!(HWREG(I2C8_BASE + I2C_O_SCSR) & I2C_SCSR_TREQ))
+        {
+        	if(!Timeout--)
+        	{
+        		DPRINTF(("I2CSend timeout\n"));
+        		Timeout_reset();
+        	}
+        }
+
+        //
+        // Send out the next byte.
+        //
+        HWREG(I2C8_BASE + I2C_O_SDR) = *pui8Data++;
+    }
+}
+
+//*****************************************************************************
+//
+//! Waits until all data has been transmitted by the I2C port.
+//!
+//! This function waits until all data written to the I2C port has been read by
+//! the master.
+//!
+//! \return None.
+//
+//*****************************************************************************
+int
+I2CFlush()
+{
+	uint32_t Timeout=TIMEOUT; //5 seconeds
+    //
+    // Wait until the I2C bus is no longer busy, meaning that the last byte has
+    // been sent.
+    //
+    while(HWREG(I2C8_BASE + I2C_O_MCS) & I2C_MCS_BUSBSY)
+    {
+    	if(!Timeout--)
+    	{
+    		return(-1);
+    	}
+    }
+	return(0);
+}
+
+//*****************************************************************************
+//
+//! Receives data over the I2C port.
+//!
+//! \param pui8Data is the buffer to read data into from the I2C port.
+//! \param ui32Size is the number of bytes provided in the \e pui8Data buffer
+//! that should be written with data from the I2C port.
+//!
+//! This function reads back \e ui32Size bytes of data from the I2C port, into
+//! the buffer that is pointed to by \e pui8Data.  This function will not
+//! return until \e ui32Size number of bytes have been received.  This function
+//! will wait till the I2C Slave port has been properly addressed by the I2C
+//! Master before reading the first byte of data from the I2C port.
+//!
+//! \return None.
+//
+//*****************************************************************************
+int
+I2CReceive(uint8_t *pui8Data, uint32_t ui32Size)
+{
+	//uint32_t Timeout=30000000*2; //30 seconeds
+	uint32_t Timeout=TIMEOUT;//10000000; //5 seconeds
+	//
+    // Send out the number of bytes requested.
+    //
+	//DPRINTF(("I2CReceive - ui32Size:%d\n",ui32Size));
+    while(ui32Size--)
+    {
+    	Timeout=TIMEOUT; //5 seconeds
+        //
+        // Wait until the slave has received the character.
+        //
+        while(!(HWREG(I2C8_BASE + I2C_O_SCSR) & I2C_SCSR_RREQ))
+        {
+        	if(!Timeout--)
+        	{
+        		return(-1);
+        	}
+        }
+
+        //
+        // Receive a byte from the I2C.
+        //
+        *pui8Data++ = HWREG(I2C8_BASE + I2C_O_SDR);
+        //*pui8Data--;
+    	//DPRINTF(("I2CReceive data - 0x%x\n",*pui8Data));
+        //*pui8Data++;
+    }
+	return(0);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+#endif
diff --unidirectional-new-file -ru f09_tmp/bl_i2c.h f09_bootloader_202/bl_i2c.h
--- f09_tmp/bl_i2c.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_i2c.h	2017-08-23 13:37:39.841000000 +0800
@@ -0,0 +1,108 @@
+//*****************************************************************************
+//
+// bl_i2c.h - Definitions for the I2C transport functions.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __BL_I2C_H__
+#define __BL_I2C_H__
+
+//*****************************************************************************
+//
+// This defines the I2C clock pin that is being used by the boot loader.
+//
+//*****************************************************************************
+#define I2C_CLK                 (1 << 2)
+
+//*****************************************************************************
+//
+// This defines the I2C data pin that is being used by the boot loader.
+//
+//*****************************************************************************
+#define I2C_DATA                (1 << 3)
+
+//*****************************************************************************
+//
+// This defines the combination of pins used to implement the I2C port used by
+// the boot loader.
+//
+//*****************************************************************************
+#define I2C_PINS                (I2C_CLK | I2C_DATA)
+
+//*****************************************************************************
+//
+// The number of words in the data buffer used for receiving packets.  This
+// value must be at least 3.  If using autobauding on the UART, this must be at
+// least 20.  The maximum usable value is 65 (larger values will result in
+// unused space in the buffer).
+//
+// Depends on: None
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+#define BUFFER_SIZEi2c             65//20
+
+//*****************************************************************************
+//
+// The size of a single, erasable page in the flash.  This must be a power
+// of 2.  The default value of 1KB represents the page size for the internal
+// flash on all Tiva MCUs and this value should only be overridden if
+// configuring a boot loader to access external flash devices with a page size
+// different from this.
+//
+// Depends on: None
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+//#define FLASH_PAGE_SIZE         0x00000400
+
+//*****************************************************************************
+//
+// Specifies the I2C address of the boot loader.
+//
+// Depends on: I2C_ENABLE_UPDATE
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+#define I2C_SLAVE_ADDR          0x20
+
+//*****************************************************************************
+//
+// I2C Transport APIs
+//
+//*****************************************************************************
+extern void I2CSend(const uint8_t *pui8Data, uint32_t ui32Size);
+extern int I2CReceive(uint8_t *pui8Data, uint32_t ui32Size);
+extern int I2CFlush();
+
+//*****************************************************************************
+//
+// Define the transport functions if the I2C port is being used.
+//
+//*****************************************************************************
+//#define SendData                I2CSend
+//#define FlushData               I2CFlush
+//#define ReceiveData             I2CReceive
+
+#endif // __BL_I2C_H__
diff --unidirectional-new-file -ru f09_tmp/bl_oem.c f09_bootloader_202/bl_oem.c
--- f09_tmp/bl_oem.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_oem.c	2017-08-23 13:37:41.022000000 +0800
@@ -0,0 +1,322 @@
+//*****************************************************************************
+//
+// bl_oem.c - Functions to oem feature.
+//
+// Copyright (c) 2007-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+#include <time.h>
+
+#include "inc/hw_ints.h"
+#include "inc/hw_flash.h"
+#include "inc/hw_gpio.h"
+#include "inc/hw_lpcb.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_timer.h"
+#include "inc/hw_types.h"
+#include "driverlib/rom.h"
+#include "driverlib/flash.h"
+#include "driverlib/gpio.h"
+#include "driverlib/lpcb.h"
+#include "driverlib/lpc.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/sw_crc.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/timer.h"
+#include "driverlib/rom_map.h"
+#include "bmc_blcfg.h"
+
+
+
+
+#ifdef OEM_HOOK
+
+
+//*****************************************************************************
+//
+// The system clock speed.
+//
+//*****************************************************************************
+extern uint32_t g_ui32SysClk;
+
+//*****************************************************************************
+//
+// Power sequence Pin definition
+//
+// Note: All GPIO peripherals are enabled during init, so it is not
+// necessary to specifically define the peripheral here.
+//
+//*****************************************************************************
+#define RST_BTN_BMC_IN_N_PERIPH     	SYSCTL_PERIPH_GPION
+#define RST_BTN_BMC_IN_N_PORT     		GPIO_PORTN_BASE
+#define RST_BTN_BMC_IN_N_PIN      		GPIO_PIN_7
+
+#define RST_BTN_BMC_OUT_N_PERIPH     	SYSCTL_PERIPH_GPIOK
+#define RST_BTN_BMC_OUT_N_PORT     		GPIO_PORTK_BASE
+#define RST_BTN_BMC_OUT_N_PIN      		GPIO_PIN_3
+
+#define PWRGD_COREPWR_PERIPH     		SYSCTL_PERIPH_GPIOG
+#define PWRGD_COREPWR_PORT     			GPIO_PORTG_BASE
+#define PWRGD_COREPWR_PIN      			GPIO_PIN_1
+
+#define PORT80_P0_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P0_PORT     				GPIO_PORTH_BASE
+#define PORT80_P0_PIN      				GPIO_PIN_0
+#define PORT80_P1_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P1_PORT     				GPIO_PORTH_BASE
+#define PORT80_P1_PIN      				GPIO_PIN_1
+#define PORT80_P2_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P2_PORT     				GPIO_PORTH_BASE
+#define PORT80_P2_PIN      				GPIO_PIN_2
+#define PORT80_P3_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P3_PORT     				GPIO_PORTH_BASE
+#define PORT80_P3_PIN      				GPIO_PIN_3
+#define PORT80_P4_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P4_PORT     				GPIO_PORTH_BASE
+#define PORT80_P4_PIN      				GPIO_PIN_4
+#define PORT80_P5_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P5_PORT     				GPIO_PORTH_BASE
+#define PORT80_P5_PIN      				GPIO_PIN_5
+#define PORT80_P6_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P6_PORT     				GPIO_PORTH_BASE
+#define PORT80_P6_PIN      				GPIO_PIN_6
+#define PORT80_P7_PERIPH   			  	SYSCTL_PERIPH_GPIOH
+#define PORT80_P7_PORT     				GPIO_PORTH_BASE
+#define PORT80_P7_PIN      				GPIO_PIN_7
+
+//*****************************************************************************
+//
+// LPC Channel Definitions
+//
+//*****************************************************************************
+#define PORT80_CHANNEL           3
+#define PORT80_CONFIG            (LPCB_CHAN_SIZE_4)
+#define PORT80_OFFSET            0x0010
+#define PORT80_ADDRESS           0x0080
+#define PORT80_INT		         (LPC_INT_CH0_EP_FROM_DATA << (4*PORT80_CHANNEL))
+
+//*****************************************************************************
+//
+// Enter Boot Init hook
+//
+//*****************************************************************************
+void OEM_HOOK_BootInit(void)
+{
+
+	DPRINTF(("\n Enter OEM_HOOK_BootInit  \n"));
+
+	//
+	// Initial the GPIO peripheral for power sequence signals.
+	//
+	ROM_SysCtlPeripheralEnable(RST_BTN_BMC_IN_N_PERIPH);
+	ROM_SysCtlPeripheralEnable(RST_BTN_BMC_OUT_N_PERIPH);
+	ROM_SysCtlPeripheralEnable(PWRGD_COREPWR_PERIPH);
+
+	//
+	// Configure the OEM power sequence pins
+	//
+	MAP_GPIODirModeSet(RST_BTN_BMC_IN_N_PORT, RST_BTN_BMC_IN_N_PIN, GPIO_DIR_MODE_IN);
+	MAP_GPIODirModeSet(RST_BTN_BMC_OUT_N_PORT, RST_BTN_BMC_OUT_N_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PWRGD_COREPWR_PORT, PWRGD_COREPWR_PIN, GPIO_DIR_MODE_IN);
+
+	MAP_GPIOPadConfigSet(RST_BTN_BMC_IN_N_PORT, RST_BTN_BMC_IN_N_PIN, GPIO_STRENGTH_2MA,
+							GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(RST_BTN_BMC_OUT_N_PORT, RST_BTN_BMC_OUT_N_PIN, GPIO_STRENGTH_2MA,
+							GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PWRGD_COREPWR_PORT, PWRGD_COREPWR_PIN, GPIO_STRENGTH_2MA,
+							GPIO_PIN_TYPE_STD_WPU);
+
+	//
+	// Set default output value
+	//
+	ROM_GPIOPinWrite(RST_BTN_BMC_OUT_N_PORT, RST_BTN_BMC_OUT_N_PIN,
+						RST_BTN_BMC_OUT_N_PIN);
+
+	//
+	// Check power good or not. if not, do power sequence.
+	//
+	if(MAP_GPIOPinRead(PWRGD_COREPWR_PORT, PWRGD_COREPWR_PIN) == 0x00)
+	{
+		DPRINTF((" Do power sequence start \n"));
+
+		//
+		// Bypass power button signal for power on
+		//
+		do
+		{
+
+		    //
+		    // Delay for at least 1000 uSecs.
+		    //
+		    MAP_SysCtlDelay(((g_ui32SysClk / 1000000) * 1000) / 3);
+
+			if(MAP_GPIOPinRead(RST_BTN_BMC_IN_N_PORT, RST_BTN_BMC_IN_N_PIN) == 0x00)
+			{
+				ROM_GPIOPinWrite(RST_BTN_BMC_OUT_N_PORT, RST_BTN_BMC_OUT_N_PIN, 0);
+
+				break;
+			}
+		}
+		while(1);
+
+		do
+		{
+		    //
+		    // Delay for at least 1000 uSecs.
+		    //
+		    MAP_SysCtlDelay(((g_ui32SysClk / 1000000) * 1000) / 3);
+
+			if(MAP_GPIOPinRead(RST_BTN_BMC_IN_N_PORT, RST_BTN_BMC_IN_N_PIN) == RST_BTN_BMC_IN_N_PIN)
+			{
+				ROM_GPIOPinWrite(RST_BTN_BMC_OUT_N_PORT, RST_BTN_BMC_OUT_N_PIN,
+						RST_BTN_BMC_OUT_N_PIN);
+				break;
+			}
+		}
+		while(1);
+
+		DPRINTF((" Do power sequence end  \n"));
+	}
+
+
+	//
+	// Initial port 80 function
+	//
+
+	//
+	// Initial the GPIO peripheral for OEM PORT80 signals.
+	//
+	ROM_SysCtlPeripheralEnable(PORT80_P0_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P1_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P2_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P3_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P4_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P5_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P6_PERIPH);
+	ROM_SysCtlPeripheralEnable(PORT80_P7_PERIPH);
+
+	MAP_GPIODirModeSet(PORT80_P0_PORT, PORT80_P0_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P1_PORT, PORT80_P1_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P2_PORT, PORT80_P2_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P3_PORT, PORT80_P3_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P4_PORT, PORT80_P4_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P5_PORT, PORT80_P5_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P6_PORT, PORT80_P6_PIN, GPIO_DIR_MODE_OUT);
+	MAP_GPIODirModeSet(PORT80_P7_PORT, PORT80_P7_PIN, GPIO_DIR_MODE_OUT);
+
+	MAP_GPIOPadConfigSet(PORT80_P0_PORT, PORT80_P0_PIN, GPIO_STRENGTH_2MA,
+	     				 	 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P1_PORT, PORT80_P1_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P2_PORT, PORT80_P2_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P3_PORT, PORT80_P3_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P4_PORT, PORT80_P4_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P5_PORT, PORT80_P5_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P6_PORT, PORT80_P6_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+	MAP_GPIOPadConfigSet(PORT80_P7_PORT, PORT80_P7_PIN, GPIO_STRENGTH_2MA,
+		     				 GPIO_PIN_TYPE_STD_WPU);
+
+	//
+	// Configure Port80 channel
+	//
+    MAP_LPCChannelConfigEPSet(LPC0_BASE,
+    						  PORT80_CHANNEL,
+    						  PORT80_CONFIG,
+    						  PORT80_ADDRESS,
+    						  PORT80_OFFSET);
+
+    //
+    // Enable Port80 channel
+    //
+    MAP_LPCBChannelEnable(LPC0_BASE, PORT80_CHANNEL);
+
+    //
+    // Enable the LPC channel interrupt.
+    //
+    MAP_LPCIntEnable(LPC0_BASE, PORT80_INT);
+
+    //
+    // Enable the LPC interrupt.
+    //
+    MAP_IntEnable(INT_LPC0);
+}
+
+//*****************************************************************************
+//
+// LPC interrupt handler for PORT80
+//
+//*****************************************************************************
+void LPCIntHandler(void)
+{
+	uint8_t ui8Data;
+	uint64_t ui64Status;
+
+	//
+	// Get the LPC masked interrupt status and clear the interrupts.
+	//
+	ui64Status = LPCIntStatus(LPC0_BASE, true);
+	LPCIntClear(LPC0_BASE, ui64Status);
+
+	//
+	// Read PORT80 channel and set port80 output port
+	//
+	ui8Data = MAP_LPCByteRead(LPC0_BASE, PORT80_OFFSET);
+
+	ROM_GPIOPinWrite(PORT80_P0_PORT, PORT80_P0_PIN, (ui8Data & 0x01) ?
+					 (PORT80_P0_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P1_PORT, PORT80_P1_PIN, (ui8Data & 0x02) ?
+					 (PORT80_P1_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P2_PORT, PORT80_P2_PIN, (ui8Data & 0x04) ?
+					 (PORT80_P2_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P3_PORT, PORT80_P3_PIN, (ui8Data & 0x08) ?
+					 (PORT80_P3_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P4_PORT, PORT80_P4_PIN, (ui8Data & 0x10) ?
+					 (PORT80_P4_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P5_PORT, PORT80_P5_PIN, (ui8Data & 0x20) ?
+					 (PORT80_P5_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P6_PORT, PORT80_P6_PIN, (ui8Data & 0x40) ?
+					 (PORT80_P6_PIN) : (0));
+	ROM_GPIOPinWrite(PORT80_P7_PORT, PORT80_P7_PIN, (ui8Data & 0x80) ?
+					 (PORT80_P7_PIN) : (0));
+}
+
+
+
+#endif
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+
diff --unidirectional-new-file -ru f09_tmp/bl_packet.c f09_bootloader_202/bl_packet.c
--- f09_tmp/bl_packet.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_packet.c	2017-08-23 13:37:40.650000000 +0800
@@ -0,0 +1,424 @@
+//*****************************************************************************
+//
+// bl_packet.c - Packet handler functions used by the boot loader.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include "bl_packet.h"
+#include "bl_uart.h"
+#include "bl_i2c.h"
+#include "bl_commands.h"
+#include "bmc_blcfg.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_types.h"
+#include "driverlib/sysctl.h"
+
+
+#define RESET_TIMEOUT (524288*15/2)
+//*****************************************************************************
+//
+//! \addtogroup bl_packet_api
+//! @{
+//
+//*****************************************************************************
+#if defined(I2C_ENABLE_UPDATE) || defined(SSI_ENABLE_UPDATE) || \
+    defined(UART_ENABLE_UPDATE) || defined(DOXYGEN)
+
+
+//*****************************************************************************
+//
+// The packet that is sent to acknowledge a received packet.
+//
+//*****************************************************************************
+static const uint8_t g_pui8ACK[2] = { 0, COMMAND_ACK };
+//static const uint8_t g_pui8ACK1[0] = { 0 };
+static const uint8_t g_pui8ACK2[1] = { COMMAND_ACK };
+//*****************************************************************************
+//
+// The packet that is sent to not-acknowledge a received packet.
+//
+//*****************************************************************************
+static const uint8_t g_pui8NAK[2] = { 0, COMMAND_NAK };
+//static const uint8_t g_pui8NAK1[0] = { 0 };
+static const uint8_t g_pui8NAK2[1] = { COMMAND_NAK };
+//*****************************************************************************
+//
+//! Calculates an 8-bit checksum
+//!
+//! \param pui8Data is a pointer to an array of 8-bit data of size ui32Size.
+//! \param ui32Size is the size of the array that will run through the checksum
+//! algorithm.
+//!
+//! This function simply calculates an 8-bit checksum on the data passed in.
+//!
+//! \return Returns the calculated checksum.
+//
+//*****************************************************************************
+uint32_t
+CheckSum(const uint8_t *pui8Data, uint32_t ui32Size)
+{
+    uint32_t ui32CheckSum;
+
+    //
+    // Initialize the checksum to zero.
+    //
+    ui32CheckSum = 0;
+
+    //
+    // Add up all the bytes, do not do anything for an overflow.
+    //
+    while(ui32Size--)
+    {
+        ui32CheckSum += *pui8Data++;
+    }
+
+    //
+    // Return the caculated check sum.
+    //
+    return(ui32CheckSum & 0xff);
+}
+
+//*****************************************************************************
+//
+//! Sends an Acknowledge packet.
+//!
+//! This function is called to acknowledge that a packet has been received by
+//! the microcontroller.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+AckPacket(uint8_t interface)
+{
+    //
+    // ACK/NAK packets are the only ones with no size.
+    //
+	if(interface == UART_UPDATE){
+		//UARTSend(g_pui8ACK, 2);
+    	SysCtlDelay(10486); //2ms
+		UARTSend(g_pui8ACK2, 1);
+    	SysCtlDelay(26214); //5ms
+	}else if(interface == I2C_UPDATE){
+		I2CSend(g_pui8ACK, 2);
+	}
+    //SendData(g_pui8ACK, 2);
+}
+
+//*****************************************************************************
+//
+//! Sends a no-acknowledge packet.
+//!
+//! This function is called when an invalid packet has been received by the
+//! microcontroller, indicating that it should be retransmitted.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+NakPacket(uint8_t interface)
+{
+    //
+    // ACK/NAK packets are the only ones with no size.
+    //
+	if(interface == UART_UPDATE){
+		//UARTSend(g_pui8NAK, 2);
+		UARTSend(g_pui8NAK2, 1);
+		SysCtlDelay(26214); //5ms
+	}else if(interface == I2C_UPDATE){
+		I2CSend(g_pui8NAK, 2);
+		//SendData(g_pui8NAK, 2);
+	}
+}
+
+void Timeout_reset(){
+
+	//Delay
+	SysCtlDelay(RESET_TIMEOUT);
+
+    //
+    // Perform a software reset request.  This will cause the
+    // microcontroller to reset; no further code will be executed.
+    //
+    //HWREG(NVIC_APINT) = (NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ);
+
+    //only do the core reset , doesn't reset the peripherals
+    HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+
+    //
+    // The microcontroller should have reset, so this should never
+    // be reached.  Just in case, loop forever.
+    //
+    while(1)
+    {
+    }
+}
+//*****************************************************************************
+//
+//! Receives a data packet.
+//!
+//! \param pui8Data is the location to store the data that is sent to the boot
+//! loader.
+//! \param pui32Size is the number of bytes returned in the pui8Data buffer
+//! that was provided.
+//!
+//! This function receives a packet of data from specified transfer function.
+//!
+//! \return Returns zero to indicate success while any non-zero value indicates
+//! a failure.
+//
+//*****************************************************************************
+//interface
+//0:UART
+//1:I2C
+int
+ReceivePacket(uint8_t *pui8Data, uint32_t *pui32Size, uint8_t interface)
+{
+    uint32_t ui32Size, ui32CheckSum;
+
+    //
+    // Wait for non-zero data before getting the first byte that holds the
+    // size of the packet we are receiving.
+    //
+    //DPRINTF(("R 1 - S:%d\n",*pui32Size));
+    //Test
+/*
+    while(1)
+    {
+            ReceiveData((uint8_t *)&ui32Size, 20);
+    }
+*/
+//----------------------------------------------
+    ui32Size = 0;
+    while(ui32Size == 0)
+    {
+    	if(interface == UART_UPDATE){
+    		if(UARTReceive((uint8_t *)&ui32Size, 1) == -1){
+    			DPRINTF(("UART timeout\n"));
+    			Timeout_reset();
+    		}
+    	}else if(interface == I2C_UPDATE){
+    		if(I2CReceive((uint8_t *)&ui32Size, 1) == -1){
+    			DPRINTF(("I2C timeout\n"));
+    			Timeout_reset();
+    		}
+    	}
+    }
+
+    //The packet size is no valid.
+    if(ui32Size < 2 ){
+    	DPRINTF(("Packet data size is no valid, return fail!\n"));
+    	return(-1);
+    }
+
+    //
+    // Subtract off the size and checksum bytes.
+    //
+    ui32Size -= 2;
+    //DPRINTF(("R 2 - S:%d\n",ui32Size));
+    //
+    // Receive the checksum followed by the actual data.
+    //
+	if(interface == UART_UPDATE){
+		if(UARTReceive((uint8_t *)&ui32CheckSum, 1) == -1){
+			DPRINTF(("UART timeout\n"));
+			Timeout_reset();
+		}
+	}else if(interface == I2C_UPDATE){
+		if(I2CReceive((uint8_t *)&ui32CheckSum, 1) == -1){
+			DPRINTF(("I2C timeout\n"));
+			Timeout_reset();
+		}
+	}
+    //DPRINTF(("*ui32CheckSum: 0x%x\n",&ui32CheckSum));
+
+    //
+    // If there is room in the buffer then receive the requested data.
+    //
+    //DPRINTF(("pui32Size:%d >= ui32Size:%d\n",*pui32Size,ui32Size));
+    if(*pui32Size >= ui32Size)
+    {
+        //
+        // Receive the actual data in the packet.
+        //
+    	if(interface == UART_UPDATE){
+    		if(UARTReceive(pui8Data, ui32Size) == -1){
+    			DPRINTF(("UART timeout\n"));
+    			Timeout_reset();
+    		}
+    	}else if(interface == I2C_UPDATE){
+    		if(I2CReceive(pui8Data, ui32Size) == -1){
+    			DPRINTF(("I2C timeout\n"));
+    			Timeout_reset();
+    		}
+    	}
+        //
+        // Send a no acknowledge if the checksum does not match, otherwise send
+        // an acknowledge to the packet later.
+        //
+        if(CheckSum(pui8Data, ui32Size) != (ui32CheckSum & 0xff))
+        {
+            //
+            // Indicate tha the packet was not received correctly.
+            //
+            NakPacket(interface);
+
+            DPRINTF(("Packet was not received, there is no valid data in the buffer.1\n"));
+            //
+            // Packet was not received, there is no valid data in the buffer.
+            //
+            return(-1);
+        }
+    }
+    else
+    {
+        //
+        // If the caller allocated a buffer that was too small for the received
+        // data packet, receive it but don't fill the buffer.
+        // Then inform the caller that the packet was not received correctly.
+        //
+        while(ui32Size--)
+        {
+        	if(interface == UART_UPDATE){
+        		if(UARTReceive(pui8Data, 1) == -1){
+        			DPRINTF(("UART timeout\n"));
+        			Timeout_reset();
+        		}
+        	}else if(interface == I2C_UPDATE){
+        		if(I2CReceive(pui8Data, 1) == -1){
+        			DPRINTF(("I2C timeout\n"));
+        			Timeout_reset();
+        		}
+        	}
+        }
+
+        DPRINTF(("Packet was not received, there is no valid data in the buffer.2\n"));
+        //
+        // Packet was not received, there is no valid data in the buffer.
+        //
+        return(-1);
+    }
+
+    //
+    // Make sure to return the number of bytes received.
+    //
+    *pui32Size = ui32Size;
+
+    //
+    // Packet was received successfully.
+    //
+    //DPRINTF(("R end\n"));
+    return(0);
+}
+
+//*****************************************************************************
+//
+//! Sends a data packet.
+//!
+//! \param pui8Data is the location of the data to be sent.
+//! \param ui32Size is the number of bytes to send.
+//!
+//! This function sends the data provided in the \e pui8Data parameter in the
+//! packet format used by the boot loader.  The caller only needs to specify
+//! the buffer with the data that needs to be transferred.  This function
+//! addresses all other packet formatting issues.
+//!
+//! \return Returns zero to indicate success while any non-zero value indicates
+//! a failure.
+//
+//*****************************************************************************
+int
+SendPacket(uint8_t *pui8Data, uint32_t ui32Size, uint8_t interface)
+{
+    uint32_t ui32Temp;
+
+    //
+    // Caculate the checksum to be sent out with the data.
+    //
+    ui32Temp = CheckSum(pui8Data, ui32Size);
+
+    //
+    // Need to include the size and checksum bytes in the packet.
+    //
+    ui32Size += 2;
+
+    //
+    // Send out the size followed by the data.
+    //
+
+	if(interface == UART_UPDATE){
+		SysCtlDelay(26214); //5ms
+		UARTSend((uint8_t *)&ui32Size, 1);
+    	SysCtlDelay(78643); //15ms
+		UARTSend((uint8_t *)&ui32Temp, 1);
+    	SysCtlDelay(78643); //15ms (10ms - 52429)
+		UARTSend(pui8Data, ui32Size - 2);
+	}else if(interface == I2C_UPDATE){
+		I2CSend((uint8_t *)&ui32Size, 1);
+		I2CSend((uint8_t *)&ui32Temp, 1);
+		I2CSend(pui8Data, ui32Size - 2);
+	}
+    //SendData((uint8_t *)&ui32Size, 1);
+    //SendData((uint8_t *)&ui32Temp, 1);
+    //SendData(pui8Data, ui32Size - 2);
+
+    //
+    // Wait for a non zero byte.
+    //
+    ui32Temp = 0;
+    while(ui32Temp == 0)
+    {
+    	if(interface == UART_UPDATE){
+    		if(UARTReceive((uint8_t *)&ui32Temp, 1) == -1){
+    			DPRINTF(("UART timeout\n"));
+    			Timeout_reset();
+    		}
+    	}else if(interface == I2C_UPDATE){
+    		if(I2CReceive((uint8_t *)&ui32Temp, 1) == -1){
+    			DPRINTF(("I2C timeout\n"));
+    			Timeout_reset();
+    		}
+    	}
+    }
+
+    //
+    // Check if the byte was a valid ACK and return a negative value if it was
+    // not and aknowledge.
+    //
+    if(ui32Temp != COMMAND_ACK)
+    {
+        return(-1);
+    }
+
+    //
+    // This packet was sent and received successfully.
+    //
+    return(0);
+}
+
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+#endif
diff --unidirectional-new-file -ru f09_tmp/bl_packet.h f09_bootloader_202/bl_packet.h
--- f09_tmp/bl_packet.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_packet.h	2017-08-23 13:37:40.974000000 +0800
@@ -0,0 +1,37 @@
+//*****************************************************************************
+//
+// bl_packet.h - The global variables and definitions of the boot loader.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __BL_PACKET_H__
+#define __BL_PACKET_H__
+
+//*****************************************************************************
+//
+// Packet Handling APIs
+//
+//*****************************************************************************
+extern int ReceivePacket(uint8_t *pui8Data, uint32_t *pui32Size, uint8_t interface);
+extern int SendPacket(uint8_t *pui8Data, uint32_t ui32Size, uint8_t interface);
+extern void AckPacket(uint8_t interface);
+
+#endif // __BL_PACKET_H__
diff --unidirectional-new-file -ru f09_tmp/bl_uart.c f09_bootloader_202/bl_uart.c
--- f09_tmp/bl_uart.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_uart.c	2017-08-23 13:37:40.968000000 +0800
@@ -0,0 +1,916 @@
+//*****************************************************************************
+//
+// bl_uart.c - Functions to transfer data via the UART port.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include "bmc_blcfg.h"
+#include "inc/hw_gpio.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_types.h"
+#include "inc/hw_uart.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/gpio.h"
+#include "bl_packet.h"
+#include "bl_uart.h"
+#include "bl_commands.h"
+#include "inc/hw_nvic.h"
+#include "boot_loader/bl_flash.h"
+#include "boot_loader/bl_hooks.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/eeprom.h"
+#include "driverlib/sysctl.h"
+
+#define UART_ENABLE_UPDATE
+
+extern void CallApplication(uint32_t);
+extern uint32_t CheckImage(uint32_t ui32Address);
+
+
+//*****************************************************************************
+//
+//! \addtogroup bl_uart_api
+//! @{
+//
+//*****************************************************************************
+#if 1
+//#if defined(UART_ENABLE_UPDATE) || defined(DOXYGEN)
+
+//*****************************************************************************
+//
+// Holds the current status of the last command that was issued to the boot
+// loader.
+//
+//*****************************************************************************
+uint8_t g_ui8Status;
+
+//*****************************************************************************
+//
+// This holds the current remaining size in bytes to be downloaded.
+//
+//*****************************************************************************
+uint32_t g_ui32TransferSize;
+
+//*****************************************************************************
+//
+// This holds the current address that is being written to during a download
+// command.
+//
+//*****************************************************************************
+uint32_t g_ui32TransferAddress;
+
+//*****************************************************************************
+//
+// This is the data buffer used during transfers to the boot loader.
+//
+//*****************************************************************************
+uint32_t g_pui32DataBuffer[BUFFER_SIZE];
+
+//*****************************************************************************
+//
+// This is an specially aligned buffer pointer to g_pui32DataBuffer to make
+// copying to the buffer simpler.  It must be offset to end on an address that
+// ends with 3.
+//
+//*****************************************************************************
+uint8_t *g_pui8DataBuffer;
+
+//*****************************************************************************
+//
+// Converts a word from big endian to little endian.  This macro uses compiler-
+// specific constructs to perform an inline insertion of the "rev" instruction,
+// which performs the byte swap directly.
+//
+//*****************************************************************************
+#if defined(ewarm)
+#include <intrinsics.h>
+#define SwapWord(x)             __REV(x)
+#endif
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+#define SwapWord(x) __extension__                                             \
+        ({                                                                    \
+             register uint32_t __ret, __inp = x;                              \
+             __asm__("rev %0, %1" : "=r" (__ret) : "r" (__inp));              \
+             __ret;                                                           \
+        })
+#endif
+#if defined(rvmdk) || defined(__ARMCC_VERSION)
+#define SwapWord(x)             __rev(x)
+#endif
+#if defined(ccs)
+uint32_t
+SwapWord(uint32_t x)
+{
+    __asm("    rev     r0, r0\n"
+          "    bx      lr\n"); // need this to make sure r0 is returned
+    return(x + 1); // return makes compiler happy - ignored
+}
+#endif
+
+
+//*****************************************************************************
+//
+//! Configures the microcontroller.
+//!
+//! This function configures the peripherals and GPIOs of the microcontroller,
+//! preparing it for use by the boot loader.  The interface that has been
+//! selected as the update port will be configured, and auto-baud will be
+//! performed if required.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+ConfigureUARTDevice(void)
+{
+#ifdef UART_ENABLE_UPDATE
+    uint32_t ui32ProcRatio;
+#endif
+
+#ifdef UART_ENABLE_UPDATE
+
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
+    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
+    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);
+/*
+    ROM_GPIOPinTypeUART(GPIO_PORTA_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+    ROM_UARTClockSourceSet(UART0_BASE, UART_CLOCK_PIOSC);
+    UARTStdioConfig(0, 921600, 16000000);
+    AckPacket(UART_UPDATE);
+*/
+#endif
+
+#ifdef CRYSTAL_FREQ
+    //
+    // Since the crystal frequency was specified, enable the main oscillator
+    // and clock the processor from it.
+    //
+    HWREG(SYSCTL_RCC) &= ~(SYSCTL_RCC_MOSCDIS);
+    //Delay(524288);
+    SysCtlDelay(524288);
+    HWREG(SYSCTL_RCC) = ((HWREG(SYSCTL_RCC) & ~(SYSCTL_RCC_OSCSRC_M)) |
+                         SYSCTL_RCC_OSCSRC_MAIN);
+#endif
+
+#ifdef UART_ENABLE_UPDATE
+    //
+    // Enable the the clocks to the UART and GPIO modules.
+    //
+    HWREG(SYSCTL_RCGC2) |= SYSCTL_RCGC2_GPIOA;
+    HWREG(SYSCTL_RCGC1) |= SYSCTL_RCGC1_UART0;
+    //
+    // Keep attempting to sync until we are successful.
+    //
+#ifdef UART_AUTOBAUD
+    while(UARTAutoBaud(&ui32ProcRatio) < 0)
+    {
+    }
+#else
+    ui32ProcRatio = UART_BAUD_RATIO(UART_FIXED_BAUDRATE);
+#endif
+    //
+    // Set GPIO A0 and A1 as UART pins.
+    //
+    HWREG(GPIO_PORTA_BASE + GPIO_O_AFSEL) |= UART_PINS;
+    //
+    // Set the pin type.
+    //
+    HWREG(GPIO_PORTA_BASE + GPIO_O_DEN) |= UART_PINS;
+    //
+    // Set the baud rate.
+    //
+    HWREG(UART0_BASE + UART_O_IBRD) = ui32ProcRatio >> 6;
+    HWREG(UART0_BASE + UART_O_FBRD) = ui32ProcRatio & UART_FBRD_DIVFRAC_M;//0x0000003F
+
+    //
+    // Set data length, parity, and number of stop bits to 8-N-1.
+    //
+    HWREG(UART0_BASE + UART_O_LCRH) = UART_LCRH_WLEN_8 | UART_LCRH_FEN;
+    //
+    // Enable RX, TX, and the UART.
+    //
+    HWREG(UART0_BASE + UART_O_CTL) = (UART_CTL_UARTEN | UART_CTL_TXE |
+                                      UART_CTL_RXE);
+
+#ifdef UART_AUTOBAUD
+    //
+    // Need to ack in the UART case to hold it up while we get things set up.
+    //
+    AckPacket(UART_UPDATE);
+#endif
+
+#endif
+}
+
+//*****************************************************************************
+//
+//! This function performs the update on the selected port.
+//!
+//! This function is called directly by the boot loader or it is called as a
+//! result of an update request from the application.
+//!
+//! \return Never returns.
+//
+//*****************************************************************************
+void
+UART_Updater(void)
+{
+    uint32_t ui32Size, ui32Temp, ui32FlashSize;
+
+    //
+    // This ensures proper alignment of the global buffer so that the one byte
+    // size parameter used by the packetized format is easily skipped for data
+    // transfers.
+    //
+    g_pui8DataBuffer = ((uint8_t *)g_pui32DataBuffer) + 3;
+
+    //
+    // Insure that the COMMAND_SEND_DATA cannot be sent to erase the boot
+    // loader before the application is erased.
+    //
+    g_ui32TransferAddress = 0xffffffff;
+
+    //
+    // Read any data from the serial port in use.
+    //
+    while(1)
+    {
+        //
+        // Receive a packet from the port in use.
+        //
+        ui32Size = sizeof(g_pui32DataBuffer) - 3;
+        if(ReceivePacket(g_pui8DataBuffer, &ui32Size, UART_UPDATE) != 0)
+        {
+            continue;
+        }
+        //
+        // The first byte of the data buffer has the command and determines
+        // the format of the rest of the bytes.
+        //
+        switch(g_pui8DataBuffer[0])
+        {
+            //
+            // This was a simple ping command.
+            //
+            case COMMAND_PING:
+            {
+                //
+                // This command always sets the status to COMMAND_RET_SUCCESS.
+                //
+                g_ui8Status = COMMAND_RET_SUCCESS;
+
+                //
+                // Just acknowledge that the command was received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command indicates the start of a download sequence.
+            //
+            case COMMAND_DOWNLOAD:
+            {
+                //
+                // Until determined otherwise, the command status is success.
+                //
+                g_ui8Status = COMMAND_RET_SUCCESS;
+
+                //
+                // A simple do/while(0) control loop to make error exits
+                // easier.
+                //
+                do
+                {
+                    //
+                    // See if a full packet was received.
+                    //
+                    if(ui32Size != 9)
+                    {
+                        //
+                        // Indicate that an invalid command was received.
+                        //
+                        g_ui8Status = COMMAND_RET_INVALID_CMD;
+                    	DPRINTF(("COMMAND_RET_INVALID_CMD\n"));
+
+                        //
+                        // This packet has been handled.
+                        //
+                        break;
+                    }
+
+                    //
+                    // Get the address and size from the command.
+                    //
+                    g_ui32TransferAddress = SwapWord(g_pui32DataBuffer[1]);
+                    g_ui32TransferSize = SwapWord(g_pui32DataBuffer[2]);
+#ifdef BL_PROGRESS_FN_HOOK
+                    g_ui32ImageSize = g_ui32TransferSize;
+#endif
+
+                    //
+                    // Check for a valid starting address and image size.
+                    //
+                    if(!BL_FLASH_AD_CHECK_FN_HOOK(g_ui32TransferAddress,
+                                                  g_ui32TransferSize))
+                    {
+                        //
+                        // Set the code to an error to indicate that the last
+                        // command failed.  This informs the updater program
+                        // that the download command failed.
+                        //
+                        g_ui8Status = COMMAND_RET_INVALID_ADR;
+                    	DPRINTF(("COMMAND_RET_INVALID_ADR\n"));
+
+                        //
+                        // This packet has been handled.
+                        //
+                        break;
+                    }
+
+
+                    //
+                    // Only erase the space that we need if we are not
+                    // protecting the code, otherwise erase the entire flash.
+                    //
+#ifdef FLASH_CODE_PROTECTION
+                    ui32FlashSize = BL_FLASH_SIZE_FN_HOOK();
+#ifdef FLASH_RSVD_SPACE
+                    if((ui32FlashSize - FLASH_RSVD_SPACE) !=
+                       g_ui32TransferAddress)
+                    {
+                        ui32FlashSize -= FLASH_RSVD_SPACE;
+                    }
+#endif
+#else
+                    ui32FlashSize = g_ui32TransferAddress + g_ui32TransferSize;
+#endif
+
+                    //
+                    // Clear the flash access interrupt.
+                    //
+                    BL_FLASH_CL_ERR_FN_HOOK();
+
+                    //
+                    // Leave the boot loader present until we start getting an
+                    // image.
+                    //
+                    for(ui32Temp = g_ui32TransferAddress;
+                        ui32Temp < ui32FlashSize; ui32Temp += FLASH_PAGE_SIZE)
+                    {
+                        //
+                        // Erase this block.
+                        //
+                        BL_FLASH_ERASE_FN_HOOK(ui32Temp);
+                    }
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        g_ui8Status = COMMAND_RET_FLASH_FAIL;
+                    }
+                }
+                while(0);
+
+                //
+                // See if the command was successful.
+                //
+                if(g_ui8Status != COMMAND_RET_SUCCESS)
+                {
+                    //
+                    // Setting g_ui32TransferSize to zero makes
+                    // COMMAND_SEND_DATA fail to accept any data.
+                    //
+                    g_ui32TransferSize = 0;
+                }
+
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // If we have a start notification hook function, call it
+                // now if everything is OK.
+                //
+#ifdef BL_START_FN_HOOK
+                if(g_ui32TransferSize)
+                {
+                    BL_START_FN_HOOK();
+                }
+#endif
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command indicates that control should be transferred to
+            // the specified address.
+            //
+            case COMMAND_RUN:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // See if a full packet was received.
+                //
+                if(ui32Size != 5)
+                {
+                    //
+                    // Indicate that an invalid command was received.
+                    //
+                    g_ui8Status = COMMAND_RET_INVALID_CMD;
+                	DPRINTF(("run - COMMAND_RET_INVALID_CMD\n"));
+
+                    //
+                    // This packet has been handled.
+                    //
+                    break;
+                }
+
+                //
+                // Get the address to which control should be transferred.
+                //
+                g_ui32TransferAddress = SwapWord(g_pui32DataBuffer[1]);
+
+                //
+                // This determines the size of the flash available on the
+                // device in use.
+                //
+                //Mini
+                //ui32FlashSize = BL_FLASH_SIZE_FN_HOOK();
+                ui32FlashSize = 0x100000;
+                //
+                // Test if the transfer address is valid for this device.
+                //
+                if(g_ui32TransferAddress >= ui32FlashSize)
+                {
+                    //
+                    // Indicate that an invalid address was specified.
+                    //
+                    g_ui8Status = COMMAND_RET_INVALID_ADR;
+                	DPRINTF(("run - COMMAND_RET_INVALID_ADR\n"));
+
+                    //
+                    // This packet has been handled.
+                    //
+                    break;
+                }
+
+                //
+                // Make sure that the ACK packet has been sent.
+                //
+                UARTFlush();
+
+                //
+                // Reset and disable the peripherals used by the boot loader.
+                //
+                /*
+                HWREG(SYSCTL_RCGC1) &= ~SYSCTL_RCGC1_UART4;
+                HWREG(SYSCTL_SRCR1) = SYSCTL_RCGC1_UART4;
+                */
+                HWREG(SYSCTL_RCGC1) &= ~SYSCTL_RCGC1_UART0;
+                HWREG(SYSCTL_SRCR1) = SYSCTL_RCGC1_UART0;
+                HWREG(SYSCTL_SRCR1) = 0;
+
+//Mini : Start image from 0x8000 ---------------------------------------------------------
+            	if (CheckImage(APP_START_ADDRESS) == 0)
+            	{
+                	//uint32_t ui32delData;
+                	//EEPROMRead(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+                	//ui32delData = (ui32delData & 0x0000FFFF) | 0x01<<24;
+                	//EEPROMProgram(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+            	    //
+            	    // Pass control to the application.
+            	    //
+            	    DPRINTF(("There is a valid image in the flash.\n"));
+            	    CallApplication(APP_START_ADDRESS);
+            	}
+//----------------------------------------------------------------------------------------
+
+                //
+                // Branch to the specified address.  This should never return.
+                // If it does, very bad things will likely happen since it is
+                // likely that the copy of the boot loader in SRAM will have
+                // been overwritten.
+                //
+                ((void (*)(void))g_ui32TransferAddress)();
+
+                //
+                // In case this ever does return and the boot loader is still
+                // intact, simply reset the device.
+                //
+                HWREG(NVIC_APINT) = (NVIC_APINT_VECTKEY |
+                                     NVIC_APINT_SYSRESETREQ);
+
+                //
+                // The microcontroller should have reset, so this should
+                // never be reached.  Just in case, loop forever.
+                //
+                while(1)
+                {
+                }
+            }
+
+            //
+            // This command just returns the status of the last command that
+            // was sent.
+            //
+            case COMMAND_GET_STATUS:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // Return the status to the updater.
+                //
+                SendPacket(&g_ui8Status, 1, UART_UPDATE);
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command is sent to transfer data to the device following
+            // a download command.
+            //
+            case COMMAND_SEND_DATA:
+            {
+                //
+                // Until determined otherwise, the command status is success.
+                //
+                g_ui8Status = COMMAND_RET_SUCCESS;
+
+                //
+                // If this is overwriting the boot loader then the application
+                // has already been erased so now erase the boot loader.
+                //
+                if(g_ui32TransferAddress == 0)
+                {
+                    //
+                    // Clear the flash access interrupt.
+                    //
+                    BL_FLASH_CL_ERR_FN_HOOK();
+
+                    //
+                    // Erase the boot loader.
+                    //
+                    for(ui32Temp = 0; ui32Temp < APP_START_ADDRESS;
+                        ui32Temp += FLASH_PAGE_SIZE)
+                    {
+                        //
+                        // Erase this block.
+                        //
+                        BL_FLASH_ERASE_FN_HOOK(ui32Temp);
+                    }
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        //
+                        // Setting g_ui32TransferSize to zero makes
+                        // COMMAND_SEND_DATA fail to accept any more data.
+                        //
+                        g_ui32TransferSize = 0;
+
+                        //
+                        // Indicate that the flash erase failed.
+                        //
+                        g_ui8Status = COMMAND_RET_FLASH_FAIL;
+                    	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_FLASH_FAIL\n"));
+                    }
+                }
+
+                //
+                // Take one byte off for the command.
+                //
+                ui32Size = ui32Size - 1;
+
+                //
+                // Check if there are any more bytes to receive.
+                //
+                if(g_ui32TransferSize >= ui32Size)
+                {
+                    //
+                    // If we have been provided with a decryption hook function
+                    // call it here.
+                    //
+#ifdef BL_DECRYPT_FN_HOOK
+                    BL_DECRYPT_FN_HOOK(g_pui8DataBuffer + 1, ui32Size);
+#endif
+
+                    //
+                    // Write this block of data to the flash
+                    //
+                    BL_FLASH_PROGRAM_FN_HOOK(g_ui32TransferAddress,
+                                             (uint8_t *) &g_pui32DataBuffer[1],
+                                             ((ui32Size + 3) & ~3));
+
+                    //
+                    // Return an error if an access violation occurred.
+                    //
+                    if(BL_FLASH_ERROR_FN_HOOK())
+                    {
+                        //
+                        // Indicate that the flash programming failed.
+                        //
+                        g_ui8Status = COMMAND_RET_FLASH_FAIL;
+                    	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_FLASH_FAIL\n"));
+                    }
+                    else
+                    {
+                        //
+                        // Now update the address to program.
+                        //
+                        g_ui32TransferSize -= ui32Size;
+                        g_ui32TransferAddress += ui32Size;
+
+                        //
+                        // If a progress hook function has been provided, call
+                        // it here.
+                        //
+#ifdef BL_PROGRESS_FN_HOOK
+                        BL_PROGRESS_FN_HOOK(g_ui32ImageSize -
+                                            g_ui32TransferSize,
+                                            g_ui32ImageSize);
+#endif
+                    }
+                }
+                else
+                {
+                    //
+                    // This indicates that too much data is being sent to the
+                    // device.
+                    //
+                    g_ui8Status = COMMAND_RET_INVALID_ADR;
+                	DPRINTF(("COMMAND_SEND_DATA - COMMAND_RET_INVALID_ADR\n"));
+                }
+
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // If we have an end notification hook function, and we've
+                // reached the end, call it now.
+                //
+#ifdef BL_END_FN_HOOK
+                if(g_ui32TransferSize == 0)
+                {
+                    BL_END_FN_HOOK();
+                }
+#endif
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+
+            //
+            // This command is used to reset the device.
+            //
+            case COMMAND_RESET:
+            {
+                //
+                // Send out a one-byte ACK to ensure the byte goes back to the
+                // host before we reset everything.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // Make sure that the ACK packet has been sent.
+                //
+                UARTFlush();
+
+                //
+                // Perform a software reset request.  This will cause the
+                // microcontroller to reset; no further code will be executed.
+                //
+                HWREG(NVIC_APINT) = (NVIC_APINT_VECTKEY |
+                                     NVIC_APINT_SYSRESETREQ);
+
+                //
+                // The microcontroller should have reset, so this should never
+                // be reached.  Just in case, loop forever.
+                //
+                while(1)
+                {
+                }
+            }
+
+            //
+            // Just acknowledge the command and set the error to indicate that
+            // a bad command was sent.
+            //
+            default:
+            {
+                //
+                // Acknowledge that this command was received correctly.  This
+                // does not indicate success, just that the command was
+                // received.
+                //
+                AckPacket(UART_UPDATE);
+
+                //
+                // Indicate that a bad comand was sent.
+                //
+                g_ui8Status = COMMAND_RET_UNKNOWN_CMD;
+            	DPRINTF(("default - COMMAND_RET_UNKNOWN_CMD\n"));
+
+                //
+                // Go back and wait for a new command.
+                //
+                break;
+            }
+        }
+    }
+}
+
+//*****************************************************************************
+//
+//! Sends data over the UART port.
+//!
+//! \param pui8Data is the buffer containing the data to write out to the UART
+//! port.
+//! \param ui32Size is the number of bytes provided in \e pui8Data buffer that
+//! will be written out to the UART port.
+//!
+//! This function sends \e ui32Size bytes of data from the buffer pointed to by
+//! \e pui8Data via the UART port.
+//!
+//! \return None.
+//
+//*****************************************************************************
+void
+UARTSend(const uint8_t *pui8Data, uint32_t ui32Size)
+{
+	//DPRINTF(("UARTSend - ui32Size:%d %x\n",ui32Size,*pui8Data));
+    //
+    // Transmit the number of bytes requested on the UART port.
+    //
+    while(ui32Size--)
+    {
+        //
+        // Make sure that the transmit FIFO is not full.
+        //
+        while((HWREG(UART0_BASE + UART_O_FR) & UART_FR_TXFF))
+        {
+        }
+
+        //
+        // Send out the next byte.
+        //
+        HWREG(UART0_BASE + UART_O_DR) = *pui8Data++;
+    }
+
+    //
+    // Wait until the UART is done transmitting.
+    //
+    UARTFlush();
+}
+
+//*****************************************************************************
+//
+//! Waits until all data has been transmitted by the UART port.
+//!
+//! This function waits until all data written to the UART port has been
+//! transmitted.
+//!
+//! \return None.
+//
+//*****************************************************************************
+int
+UARTFlush()
+{
+	uint32_t Timeout=30000000*2; //30 seconeds
+    //
+    // Wait for the UART FIFO to empty and then wait for the shifter to get the
+    // bytes out the port.
+    //
+    while(!(HWREG(UART0_BASE + UART_O_FR) & UART_FR_TXFE))
+    {
+    	if(!Timeout--)
+    	{
+    		return(-1);
+    	}
+    }
+
+	Timeout=30000000*2; //30 seconeds
+    //
+    // Wait for the FIFO to not be busy so that the shifter completes.
+    //
+    while((HWREG(UART0_BASE + UART_O_FR) & UART_FR_BUSY))
+    {
+    	if(!Timeout--)
+    	{
+    		return(-1);
+    	}
+    }
+	return(0);
+}
+
+//*****************************************************************************
+//
+//! Receives data over the UART port.
+//!
+//! \param pui8Data is the buffer to read data into from the UART port.
+//! \param ui32Size is the number of bytes provided in the \e pui8Data buffer
+//! that should be written with data from the UART port.
+//!
+//! This function reads back \e ui32Size bytes of data from the UART port, into
+//! the buffer that is pointed to by \e pui8Data.  This function will not
+//! return until \e ui32Size number of bytes have been received.
+//!
+//! \return None.
+//
+//*****************************************************************************
+int
+UARTReceive(uint8_t *pui8Data, uint32_t ui32Size)
+{
+	uint32_t Timeout=30000000*2; //30 seconeds
+	//
+    // Send out the number of bytes requested.
+    //
+	//DPRINTF(("UARTReceive - ui32Size:%d\n",ui32Size));
+    while(ui32Size--)
+    {
+    	Timeout=30000000*2; //30 seconeds
+        //
+        // Wait for the FIFO to not be empty.
+        //
+        while((HWREG(UART0_BASE + UART_O_FR) & UART_FR_RXFE))
+        {
+        	if(!Timeout--)
+        	{
+        		return(-1);
+        	}
+        }
+
+        //
+        // Receive a byte from the UART.
+        //
+        *pui8Data++ = HWREG(UART0_BASE + UART_O_DR);
+        //*pui8Data--;
+    	//DPRINTF(("UARTReceive data - 0x%x\n",*pui8Data));
+        //*pui8Data++;
+    }
+	return(0);
+}
+//*****************************************************************************
+//
+// Close the Doxygen group.
+//! @}
+//
+//*****************************************************************************
+#endif
+
diff --unidirectional-new-file -ru f09_tmp/bl_uart.h f09_bootloader_202/bl_uart.h
--- f09_tmp/bl_uart.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bl_uart.h	2017-08-23 13:37:40.990000000 +0800
@@ -0,0 +1,130 @@
+//*****************************************************************************
+//
+// bl_uart.h - Definitions for the UART transport functions.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1.0 of the Tiva Firmware Development Package.
+//
+//*****************************************************************************
+
+#ifndef __BL_UART_H__
+#define __BL_UART_H__
+
+//*****************************************************************************
+//
+// Enables automatic baud rate detection.  This can be used if the crystal
+// frequency is unknown, or if operation at different baud rates is desired.
+//
+// Depends on: UART_ENABLE_UPDATE
+// Exclusive of: UART_FIXED_BAUDRATE
+// Requires: None
+//
+//*****************************************************************************
+//#define UART_AUTOBAUD
+
+//*****************************************************************************
+//
+// This macro is used to generate a constant to represent the UART baud rate to
+// processor clock rate ratio.  This prevents the need for run-time calculation
+// of the ratio of baud rate to processor clock rate ratio.
+//
+//*****************************************************************************
+#define UART_BAUD_RATIO(ui32Baud)                                             \
+                                ((((CRYSTAL_FREQ * 8) / ui32Baud) + 1) / 2)
+//*****************************************************************************
+//
+// This defines the UART receive pin that is being used by the boot loader.
+//
+//*****************************************************************************
+#define UART_RX                 (1 << 0)
+
+//*****************************************************************************
+//
+// This defines the UART transmit pin that is being used by the boot loader.
+//
+//*****************************************************************************
+#define UART_TX                 (1 << 1)
+
+//*****************************************************************************
+//
+// This defines the combination of pins used to implement the UART port used by
+// the boot loader.
+//
+//*****************************************************************************
+#define UART_PINS               (UART_RX | UART_TX)
+
+
+//*****************************************************************************
+//
+// Selects the baud rate to be used for the UART.
+//
+// Depends on: UART_ENABLE_UPDATE, CRYSTAL_FREQ
+// Exclusive of: UART_AUTOBAUD
+// Requires: None
+//
+//*****************************************************************************
+#define UART_FIXED_BAUDRATE     115200
+//*****************************************************************************
+//
+// The number of words in the data buffer used for receiving packets.  This
+// value must be at least 3.  If using autobauding on the UART, this must be at
+// least 20.  The maximum usable value is 65 (larger values will result in
+// unused space in the buffer).
+//
+// Depends on: None
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+#define BUFFER_SIZE             65//20
+//*****************************************************************************
+//
+// The frequency of the crystal used to clock the microcontroller.
+//
+// This defines the crystal frequency used by the microcontroller running the
+// boot loader.  If this is unknown at the time of production, then use the
+// UART_AUTOBAUD feature to properly configure the UART.
+//
+// Depends on: None
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+//#define CRYSTAL_FREQ            8000000
+#define CRYSTAL_FREQ            16000000
+
+//*****************************************************************************
+//
+// UART Transport APIs
+//
+//*****************************************************************************
+extern void UARTSend(const uint8_t *pui8Data, uint32_t ui32Size);
+extern int UARTReceive(uint8_t *pui8Data, uint32_t ui32Size);
+extern int UARTFlush();
+extern int UARTAutoBaud(uint32_t *pui32Ratio);
+
+//*****************************************************************************
+//
+// Define the transport functions if the UART is being used.
+//
+//*****************************************************************************
+//#define SendData                UARTSend
+//#define FlushData               UARTFlush
+//#define ReceiveData             UARTReceive
+
+#endif // __BL_UART_H__
diff --unidirectional-new-file -ru f09_tmp/bmc_blcfg.h f09_bootloader_202/bmc_blcfg.h
--- f09_tmp/bmc_blcfg.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/bmc_blcfg.h	2017-08-23 13:37:40.356000000 +0800
@@ -0,0 +1,187 @@
+//*****************************************************************************
+//
+// bmc_blcfg.h - The configurable parameters of the boot loader.
+//
+// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#ifndef __BMC_BLCFG_H__
+#define __BMC_BLCFG_H__
+
+//*****************************************************************************
+//
+// The number of words of stack space that were reserved for the boot loader.
+//
+//*****************************************************************************
+#ifndef STACK_SIZE
+#define STACK_SIZE              128
+#endif
+
+//*****************************************************************************
+//
+// Specifies the hard coded MAC address for the Ethernet interface.  There are
+// six individual values (ENET_MAC_ADDR0 through ENET_MAC_ADDR5) that provide
+// the six bytes of the MAC address, where ENET_MAC_ADDR0 though ENET_MAC_ADDR2
+// provide the organizationally unique identifier (OUI) and ENET_MAC_ADDR3
+// through ENET_MAC_ADDR5 provide the extension identifier.
+//
+//*****************************************************************************
+#ifndef ENET_MAC_ADDR0
+#define ENET_MAC_ADDR0          0x00
+#define ENET_MAC_ADDR1          0x12
+#define ENET_MAC_ADDR2          0xD1
+#define ENET_MAC_ADDR3          0x16
+#define ENET_MAC_ADDR4          0x79
+#define ENET_MAC_ADDR5          0x05
+#endif
+
+
+//*****************************************************************************
+//
+// The total size of flash to allow the boot loader to write to during an
+// update. This is used to determine the end via MCU_FLASH_SIZE -
+// APP_START_ADDR. This should not exceed the maximum flash on the processor.
+// Check the datasheet to determine maximum flash size.
+//
+//*****************************************************************************
+#ifndef MCU_FLASH_SIZE
+#define MCU_FLASH_SIZE          0x100000
+#endif
+
+//*****************************************************************************
+//
+// The size of a single, erasable page in the flash. For internal flash
+// targets, this is MCU-dependent. Please check the datasheet.
+//
+//*****************************************************************************
+#ifndef FLASH_PAGE_SIZE
+#define FLASH_PAGE_SIZE         0x00004000
+#endif
+
+//*****************************************************************************
+//
+// The flash address where the application code should reside.
+//
+//*****************************************************************************
+#ifndef APP_START_ADDRESS
+#define APP_START_ADDRESS       0x00008000
+#endif
+
+//*****************************************************************************
+//
+// Location in flash that holds the Update information.
+// This is expected to be:
+//          bool RunUpdate (32bits storage)
+//          TFTP server IP (32bits storage)
+//          Application firmware image file name (1024bits storage)
+//
+//*****************************************************************************
+#ifndef FLASH_ADDR_UPDATE
+#define FLASH_ADDR_UPDATE       		0x0007C000 ////0x00004000
+#endif
+
+#ifndef FLASH_BLOCK_PROTECT_SIZE
+#define FLASH_BLOCK_PROTECT_SIZE        2*1024 //2K
+#endif
+
+#ifndef FLASH_UPDATE_DATA_SIZE
+#define FLASH_UPDATE_DATA_SIZE  		0x88
+#endif
+
+//Jerry130724
+// *****************************************************************************************************/
+// log tftp update info from the internal EEPROM 4k offset
+// 0x1000 ~ 0x1004   : tftp update flag, 0x00000001:need to update ,0x0 don't need to update
+//                      LPC update flag, 0x00000002:need to update
+//                     UART update flag, 0x00000003:need to update
+//                      I2C update flag, 0x00000004:need to update
+// 0x1005 ~ 0x1008   : tftp server ip address , user can set the ip addresss by using OEM command 0x30 0x23 0x01 and 4 byte ipadr
+// 0x1009 ~ 0x1089   : tftp image file name , user can set the image name by using OEM command 0x30 0x23 0x02 and file name ASCII code with 0x00 in the end
+// *****************************************************************************************************/
+#ifndef EEPROM_ADDR_UPDATE
+#define EEPROM_ADDR_UPDATE	0x1000    
+#endif
+
+#ifndef EEPROM_UPDATE_DATA_SIZE
+#define EEPROM_UPDATE_DATA_SIZE	0x88    
+#endif
+
+#ifndef EEPROM_ADDR_WD_FLAG
+#define EEPROM_ADDR_WD_FLAG       		0x1100
+#endif
+
+#ifndef EEPROM_FLASH_CLEAR_FLAG
+#define EEPROM_FLASH_CLEAR_FLAG       	0x1080
+#endif
+
+#ifndef EEPROM_DHCP_RETRY_FLAG
+#define EEPROM_DHCP_RETRY_FLAG       	0x10C0
+#endif
+
+
+#define UIP_DHCP_DISCOVER_TIMES	4
+#define UIP_DHCP_RETRY        	3
+
+#define bootver_offet		0x558
+#define WDTRETRY			0x05
+
+#define		BOOT_MAJOR_VERSION	2
+#define		BOOT_MINOR_VERSION	02
+#define     BOOT_FIRMWARE_VERSION            BOOT_MAJOR_VERSION << 8 | BOOT_MINOR_VERSION 
+
+
+//*****************************************************************************
+//
+// Setup output on UART0, only if DEBUG is enabled.
+//
+//*****************************************************************************
+#ifdef DEBUG
+#include <stdbool.h>
+#include <stdint.h>
+#include "driverlib/uart.h"
+#include "utils/uartstdio.h"
+#define DPRINTF(a)      \
+    do                  \
+    {                   \
+        UARTprintf a ;  \
+    } while(0)
+
+#else
+#define DPRINTF(a)
+#endif
+
+
+//*****************************************************************************
+//
+// The OEM feature definitions
+//
+//*****************************************************************************
+//#define OEM_HOOK
+
+#define I2C_ENABLE_UPDATE
+#define UART_ENABLE_UPDATE
+
+#define UART_UPDATE 0
+#define I2C_UPDATE 1
+
+#endif // __BMC_BLCFG_H__
diff --unidirectional-new-file -ru f09_tmp/boot_loader/bl_flash.h f09_bootloader_202/boot_loader/bl_flash.h
--- f09_tmp/boot_loader/bl_flash.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/boot_loader/bl_flash.h	2017-08-23 13:37:40.377000000 +0800
@@ -0,0 +1,148 @@
+//*****************************************************************************
+//
+// bl_flash.h - Flash programming functions used by the boot loader.
+//
+// Copyright (c) 2006-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC Firmware Development Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#ifndef __BL_FLASH_H__
+#define __BL_FLASH_H__
+
+#include "driverlib/rom.h"
+#include "inc/hw_flash.h"
+
+//*****************************************************************************
+//
+// Basic functions for erasing and programming internal flash.
+//
+//*****************************************************************************
+extern void BLInternalFlashErase(uint32_t ui32Address);
+extern void BLInternalFlashProgram(uint32_t ui32DstAddr, uint8_t *pui8SrcData,
+                                   uint32_t ui32Length);
+extern uint32_t BLInternalFlashSizeGet(void);
+extern uint32_t BLInternalFlashStartAddrCheck(uint32_t ui32Addr,
+                                              uint32_t ui32ImgSize);
+extern uint32_t BLInternalFlashErrorCheck(void);
+extern void BLInternalFlashErrorClear(void);
+
+//*****************************************************************************
+//
+// If the user has not specified which flash programming functions to use,
+// default to the basic, internal flash functions on Sandstorm, Fury and
+// DustDevil parts or the ROM-resident function for Tempest-class parts.
+//
+//*****************************************************************************
+#ifndef BL_FLASH_ERASE_FN_HOOK
+#define BL_FLASH_ERASE_FN_HOOK(ui32Address)                                   \
+        {                                                                     \
+            HWREG(FLASH_FMA) = (ui32Address);                                 \
+            HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;             \
+            while(HWREG(FLASH_FMC) & FLASH_FMC_ERASE)                         \
+            {                                                                 \
+            }                                                                 \
+        }
+#else
+extern void BL_FLASH_ERASE_FN_HOOK(uint32_t ui32Address);
+#endif
+
+#ifndef BL_FLASH_PROGRAM_FN_HOOK
+#ifdef ROM_FlashProgram
+#define BL_FLASH_PROGRAM_FN_HOOK(ui32DstAddr, pui8SrcData, ui32Length)        \
+        ROM_FlashProgram((uint32_t *)pui8SrcData, ui32DstAddr,                \
+                         (((ui32Length) + 3) & ~3))
+#else
+#define BL_FLASH_PROGRAM_FN_HOOK(ui32DstAddr, pui8SrcData, ui32Length)        \
+        {                                                                     \
+            uint32_t ui32FlashProgLoop;                                       \
+                                                                              \
+            for(ui32FlashProgLoop = 0; ui32FlashProgLoop < (ui32Length);      \
+                ui32FlashProgLoop += 4)                                       \
+            {                                                                 \
+                HWREG(FLASH_FMA) = (ui32DstAddr) + ui32FlashProgLoop;         \
+                HWREG(FLASH_FMD) = *(uint32_t *)((pui8SrcData) +              \
+                                                 ui32FlashProgLoop);          \
+                HWREG(FLASH_FMC) = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;         \
+                while(HWREG(FLASH_FMC) & FLASH_FMC_WRITE)                     \
+                {                                                             \
+                }                                                             \
+            }                                                                 \
+        }
+#endif
+#else
+extern uint32_t BL_FLASH_PROGRAM_FN_HOOK(uint32_t ui32DstAddr,
+                                         uint8_t *pui8SrcData,
+                                         uint32_t ui32Length);
+#endif
+
+#ifndef BL_FLASH_CL_ERR_FN_HOOK
+#define BL_FLASH_CL_ERR_FN_HOOK() HWREG(FLASH_FCMISC) = FLASH_FCMISC_AMISC
+#else
+extern void BL_FLASH_CL_ERR_FN_HOOK(void);
+#endif
+
+#ifndef BL_FLASH_ERROR_FN_HOOK
+#define BL_FLASH_ERROR_FN_HOOK()    (HWREG(FLASH_FCRIS) & FLASH_FCRIS_ARIS)
+#else
+extern uint32_t BL_FLASH_ERROR_FN_HOOK(void);
+#endif
+
+#ifndef BL_FLASH_SIZE_FN_HOOK
+#define BL_FLASH_SIZE_FN_HOOK()                                               \
+        (((HWREG(SYSCTL_DC0) & SYSCTL_DC0_FLASHSZ_M) + 1) << 11)
+#else
+extern uint32_t BL_FLASH_SIZE_FN_HOOK(void);
+#endif
+
+#ifndef BL_FLASH_END_FN_HOOK
+#define BL_FLASH_END_FN_HOOK()                                               \
+        (((HWREG(SYSCTL_DC0) & SYSCTL_DC0_FLASHSZ_M) + 1) << 11)
+#else
+extern uint32_t BL_FLASH_END_FN_HOOK(void);
+#endif
+
+#ifndef BL_FLASH_AD_CHECK_FN_HOOK
+#define BL_FLASH_AD_CHECK_FN_HOOK(ui32Addr, ui32Size)                         \
+        BLInternalFlashStartAddrCheck((ui32Addr), (ui32Size))
+#else
+extern uint32_t BL_FLASH_AD_CHECK_FN_HOOK(uint32_t ui32Address,
+                                          uint32_t ui32Length);
+#endif
+
+//*****************************************************************************
+//
+// The starting address of the application.  This must be a multiple of 1024
+// bytes (making it aligned to a page boundary).  A vector table is expected at
+// this location, and the perceived validity of the vector table (stack located
+// in SRAM, reset vector located in flash) is used as an indication of the
+// validity of the application image.
+//
+// The flash image of the boot loader must not be larger than this value.
+//
+// Depends on: None
+// Exclusive of: None
+// Requires: None
+//
+//*****************************************************************************
+#define APP_START_ADDRESS       0x00008000
+
+#endif // __BL_FLASH_H__
diff --unidirectional-new-file -ru f09_tmp/boot_loader/bl_hooks.h f09_bootloader_202/boot_loader/bl_hooks.h
--- f09_tmp/boot_loader/bl_hooks.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/boot_loader/bl_hooks.h	2017-08-23 13:37:40.381000000 +0800
@@ -0,0 +1,75 @@
+//*****************************************************************************
+//
+// bl_hooks.h - Definitions for the application-specific hook function.
+//
+// Copyright (c) 2009-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC Firmware Development Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#ifndef __BL_HOOKS_H__
+#define __BL_HOOKS_H__
+
+//*****************************************************************************
+//
+// Prototypes for any application-specific hook functions that are defined in
+// bl_config.h.  Note that the low level flash programming hooks are handled
+// in bl_flash.h to allow us to define macros for internal flash programming
+// in the normal case where no override functions are provided.
+//
+//*****************************************************************************
+#ifdef BL_HW_INIT_FN_HOOK
+extern void BL_HW_INIT_FN_HOOK(void);
+#endif
+#ifdef BL_INIT_FN_HOOK
+extern void BL_INIT_FN_HOOK(void);
+#endif
+#ifdef BL_REINIT_FN_HOOK
+extern void BL_REINIT_FN_HOOK(void);
+#endif
+#ifdef BL_START_FN_HOOK
+extern void BL_START_FN_HOOK(void);
+#endif
+#ifdef BL_PROGRESS_FN_HOOK
+extern void BL_PROGRESS_FN_HOOK(uint32_t ui32Completed, uint32_t ui32Total);
+#endif
+#ifdef BL_END_FN_HOOK
+extern void BL_END_FN_HOOK(void);
+#endif
+#ifdef BL_DECRYPT_FN_HOOK
+extern void BL_DECRYPT_FN_HOOK(uint8_t *pui8Buffer, uint32_t ui32Size);
+#endif
+#ifdef BL_CHECK_UPDATE_FN_HOOK
+extern uint32_t BL_CHECK_UPDATE_FN_HOOK(void);
+#endif
+
+//*****************************************************************************
+//
+// If ENABLE_DECRYPTION is defined but we don't have a hook function set for
+// decryption, default to the previous behavior which calls the stub function
+// DecryptData.
+//
+//*****************************************************************************
+#if (defined ENABLE_DECRYPTION) && !(defined BL_DECRYPT_FN_HOOK)
+#define BL_DECRYPT_FN_HOOK      DecryptData
+#endif
+
+#endif // __BL_HOOKS_H__
diff --unidirectional-new-file -ru f09_tmp/boot_lpc.c f09_bootloader_202/boot_lpc.c
--- f09_tmp/boot_lpc.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/boot_lpc.c	2017-08-23 13:37:39.884000000 +0800
@@ -0,0 +1,1590 @@
+//*****************************************************************************
+//
+// boot_lpc.c - TI LPC flash boot loader.
+//
+// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+#include <stdbool.h>
+#include <stdint.h>
+#include <time.h>
+
+#include "inc/hw_flash.h"
+#include "inc/hw_gpio.h"
+#include "inc/hw_lpcb.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_timer.h"
+#include "inc/hw_types.h"
+#include "driverlib/flash.h"
+#include "driverlib/gpio.h"
+#include "driverlib/lpcb.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/rom_map.h"
+#include "driverlib/sw_crc.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/timer.h"
+#include "boot_loader/bl_flash.h"
+#include "bmc_blcfg.h"
+#include "driverlib/eeprom.h"
+
+
+//*****************************************************************************
+//
+// Clock configuration.
+//
+//*****************************************************************************
+#define LPCBOOT_SYSCTL_CLOCK    (SYSCTL_OSC_INT | SYSCTL_USE_PLL |            \
+                                 SYSCTL_CFG_VCO_480)
+#define LPCBOOT_CLOCK_HZ        120000000
+
+//*****************************************************************************
+//
+// The error codes that can be returned by the image check function.
+//
+//*****************************************************************************
+#define IMG_ERR_NONE            0
+#define IMG_ERR_BAD_ALIGNMENT   1
+#define IMG_ERR_INVALID_SP      2
+#define IMG_ERR_INVALID_PC      3
+
+//*****************************************************************************
+//
+// Return values/error codes for LPC boot loader functions.
+//
+//*****************************************************************************
+#define RC_OK                   0
+//
+// Leave room for image check/image run return codes.
+//
+#define RC_PROBE_DETECT         4
+#define RC_TIMEOUT              5
+#define RC_ERR_BAD_ADDRESS      6
+#define RC_ERR_BAD_ALIGNMENT    7
+#define RC_ERR_BAD_CMD          8
+#define RC_ERR_BAD_LENGTH       9
+#define RC_ERR_BAD_SUBCMD       10
+#define RC_ERR_BAD_PAD          11
+#define RC_ERR_BAD_SIZE         12
+#define RC_ERR_BAD_TRIGGER      13
+#define RC_ERR_BAD_CRC          14
+#define RC_ERR_BAD_IMAGE        15
+
+//*****************************************************************************
+//
+// Define the GPIO ports and pins used for the LPC signals.
+//
+//*****************************************************************************
+#define LPC_AD0_PINCFG      GPIO_PM3_LPC0AD0
+#define LPC_AD0_PORT_BASE   GPIO_PORTM_BASE
+#define LPC_AD0_PORT_PIN    GPIO_PIN_3
+#define LPC_AD1_PINCFG      GPIO_PM2_LPC0AD1
+#define LPC_AD1_PORT_BASE   GPIO_PORTM_BASE
+#define LPC_AD1_PORT_PIN    GPIO_PIN_2
+#define LPC_AD2_PINCFG      GPIO_PM1_LPC0AD2
+#define LPC_AD2_PORT_BASE   GPIO_PORTM_BASE
+#define LPC_AD2_PORT_PIN    GPIO_PIN_1
+#define LPC_AD3_PINCFG      GPIO_PM0_LPC0AD3
+#define LPC_AD3_PORT_BASE   GPIO_PORTM_BASE
+#define LPC_AD3_PORT_PIN    GPIO_PIN_0
+#define LPC_CLK_PINCFG      GPIO_PL1_LPC0CLK
+#define LPC_CLK_PORT_BASE   GPIO_PORTL_BASE
+#define LPC_CLK_PORT_PIN    GPIO_PIN_1
+#define LPC_FRAMEn_PINCFG   GPIO_PL0_LPC0FRAME_N
+#define LPC_FRAMEn_PORT_BASE                                                  \
+                            GPIO_PORTL_BASE
+#define LPC_FRAMEn_PORT_PIN GPIO_PIN_0
+#define LPC_RESETn_PINCFG   GPIO_PB3_LPC0RESET_N
+#define LPC_RESETn_PORT_BASE                                                  \
+                            GPIO_PORTB_BASE
+#define LPC_RESETn_PORT_PIN GPIO_PIN_3
+#define LPC_SERIRQ_PINCFG   GPIO_PL3_LPC0SERIRQ
+#define LPC_SERIRQ_PORT_BASE                                                  \
+                            GPIO_PORTL_BASE
+#define LPC_SERIRQ_PORT_PIN GPIO_PIN_3
+
+//*****************************************************************************
+//
+// Boot Option Pin-Strap
+//
+// Note: All GPIO peripherals are enabled during init, so it is not
+// necessary to specifically define the peripheral here.
+//
+//*****************************************************************************
+#define BOOT_OPT_0_PORT     GPIO_PORTA_BASE
+#define BOOT_OPT_0_PIN      GPIO_PIN_0
+#define BOOT_OPT_1_PORT     GPIO_PORTA_BASE
+#define BOOT_OPT_1_PIN      GPIO_PIN_1
+
+//*****************************************************************************
+//
+// LPC Channel Definitions
+//
+//*****************************************************************************
+#define PROBE_CHANNEL           0
+#define PROBE_CONFIG            (LPCB_CHAN_SIZE_8)
+#define PROBE_OFFSET            0x0080
+#define PROBE_STATUS            (LPC0_BASE + LPCB_O_CH0ST)
+#define PROBE_EXTENSION         (LPC0_BASE + LPCB_O_CH0EXT)
+#define PROBE_RIS               (LPC0_BASE + LPCB_O_RIS)
+#define PROBE_IC                (LPC0_BASE + LPCB_O_IC)
+#define PROBE_SCRATCH           (LPC0_BASE + LPCB_O_POOL + PROBE_OFFSET + 7)
+
+#define LPC_CHANNEL_A           2
+#define LPC_CHANNEL_B           3
+#define LPC_CHANNEL             (LPC_CHANNEL_B)
+#define LPC_CONFIG              (LPCB_CHAN_SIZE_32 | LPCB_CHAN_MBARB_DISABLED)
+#define LPC_OFFSET              0x0000
+#define LPC_STATUS_A            (LPC0_BASE + LPCB_O_CH2ST)
+#define LPC_STATUS_B            (LPC0_BASE + LPCB_O_CH3ST)
+#define LPC_STATUS              (LPC_STATUS_B)
+#define LPC_BLOCK               (LPC0_BASE + LPCB_O_POOL + LPC_OFFSET)
+#define LPC_TRIGGER_A           (LPC_BLOCK + 31)
+#define LPC_TRIGGER_B           (LPC_BLOCK + 63)
+#define LPC_TRIGGER             (LPC_TRIGGER_B)
+
+#define HOST_WRITE              LPCB_CH0ST_LASTHW
+#define HOST_TX                 LPCB_CH0ST_FRMH
+#define HOST_READ               LPCB_CH0ST_LASTSW
+#define CHANNEL_NR              LPCB_CH0EXT_NR
+#define CHANNEL_DIR             LPCB_CH0EXT_DIR
+#define CHANNEL_DIR_READ        CHANNEL_DIR
+#define CHANNEL_DIR_WRITE       0
+#define CHANNEL_IDX             LPCB_CH0EXT_IDX_M
+#define CHANNEL_IDX_SCRATCH     ((7 << LPCB_CH0EXT_IDX_S) & LPCB_CH0EXT_IDX_M)
+#define CHANNEL_STALL           LPCB_CH0EXT_STALL
+#define RIS_STALL               (3 << LPCB_RIS_CH0INTS_S)
+#define RIS_READ_STALL          (1 << LPCB_RIS_CH0INTS_S)
+#define RIS_WRITE_STALL         (2 << LPCB_RIS_CH0INTS_S)
+#define IC_STALL                (3 << LPCB_IC_CH0INTS_S)
+
+//*****************************************************************************
+//
+// LPC Load Configuration Block
+//
+//*****************************************************************************
+#define LCB_HDR_CMD             0
+#define LCB_HDR_LENGTH          13
+#define LCB_HDR_SUBCMD          1
+#define LCB_HDR_PAD             0xFC
+#define LCB_TRIGGER             1
+#define LCB_PAD                 0x00
+
+//*****************************************************************************
+//
+// LPC Reply Block
+//
+//*****************************************************************************
+#define RB_REPLY_NAK            0
+#define RB_REPLY_ACK            1
+#define RB_REPLY_ACK_QUAL       2
+
+//*****************************************************************************
+//
+// System RAM for Boot Image
+//
+//*****************************************************************************
+#define BOOT_DATA_RAM_START     0x20001000
+#define BOOT_DATA_RAM_RESERVED  0x00001000
+#define BOOT_DATA_RAM_PERSIST   0x00000020
+
+//*****************************************************************************
+//
+// LPC Image Load Protocol
+//
+//*****************************************************************************
+#define BOOT_STATE_RESET        0
+#define BOOT_STATE_INIT         1
+#define BOOT_STATE_DISCOVERY    2
+#define BOOT_STATE_LPC_CONFIG   3
+#define BOOT_STATE_LOAD_HEADER  4
+#define BOOT_STATE_LOAD_FW      5
+#define BOOT_STATE_VERIFY       6
+#define BOOT_STATE_CLEANUP      7
+
+//*****************************************************************************
+//
+// LPC Discovery Phase
+//
+//*****************************************************************************
+#define PROBE_QUERY        0x6A
+#define PROBE_REPLY        0xA6
+
+//*****************************************************************************
+//
+// LPC Configuration Phase
+//
+//*****************************************************************************
+#define LPC_ADDR_MAX       0x3FFFFFC0
+#define LPC_ADDR_ALIGN     0x0000003F
+
+//*****************************************************************************
+//
+// A structure that provides the values needed to access the GPIOs associated
+// with a SSI module.
+//
+//*****************************************************************************
+typedef struct
+{
+    uint32_t ui32PinConfig;
+    uint32_t ui32Base;
+    uint32_t ui32Pin;
+}
+tLPCPin;
+
+//*****************************************************************************
+//
+// The pins used for the LPC interface.
+//
+//*****************************************************************************
+static const tLPCPin g_psLPCPins[] =
+{
+    { LPC_AD0_PINCFG, LPC_AD0_PORT_BASE, LPC_AD0_PORT_PIN },
+    { LPC_AD1_PINCFG, LPC_AD1_PORT_BASE, LPC_AD1_PORT_PIN},
+    { LPC_AD2_PINCFG, LPC_AD2_PORT_BASE, LPC_AD2_PORT_PIN},
+    { LPC_AD3_PINCFG, LPC_AD3_PORT_BASE, LPC_AD3_PORT_PIN},
+    { LPC_CLK_PINCFG, LPC_CLK_PORT_BASE, LPC_CLK_PORT_PIN},
+    { LPC_FRAMEn_PINCFG, LPC_FRAMEn_PORT_BASE, LPC_FRAMEn_PORT_PIN},
+    { LPC_RESETn_PINCFG, LPC_RESETn_PORT_BASE, LPC_RESETn_PORT_PIN},
+    { LPC_SERIRQ_PINCFG, LPC_SERIRQ_PORT_BASE, LPC_SERIRQ_PORT_PIN},
+};
+#define NUM_LPC_PINS (sizeof(g_psLPCPins) / sizeof(g_psLPCPins[0]))
+
+extern void CallApplication(uint32_t);
+
+//*****************************************************************************
+//
+// The system clock speed.
+//
+//*****************************************************************************
+uint32_t g_ui32SysClk;
+
+//*****************************************************************************
+//
+// This is treated as two 128byte buffers to hold data during the image
+// transfer. This allows the boot loader to load data into the first 128 bytes
+// and write data to flash with the other 128 bytes. 128 bytes is the size of
+// the flash controller's write buffer registers.
+//
+//*****************************************************************************
+static uint8_t g_pui8TransferBuf[256];
+
+//*****************************************************************************
+//
+// A variable used for timeout calculation.
+//
+//*****************************************************************************
+static uint32_t g_ui32Timeout;
+
+//*****************************************************************************
+//
+// The Boot Strap Option for the Discovery Phase.
+//
+//*****************************************************************************
+static uint8_t g_ui8BootOpt;
+
+//*****************************************************************************
+//
+// The Mailbox Address mapping for the Boot Strap Option.
+//
+//*****************************************************************************
+//f20 uset 0x2e8, f09 use 0x3f8
+static const uint32_t g_pui32BootOptAddr[4] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
+
+//*****************************************************************************
+//
+// Load configuration block data
+//
+//*****************************************************************************
+static uint32_t g_ui32LoadAddress;
+static uint32_t g_ui32LoadLength;
+static uint32_t g_ui32CRC;
+
+//*****************************************************************************
+//
+// LPC image load protocol (state machine)
+//
+//*****************************************************************************
+static uint32_t g_ui8BootState;
+
+//*****************************************************************************
+//
+// Flag/Counter to keep up with scratch register access for timeout.
+//
+//*****************************************************************************
+static bool g_bScratchAccess;
+static uint32_t g_ui32ScratchTime;
+static uint32_t g_ui32StallTime;
+
+//*****************************************************************************
+//
+// Clear Probe Channel Not Ready indication, with appropriate hard-coded
+// delay
+//
+//*****************************************************************************
+static void
+ProbeClearStall(void)
+{
+    HWREG(PROBE_EXTENSION) |= CHANNEL_NR;
+    g_bScratchAccess = true;
+    g_ui32ScratchTime = HWREG(TIMER0_BASE + TIMER_O_TAR);
+    MAP_SysCtlDelay(12);
+}
+
+//*****************************************************************************
+//
+// Check for Probe Channel stall condition, return "true" if it was stalled,
+// or in a time out condition, false otherwise.
+//
+//*****************************************************************************
+static bool
+ProbeCheckStall(void)
+{
+    if((HWREG(PROBE_EXTENSION) & CHANNEL_NR) != CHANNEL_NR)
+    {
+        if(g_bScratchAccess == false)
+        {
+            return(false);
+        }
+        if((g_ui32ScratchTime - HWREG(TIMER0_BASE + TIMER_O_TAR)) <
+           g_ui32StallTime)
+        {
+            return(false);
+        }
+        HWREG(PROBE_EXTENSION) |= CHANNEL_NR;
+        g_ui32ScratchTime = HWREG(TIMER0_BASE + TIMER_O_TAR);
+    }
+    return(true);
+}
+
+//*****************************************************************************
+//
+// Public function that performs basic verification that the vector table and
+// stack pointer at the start of an image appear reasonable.
+//
+//*****************************************************************************
+uint32_t
+CheckImage(uint32_t ui32Address)
+{
+    uint32_t ui32SP, ui32PC, ui32FlashSize, ui32SRAMSize;
+
+    //
+    // Get the SRAM size.
+    //
+    ui32SRAMSize = ((HWREG(FLASH_SSIZE) & FLASH_SSIZE_SIZE_M) + 1) * 256;
+
+    //
+    // Get the flash size.
+    //
+    ui32FlashSize = HWREG(FLASH_PP) & 0x0000ffff;
+    ui32FlashSize = (ui32FlashSize + 1) * 2 * 1024;
+
+    //
+    // Extract the stack pointer from the vector table.
+    //
+    ui32SP = HWREG(ui32Address);
+
+    //
+    // Ensure that the stack pointer resides within one of the SRAMs and is
+    // four-byte aligned.
+    //
+    if(((ui32SP < 0x20000000)) || (ui32SP > (0x20000000 + ui32SRAMSize)) ||
+       ((ui32SP & 0x00000003) != 0x00000000))
+    {
+        return(IMG_ERR_INVALID_SP);
+    }
+
+    //
+    // Extract the reset vector address from the vector table.
+    //
+    ui32PC = HWREG(ui32Address + 4);
+
+    //
+    // Ensure that the reset vector resides within flash and has its
+    // LSB set (indicating that it is Thumb code).
+    //
+    if((ui32PC >= ui32FlashSize) || ((ui32PC & 0x00000001) != 0x00000001))
+    {
+        return(IMG_ERR_INVALID_PC);
+    }
+
+    //
+    // The vector table passes the simple checks.
+    //
+    return(IMG_ERR_NONE);
+}
+
+//*****************************************************************************
+//
+// Generate a Reply Block
+//
+//*****************************************************************************
+static void
+GenerateReplyBlock(uint8_t ui8Reply, uint8_t ui8Trigger)
+{
+    //
+    // Set the reply byte.
+    //
+    HWREGB(LPC_BLOCK) = ui8Reply;
+
+    //
+    // Echo the trigger current trigger byte from the host, which
+    // will also set the reply-ready bit in the channel status register.
+    //
+    HWREGB(LPC_TRIGGER) = ui8Trigger;
+
+    //
+    // Wait a reasonable time for host to read it.
+    //
+    g_ui32Timeout = g_ui32SysClk / 10;
+    while(HWREG(LPC_STATUS_B) & HOST_READ)
+    {
+            if(!g_ui32Timeout--)
+            {
+                break;
+            }
+    }
+
+}
+
+//*****************************************************************************
+//
+// Phase 1 - Initialization
+//
+//*****************************************************************************
+int32_t
+BootInit(void)
+{
+    uint32_t ui32Idx;
+
+
+    //
+    // Set the clocking as configured.
+    //
+    //Jerry150525 the MAP_SysCtlClockFreqSet will cause system hang,so access the register directly
+    MAP_SysCtlMOSCConfigSet(SYSCTL_MOSC_HIGHFREQ);
+    g_ui32SysClk = MAP_SysCtlClockFreqSet(LPCBOOT_SYSCTL_CLOCK,
+                                          LPCBOOT_CLOCK_HZ);
+
+    //
+    // Force Reset Behaviour Control to be POR for all resets.
+    //
+    //HWREG(SYSCTL_RESBEHAVCTL) = 0xffffffff;
+
+    //
+    // Enable all GPIO modules.
+    //
+    HWREG(SYSCTL_RCGCGPIO) = 0xffffffff;
+
+    //
+    // Enable the LPC module.
+    //
+#if 1    //remove for f09 lpc-uart.because it has been define in the runtime code
+   MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_LPC0);
+   ///MAP_SysCtlPeripheralReset(SYSCTL_PERIPH_LPC0);
+#endif
+
+    //
+    // Enable the TIMER0 module.
+    //
+    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0);
+
+#ifdef LPC_BOOT_PIN_STRAP
+    //
+    // Configure the Boot Option Pin-Strap signals.
+    //
+    MAP_GPIODirModeSet(BOOT_OPT_0_PORT, BOOT_OPT_0_PIN, GPIO_DIR_MODE_IN);
+    MAP_GPIODirModeSet(BOOT_OPT_1_PORT, BOOT_OPT_1_PIN, GPIO_DIR_MODE_IN);
+    MAP_GPIOPadConfigSet(BOOT_OPT_0_PORT, BOOT_OPT_0_PIN, GPIO_STRENGTH_2MA,
+                         GPIO_PIN_TYPE_STD_WPU);
+    MAP_GPIOPadConfigSet(BOOT_OPT_1_PORT, BOOT_OPT_1_PIN, GPIO_STRENGTH_2MA,
+                         GPIO_PIN_TYPE_STD_WPU);
+
+    //
+    // Delay for at least 10 uSecs.
+    //
+    MAP_SysCtlDelay(((g_ui32SysClk / 1000000) * 10) / 3);
+
+    //
+    // Read and swap the Boot Option signals.
+    //
+    g_ui8BootOpt = MAP_GPIOPinRead(BOOT_OPT_0_PORT, BOOT_OPT_0_PIN) ? 1 : 0;
+    g_ui8BootOpt |= MAP_GPIOPinRead(BOOT_OPT_1_PORT, BOOT_OPT_1_PIN) ? 2 : 0;
+#else
+
+    //
+    // g_ui8BootOpt: 0->0x3f8, 1->0x2f8, 2->0x3e8, 3->0x2e8
+    //
+    g_ui8BootOpt = 0;
+#endif
+
+
+    //
+    // Enable the LPC pins needed for the LPC Boot Loader.
+    //
+#if 1   //remove for f09 lpc-uart.because it has been define in the runtime code
+    for(ui32Idx = 0; ui32Idx < NUM_LPC_PINS; ui32Idx++)
+    {
+        //
+        // Configure this LPC pin.
+        //
+        MAP_GPIOPinConfigure(g_psLPCPins[ui32Idx].ui32PinConfig);
+        MAP_GPIOPadConfigSet(g_psLPCPins[ui32Idx].ui32Base,
+                             g_psLPCPins[ui32Idx].ui32Pin, GPIO_STRENGTH_4MA,
+                             GPIO_PIN_TYPE_STD);
+        MAP_GPIODirModeSet(g_psLPCPins[ui32Idx].ui32Base,
+                           g_psLPCPins[ui32Idx].ui32Pin, GPIO_DIR_MODE_HW);
+    }
+#endif
+    //
+    // Configure the LPC peripheral to ignore the Power Down pin.
+    //
+    HWREG(LPC0_BASE + LPCB_O_CTL) |= LPCB_CTL_NOPD;
+
+    //
+    // Configure/Enable Channel 0 for the Discovery phase.
+    //
+    MAP_LPCBChannelConfigMBSet(LPC0_BASE,
+                               PROBE_CHANNEL,
+                               PROBE_CONFIG,
+                               g_pui32BootOptAddr[g_ui8BootOpt],
+                               PROBE_OFFSET);
+    MAP_LPCBChannelEnable(LPC0_BASE, PROBE_CHANNEL);
+    HWREG(PROBE_IC) = 0xFFFFFFFF;
+    HWREG(PROBE_EXTENSION) |= CHANNEL_STALL;
+
+#ifdef OEM_HOOK
+    extern void OEM_HOOK_BootInit(void);
+    OEM_HOOK_BootInit();
+#endif
+
+    //
+    // Configure TIMER0 as a free-running, 32-bit timer.
+    //
+    MAP_TimerConfigure(TIMER0_BASE, TIMER_CFG_PERIODIC);
+    MAP_TimerEnable(TIMER0_BASE, TIMER_A);
+    g_bScratchAccess = false;
+    g_ui32ScratchTime = 0;
+    g_ui32StallTime = (g_ui32SysClk / 50);
+
+
+    //
+    // Initialization is complete.
+    //
+    return(RC_OK);
+}
+
+//*****************************************************************************
+//
+// Phase 2 - Discovery
+//
+//*****************************************************************************
+static int32_t
+BootDiscovery(void)
+{
+    uint32_t ui32Extension;
+    int count;
+
+    //
+    // If nothing has been written to the PROBE channel scratch register,
+    // just return
+    //
+    if(!ProbeCheckStall())
+    {
+        return(RC_OK);
+    }
+    ui32Extension = HWREG(PROBE_EXTENSION);
+
+    //
+    // An access has occurred, but not the one we are interested in, simply
+    // clear the NR status and return.
+    //
+    if(((ui32Extension & CHANNEL_DIR) != CHANNEL_DIR_WRITE) ||
+       ((ui32Extension & CHANNEL_IDX) != CHANNEL_IDX_SCRATCH))
+    {
+        ProbeClearStall();
+        return(RC_OK);
+    }
+
+    //
+    // If the data written to the scratch pad memory was NOT a probe request,
+    // just return.
+    //
+    if(HWREGB(PROBE_SCRATCH) != PROBE_QUERY)
+    {
+        ProbeClearStall();
+        return(RC_OK);
+    }
+
+    //
+    // Here, we have a valid probe query, so write the probe response, and
+    // wait for the host to read it.
+    //
+    HWREGB(PROBE_SCRATCH) = PROBE_REPLY;
+    ProbeClearStall();
+
+    //
+    // Wait for the host to read the reply that we have provided.
+    //
+    count = 1000;
+    while(true)
+    {
+    	if(!ProbeCheckStall())
+        {
+            continue;
+        }
+        ui32Extension = HWREG(PROBE_EXTENSION);
+        if(((ui32Extension & CHANNEL_DIR) == CHANNEL_DIR_READ) &&
+           ((ui32Extension & CHANNEL_IDX) == CHANNEL_IDX_SCRATCH))
+        {
+        	ProbeClearStall();
+            break;
+        }
+        if(!count--)
+        {
+            DPRINTF(("dis-con-timeout\n"));
+            ProbeClearStall();
+            return(RC_TIMEOUT);
+        }
+        ProbeClearStall();
+    }
+    //ProbeClearStall();
+  
+    //
+    // Probe was not detected.
+    //
+    return(RC_PROBE_DETECT);
+}
+
+//*****************************************************************************
+//
+// Phase 3 - LPC Configuration
+//
+//*****************************************************************************
+static int32_t
+BootLPCConfiguration(void)
+{
+    uint32_t ui32Address, ui32Extension;
+    uint8_t *pui8Address = (uint8_t *)&ui32Address;
+    int32_t i32ErrorCode;
+    uint8_t ui8ReplyCode;
+    int iIndex, count;
+
+    for(iIndex = 0; iIndex < 4; iIndex++)
+    {
+    	count = 1000;
+
+    	
+    	while(true)
+        {
+    		if(!ProbeCheckStall())
+            {
+    			continue;
+            }
+
+    		ui32Extension = HWREG(PROBE_EXTENSION);
+            if(((ui32Extension & CHANNEL_DIR) == CHANNEL_DIR_WRITE) &&
+               ((ui32Extension & CHANNEL_IDX) == CHANNEL_IDX_SCRATCH))
+            {
+                pui8Address[iIndex] = HWREGB(PROBE_SCRATCH);
+
+                ProbeClearStall();
+                ui8ReplyCode = 0x24;   //Host utility will check this reply code to send the next byte
+                HWREGB(PROBE_SCRATCH) = ui8ReplyCode;
+
+                while(true)
+                {
+                	
+                	if(!ProbeCheckStall())
+                    {
+                        continue;
+                    }
+                	ui32Extension = HWREG(PROBE_EXTENSION);
+                    if(((ui32Extension & CHANNEL_DIR) == CHANNEL_DIR_READ) &&
+                           ((ui32Extension & CHANNEL_IDX) == CHANNEL_IDX_SCRATCH))
+                    {
+                    	
+                        ProbeClearStall();
+                        break;
+                    }
+                    ProbeClearStall();
+                }
+
+
+                
+                break;
+            }
+
+            
+            //ProbeClearStall();
+
+            if(!count--)
+            {
+            	ui8ReplyCode = 0x31;   //Add the timeout that host utility will check this reply code to restart the configure
+            	DPRINTF(("config-timeout\n"));
+            	HWREGB(PROBE_SCRATCH) = ui8ReplyCode;
+            	ProbeClearStall();
+            	return(RC_TIMEOUT);
+            }
+
+        }
+    }
+    
+    //
+    // Initialize the return status and check the address.
+    //
+    if(ui32Address > LPC_ADDR_MAX)
+    {
+        ui8ReplyCode = 0x22;
+        i32ErrorCode = RC_ERR_BAD_ADDRESS;
+    }
+    else if(ui32Address & LPC_ADDR_ALIGN)
+    {
+        ui8ReplyCode = 0x23;
+        i32ErrorCode = RC_ERR_BAD_ALIGNMENT;
+    }
+    else
+    {
+        i32ErrorCode = RC_OK;
+        ui8ReplyCode = 0x21;
+
+        //
+        // Configure the two LPC channels for the LPC Boot Loader Protocol
+        //
+        //DPRINTF(("con addr = %x %x %x %x %x\n",ui32Address,LPC0_BASE,LPC_CONFIG,LPC_OFFSET,LPC_CHANNEL_A));
+        MAP_LPCBChannelConfigMBSet(LPC0_BASE,
+                                   LPC_CHANNEL_A,
+                                   LPC_CONFIG,
+                                   ui32Address,
+                                   LPC_OFFSET);
+        MAP_LPCBChannelConfigMBSet(LPC0_BASE,
+                                   LPC_CHANNEL_B,
+                                   LPC_CONFIG,
+                                   ui32Address + 32,
+                                   LPC_OFFSET + 32);
+
+        //
+        // Configure the LPC Status Block to reside in memory immediately
+        // after these two channels.
+        //
+        MAP_LPCBStatusBlockAddressSet(LPC0_BASE, ui32Address + 64, true);
+
+        //
+        // Enable the channels.
+        //
+        MAP_LPCBChannelEnable(LPC0_BASE, LPC_CHANNEL_A);
+        MAP_LPCBChannelEnable(LPC0_BASE, LPC_CHANNEL_B);
+    }
+
+    //
+    // Wait for the host to read the reply that we have provided.
+    //
+    HWREGB(PROBE_SCRATCH) = ui8ReplyCode;
+    ProbeClearStall();
+    count = 1000;
+    while(true)
+    {
+    	if(!ProbeCheckStall())
+        {
+            continue;
+        }
+
+        ui32Extension = HWREG(PROBE_EXTENSION);
+        if(((ui32Extension & CHANNEL_DIR) == CHANNEL_DIR_READ) &&
+           ((ui32Extension & CHANNEL_IDX) == CHANNEL_IDX_SCRATCH))
+        {
+            ProbeClearStall();
+            break;
+        }
+        ProbeClearStall();
+       
+
+        if(!count--)
+        {
+        	ui8ReplyCode = 0x31;   //Add the timeout that host utility will check this reply code to restart the configure
+        	DPRINTF(("!!config-timeout!!\n"));
+        	HWREGB(PROBE_SCRATCH) = ui8ReplyCode;
+        	ProbeClearStall();
+        	return(RC_TIMEOUT);
+        }
+
+    }
+   
+
+    //
+    // Return the status of this operation.
+    //
+    return(i32ErrorCode);
+}
+
+//*****************************************************************************
+//
+// Phase 4 - Load header data
+//
+//*****************************************************************************
+static int32_t
+BootLoadHeader(void)
+{
+    uint32_t ui32FlashSize;
+    uint8_t ui8Cmd, ui8Len, ui8SubCmd, ui8Pad, ui8Trigger;
+   
+
+    //
+    // At this point, the boot loader should be finished with access the
+    // COMx port for Probe/Query/Config, so clear the flag that would cause
+    // the timer to trigger.
+    //
+    g_bScratchAccess = false;
+
+    //
+    // Wait for the trigger byte to be written at the end of the LPC block.
+    //
+    g_ui32Timeout = g_ui32SysClk / 32;
+    
+
+    while(!(HWREG(LPC_STATUS) & HOST_WRITE))
+    {
+        if(!g_ui32Timeout--)
+        {
+            return(RC_TIMEOUT);     
+        }
+        if(BootDiscovery() == RC_PROBE_DETECT)
+        {
+            return(RC_PROBE_DETECT);
+        }
+    }
+     
+	 
+    //
+    // Read LPC channel data.
+    //
+    ui8Cmd = HWREGB(LPC_BLOCK + 0);
+    ui8Len = HWREGB(LPC_BLOCK + 1);
+    ui8SubCmd = HWREGB(LPC_BLOCK + 2);
+    ui8Pad = HWREGB(LPC_BLOCK + 3);
+    g_ui32LoadAddress = HWREG(LPC_BLOCK + 4);
+    g_ui32LoadLength = HWREG(LPC_BLOCK + 8);
+    g_ui32CRC = HWREG(LPC_BLOCK + 12);
+    ui8Trigger = HWREGB(LPC_TRIGGER_A);
+    ui8Trigger = HWREGB(LPC_TRIGGER);
+    //DPRINTF(("######### %x,%x,%x,%x,%x,%x,%x,%x,%x\n",ui8Cmd,ui8Len,ui8SubCmd,ui8Pad,g_ui32LoadAddress,g_ui32LoadLength,g_ui32CRC,ui8Trigger,ui8Trigger));
+    //
+    // Verify the LCB header content.
+    //
+    if(LCB_HDR_CMD != ui8Cmd)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_CMD);
+        return(RC_ERR_BAD_CMD);
+    }
+    if(LCB_HDR_LENGTH != ui8Len)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_LENGTH);
+        return(RC_ERR_BAD_LENGTH);
+    }
+    if(LCB_HDR_SUBCMD != ui8SubCmd)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_SUBCMD);
+        return(RC_ERR_BAD_SUBCMD);
+    }
+    if(LCB_HDR_PAD != ui8Pad)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_PAD);
+        return(RC_ERR_BAD_PAD);
+    }
+    if(LCB_TRIGGER != ui8Trigger)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_TRIGGER);
+        return(RC_ERR_BAD_TRIGGER);
+    }
+
+    //
+    // Verify Image load address matches the APP_START_ADDRESS configuration.
+    //
+    if(g_ui32LoadAddress != APP_START_ADDRESS)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_ADDRESS);
+        return(RC_ERR_BAD_ADDRESS);
+    }
+
+    //
+    // Verify Image Load Address is 1K aligned.
+    //
+    if(g_ui32LoadAddress & 0x3FF)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_ALIGNMENT);
+        return(RC_ERR_BAD_ALIGNMENT);
+    }
+
+    //
+    // Verify image size is 64-byte padded.
+    //
+    if(g_ui32LoadLength & 63)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_SIZE);
+        return(RC_ERR_BAD_SIZE);
+    }
+
+    //
+    // Verify image will fit in flash. Retrieve the size setting and convert it
+    // into a comparable value.
+    //
+    ui32FlashSize = HWREG(FLASH_PP) & 0x0000ffff;
+    ui32FlashSize = (ui32FlashSize + 1) * 2 * 1024;
+    if((g_ui32LoadAddress + g_ui32LoadLength) > ui32FlashSize)
+    {
+        GenerateReplyBlock(RB_REPLY_ACK_QUAL, RC_ERR_BAD_ADDRESS);
+        return(RC_ERR_BAD_ADDRESS);
+    }
+
+    //
+    // We only leave the processing loop if the block has been validated.
+    //
+    GenerateReplyBlock(RB_REPLY_ACK, ui8Trigger);
+    return(RC_OK);
+}
+
+//*****************************************************************************
+//
+// Write a block of data to flash. If any previous writes are still pending,
+// this will block and enable the LPC mailbox channel's stall submode.
+// This will return the updated address.
+//
+// This function is a subset of DriverLib's FlashProgram function (with
+// inverted blocking).
+//
+//*****************************************************************************
+static uint32_t
+BootFlashWriteBlock(uint32_t *pui32Data, uint32_t ui32Address,
+                    uint32_t ui32Bytes)
+{
+    //
+    // Limit to the controller size and make certain there's data.
+    //
+    if((ui32Bytes > 128) || (ui32Bytes == 0))
+    {
+        return(ui32Address);
+    }
+
+    //
+    // Wait for any previous writes to complete.
+    //
+    while(HWREG(FLASH_FMC2) & FLASH_FMC2_WRBUF)
+    {
+    }
+
+    HWREG(FLASH_FCMISC) = (FLASH_FCMISC_AMISC | FLASH_FCMISC_VOLTMISC |
+                           FLASH_FCMISC_INVDMISC |
+                           FLASH_FCMISC_PROGMISC);
+    //
+    // Set the address of this block of words.
+    //
+    HWREG(FLASH_FMA) = ui32Address & ~(0x7f);
+
+    //
+    // Loop over the words in this 32-word block.
+    //
+    while(ui32Bytes != 0)
+    {
+        //
+        // Write this word into the write buffer.
+        //
+        HWREG(FLASH_FWBN + (ui32Address & 0x7c)) = *pui32Data++;
+        ui32Address += 4;
+        ui32Bytes -= 4;
+    }
+
+    //
+    // Program the contents of the write buffer into flash.
+    //
+    HWREG(FLASH_FMC2) = FLASH_FMC2_WRKEY | FLASH_FMC2_WRBUF;
+
+    //
+    // Return the updated address.
+    //
+    return(ui32Address);
+}
+
+//*****************************************************************************
+//
+// Phase 5 - Load firmware
+//
+//*****************************************************************************
+static int32_t
+BootLoadFirmware(void)
+{
+    uint32_t ui32Target, *pui32Dst, *pui32Src, *pui32CRC;
+    volatile uint32_t ui32TempCRC, ui32Count;
+    int32_t i32RetCode;
+    bool bCleanFlash;
+
+    //
+    // Init to the common case.
+    //
+    ui32Count = g_ui32LoadLength;
+    ui32Target = g_ui32LoadAddress;
+    bCleanFlash = false;
+    i32RetCode = RC_OK;
+
+    //
+    // Erase the blocks, top-to-bottom.
+    //
+    while(ui32Count)
+    {
+    	MAP_FlashErase(ui32Target + ui32Count);
+        if(ui32Count > FLASH_PAGE_SIZE)
+        {
+            ui32Count -= FLASH_PAGE_SIZE;
+        }
+        else
+        {
+        	MAP_FlashErase(ui32Target);		//Jerry150612 erase 0ffset 0x8000~0xC000 page
+        	ui32Count = 0;
+        }
+    }
+
+    //
+    // Setup the initial destination address and counters for the actual
+    // transfer.
+    //
+    pui32Dst = (uint32_t *)g_pui8TransferBuf;
+    ui32Count = g_ui32LoadLength;
+    ui32TempCRC = 0xFFFFFFFF;
+
+    while(ui32Count >= 64)
+    {
+        //
+        // Reset the pointer to the beginning of the buffer pool.
+        //
+        pui32Src = (uint32_t *)LPC_BLOCK;
+
+        //
+        // Wait for the first-half of the data to be ready (32 bytes)
+        //
+        g_ui32Timeout = g_ui32SysClk / 10;
+        while(!(HWREG(LPC_STATUS_A) & HOST_WRITE))
+        {
+            if(!g_ui32Timeout--)
+            {
+                i32RetCode = RC_TIMEOUT;
+                bCleanFlash = true;
+                break;
+            }
+            if(BootDiscovery() == RC_PROBE_DETECT)
+            {
+                i32RetCode = RC_PROBE_DETECT;
+                bCleanFlash = true;
+                break;
+            }
+        }
+
+        //
+        // If timeout or probe detect, break from loop.
+        //
+        if(i32RetCode != RC_OK)
+        {
+            break;
+        }
+
+        //
+        // Here, we have 32 bytes (8 words).  Unroll this loop and transfer
+        // them as quickly as possible (in C).
+        //
+        pui32CRC = pui32Dst;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+
+        //
+        // Wait for the second-half of the data to be ready (32 bytes)
+        //
+        g_ui32Timeout = g_ui32SysClk / 10;
+        while(!(HWREG(LPC_STATUS_B) & HOST_WRITE))
+        {
+            if(!g_ui32Timeout--)
+            {
+                i32RetCode = RC_TIMEOUT;
+                bCleanFlash = true;
+                break;
+            }
+            if(BootDiscovery() == RC_PROBE_DETECT)
+            {
+                i32RetCode = RC_PROBE_DETECT;
+                bCleanFlash = true;
+                break;
+            }
+        }
+
+        //
+        // Here, we have 32 bytes (8 words).  Unroll this loop and transfer
+        // them as quickly as possible (in C).
+        //
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst++ = *pui32Src++;
+        *pui32Dst = *pui32Src++;
+
+        //
+        // Decrement the load byte counter by 64 bytes;
+        //
+        ui32Count -= 64;
+
+        //
+        // Keep a running CRC for this data
+        //
+        ui32TempCRC = Crc32(ui32TempCRC, (unsigned char *)pui32CRC, 64);
+
+        //
+        // Check the buffer position.
+        //
+        if(pui32Dst == (uint32_t *)&g_pui8TransferBuf[124])
+        {
+            //
+            // Write the buffered 128 bytes to flash.
+            //
+            ui32Target = BootFlashWriteBlock((uint32_t *)&g_pui8TransferBuf[0],
+                                             ui32Target, 128);
+            //
+            // Advance the destination pointer.
+            //
+            pui32Dst = (uint32_t *)&g_pui8TransferBuf[128];
+
+        }
+        else if(pui32Dst == (uint32_t *)&g_pui8TransferBuf[252])
+        {
+            //
+            // Write the buffered 128 bytes to flash if previous writes
+            // have completed. Stall the LPC if flash is not ready.
+            //
+            ui32Target = 
+                       BootFlashWriteBlock((uint32_t *)&g_pui8TransferBuf[128],
+                                           ui32Target, 128);
+
+            //
+            // Reset the destination pointer.
+            //
+            pui32Dst = (uint32_t *)&g_pui8TransferBuf[0];
+        }
+        else if(ui32Count == 0)
+        {
+            //
+            // Image might not be 128byte padded. The pui32CRC pointer
+            // will have the buffer position saved.
+            //
+            ui32Target = BootFlashWriteBlock(pui32CRC, ui32Target, 64);
+        }
+        else
+        {
+            //
+            // Advance the destination pointer.
+            //
+            pui32Dst++;
+        }
+
+        //
+        // Notify the host we got the 64 bytes and are ready for more.
+        // Make sure the slave read was acknowledged in the status register.
+        //
+        g_ui32Timeout = g_ui32SysClk / 10;
+        while((HWREG(LPC_STATUS_B) & (HOST_WRITE | HOST_TX)))
+        {
+            if(!g_ui32Timeout--)
+            {
+                i32RetCode = RC_TIMEOUT;
+                bCleanFlash = true;
+                break;
+            }
+            if(BootDiscovery() == RC_PROBE_DETECT)
+            {
+                i32RetCode = RC_PROBE_DETECT;
+                bCleanFlash = true;
+                break;
+            }
+        }
+        GenerateReplyBlock(RB_REPLY_ACK, 1);
+    }
+
+    //
+    // If there is remaining data, something is wrong.
+    //
+    if((ui32Count) && (i32RetCode == RC_OK))
+    {
+        //
+        // Should have been 64byte aligned.
+        //
+        i32RetCode = RC_ERR_BAD_LENGTH;
+        bCleanFlash = true;
+    }
+
+    //
+    // Check CRC results.
+    //
+    if((g_ui32CRC != ui32TempCRC) && (i32RetCode == RC_OK))
+    {
+        i32RetCode = RC_ERR_BAD_CRC;
+        bCleanFlash = true;
+    }
+
+    if(bCleanFlash == true)
+    {
+        //
+        // Erase the application area of flash.
+        //
+        ui32Count = g_ui32LoadLength;
+
+        //
+        // Erase the blocks, top-to-bottom.
+        //
+        while(ui32Count)
+        {
+            MAP_FlashErase(g_ui32LoadAddress + ui32Count);
+            if(ui32Count > FLASH_PAGE_SIZE)
+            {
+                ui32Count -= FLASH_PAGE_SIZE;
+            }
+            else
+            {
+            	MAP_FlashErase(g_ui32LoadAddress);		//Jerry150612 erase 0ffset 0x8000~0xC000 page
+            	ui32Count = 0;
+            }
+        }
+    }
+
+    //
+    // Return results.
+    //
+    return(i32RetCode);
+}
+
+//*****************************************************************************
+//
+// Phase 6 - Verify
+// Use CheckImage() to validate stack pointer and vector table address.
+//
+//*****************************************************************************
+static int32_t
+BootVerify(void)
+{
+    uint32_t ui32RetVal, ui32Count;
+    uint8_t ui8Trigger;
+
+    //
+    // Check the image, to see if it passes some basic sanity tests
+    //
+    ui32RetVal = CheckImage(g_ui32LoadAddress);
+
+    //
+    // Retrieve trigger.
+    //
+    ui8Trigger = HWREGB(LPC_TRIGGER);
+
+    if(ui32RetVal != RC_OK)
+    {
+        //
+        // Erase the application area of flash.
+        //
+        ui32Count = g_ui32LoadLength;
+
+        //
+        // Erase the blocks, top-to-bottom.
+        //
+        while(ui32Count)
+        {
+            MAP_FlashErase(g_ui32LoadAddress + ui32Count);
+            if(ui32Count > FLASH_PAGE_SIZE)
+            {
+                ui32Count -= FLASH_PAGE_SIZE;
+            }
+            else
+            {
+            	MAP_FlashErase(g_ui32LoadAddress);		//Jerry150612 erase 0ffset 0x8000~0xC000 page
+            	ui32Count = 0;
+            }
+        }
+        GenerateReplyBlock(RB_REPLY_NAK, ui8Trigger);
+        return(RC_ERR_BAD_IMAGE);
+    }
+
+    //
+    // No problems detected.
+    //
+    GenerateReplyBlock(RB_REPLY_ACK, ui8Trigger);
+    return(RC_OK);
+}
+
+//*****************************************************************************
+//
+// Phase 7 - Clean up and reset.
+// This function expects to be run from SRAM.
+//
+//*****************************************************************************
+static int32_t
+BootCleanup(void)
+{
+
+    //
+    // If image new image appears to be valid branch to the application
+    //
+   
+    if (CheckImage(APP_START_ADDRESS) == 0)
+    {
+        //
+        // Branch to the application
+        //
+    	//Jerry130820 Clear the update flag before boot into runtime
+    	//uint32_t ui32delData;
+    	
+    	//EEPROMRead(&ui32delData,EEPROM_ADDR_UPDATE,0x04);  //Jerry130913 need use EEPROM instead ROM_EEPROM ????
+    	//bit[0:7]:0x00 clear LPC update flag, bit[8:15]:0x00 clear the tftp update fail reason code, bit[25:31]:0x01 LPC update success 
+    	//ui32delData = (ui32delData & 0x0000FFFF) | 0x01<<24;
+    	//EEPROMProgram(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+    	
+//    	ui32delData = HWREG(FLASH_ADDR_UPDATE);
+//    	FlashErase(FLASH_ADDR_UPDATE);
+//    	ui32delData = (ui32delData & 0x0000FF00) | 0x01<<24;
+//    	FlashProgram(&ui32delData, FLASH_ADDR_UPDATE, 4);
+      MAP_LPCBChannelDisable(LPC0_BASE, PROBE_CHANNEL);
+      CallApplication(APP_START_ADDRESS);
+
+    }
+
+    //
+    // If the application is not valid reset and try again
+    //
+    else
+    {
+        //
+        // Reset and disable the peripherals used by the boot loader.
+        //
+#if 0    //keep lpc-uart connect, it can not disable the peripherals
+        HWREG(SYSCTL_SRGPIO) = ~(SYSCTL_SRGPIO_R2 | SYSCTL_SRGPIO_R7);
+        HWREG(SYSCTL_SRGPIO) = 0;
+        HWREG(SYSCTL_RCGCGPIO) &= (SYSCTL_SRGPIO_R2 | SYSCTL_SRGPIO_R7);
+        HWREG(SYSCTL_SRTIMER) = 0xffffffff;
+        HWREG(SYSCTL_SRTIMER) = 0;
+        HWREG(SYSCTL_RCGCTIMER) = 0;
+
+        //
+        // Switch back to running from PIOSC if currently running from the PLL.
+        //
+        if(g_ui32SysClk != 16000000)
+        {
+            MAP_SysCtlClockFreqSet(SYSCTL_OSC_INT | SYSCTL_USE_OSC, 0);
+        }
+#endif
+        //
+        // Reset the processor; the image will be re-checked and launched as a part
+        // of normal startup.
+        //
+        //HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ;
+
+        //only do the core reset , doesn't reset the peripherals
+        HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+
+    }
+    //
+    // This statement is never reached; avoiding a compiler warning.
+    //
+    return(RC_ERR_BAD_IMAGE);
+}
+
+//*****************************************************************************
+//
+// The entry point for the LPC boot loader.  This will attempt to boot from the
+// LPC interface.  If this fails, the boot loader will hang in an infinite
+// loop, as there is no error indication provided.
+//
+//*****************************************************************************
+void
+entry(void)
+{
+    uint8_t ui8NewState = BOOT_STATE_INIT;
+    int32_t i32RetCode = RC_OK;
+    int32_t dis_count = 0;
+
+    //
+    // Enter the LPC Boot Loader State Machine.
+    //
+    while(true)
+    {
+        //
+        // If boot state is changing, update the global state variable.
+        //
+        if(g_ui8BootState != ui8NewState)
+        {
+            g_ui8BootState = ui8NewState;
+        }
+
+        //
+        // Run the boot process for the current boot state.
+        //
+        switch(g_ui8BootState)
+        {
+            //
+            // Initialization phase
+            //
+            case BOOT_STATE_INIT:
+            {
+            	i32RetCode = BootInit();
+                if(RC_OK == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_DISCOVERY;
+                }
+                break;
+            }
+
+            //
+            // Discovery phase
+            //
+            case BOOT_STATE_DISCOVERY:
+            {
+            	dis_count++;
+            	
+            	i32RetCode = BootDiscovery();
+            	//set the timeout for jump to runtime
+            	if(dis_count > 20000000)
+            	{
+            		dis_count = 0;
+            		DPRINTF(("Timeout jump to runtime\n"));
+            		MAP_LPCBChannelDisable(LPC0_BASE, PROBE_CHANNEL);
+            		CallApplication(APP_START_ADDRESS);
+            	}
+                if(RC_PROBE_DETECT == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_LPC_CONFIG;
+                }
+                break;
+            }
+
+            //
+            // LPC configuration phase
+            //
+            case BOOT_STATE_LPC_CONFIG:
+            {
+                i32RetCode = BootLPCConfiguration();
+                if(RC_OK == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_LOAD_HEADER;
+                }
+                else
+                {
+                	DPRINTF(("re-dis %d\n",i32RetCode));
+                	ui8NewState = BOOT_STATE_DISCOVERY;
+                }
+                break;
+            }
+
+            //
+            // Load configuration phase
+            //
+            case BOOT_STATE_LOAD_HEADER:
+            {
+                i32RetCode = BootLoadHeader();
+                if(RC_OK == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_LOAD_FW;
+                }
+                else if(RC_PROBE_DETECT == i32RetCode)
+                {
+                	DPRINTF(("re-con %d\n",i32RetCode));
+                	ui8NewState = BOOT_STATE_LPC_CONFIG;
+                }
+                break;
+            }
+
+            //
+            // Load firmware phase
+            //
+            case BOOT_STATE_LOAD_FW:
+            {
+                i32RetCode = BootLoadFirmware();
+                if(RC_OK == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_VERIFY;
+                }
+                else if(RC_PROBE_DETECT == i32RetCode)
+                {
+                	DPRINTF(("re-con!\n"));
+                	ui8NewState = BOOT_STATE_LPC_CONFIG;
+                }
+                else
+                {
+                	DPRINTF(("re-init!\n"));
+                	ui8NewState = BOOT_STATE_INIT;
+                }
+                break;
+            }
+
+            //
+            // Authentication phase
+            //
+            case BOOT_STATE_VERIFY:
+            {
+                i32RetCode = BootVerify();
+                if(RC_OK == i32RetCode)
+                {
+                    ui8NewState = BOOT_STATE_CLEANUP;
+                }
+                else if(RC_PROBE_DETECT == i32RetCode)
+                {
+                	DPRINTF(("re-con!!\n"));
+                	ui8NewState = BOOT_STATE_LPC_CONFIG;
+                }
+                else
+                {
+                	DPRINTF(("re-hed!!\n"));
+                	ui8NewState = BOOT_STATE_LOAD_HEADER;
+                }
+
+                break;
+            }
+
+            //
+            // Firmware cleanup phase.
+            // System will be reset.
+            //
+            case BOOT_STATE_CLEANUP:
+            {
+                BootCleanup();
+                break;
+            }
+
+            //
+            // Unknown State - Revert to the init state.
+            //
+            default:
+            {
+                ui8NewState = BOOT_STATE_INIT;
+                break;
+            }
+        }
+    }
+}
diff --unidirectional-new-file -ru f09_tmp/.ccsproject f09_bootloader_202/.ccsproject
--- f09_tmp/.ccsproject	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/.ccsproject	2017-08-23 13:37:40.987000000 +0800
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<?ccsproject version="1.0"?>
+<projectOptions>
+	<deviceVariant value="Cortex M.LM4FB15P9ZAD"/>
+	<deviceFamily value="TMS470"/>
+	<deviceEndianness value="little"/>
+	<codegenToolVersion value="5.0.3"/>
+	<isElfFormat value="true"/>
+	<connection value="common/targetdb/connections/Stellaris_ICDI_Connection.xml"/>
+	<rts value="libc.a"/>
+	<isTargetManual value="false"/>
+</projectOptions>
diff --unidirectional-new-file -ru f09_tmp/.cproject f09_bootloader_202/.cproject
--- f09_tmp/.cproject	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/.cproject	2017-08-23 13:42:23.828000000 +0800
@@ -0,0 +1,201 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<?fileVersion 4.0.0?>
+
+<cproject storage_type_id="org.eclipse.cdt.core.XmlProjectDescriptionStorage">
+	<storageModule configRelations="2" moduleId="org.eclipse.cdt.core.settings">
+		<cconfiguration id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.215937359">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.215937359" moduleId="org.eclipse.cdt.core.settings" name="Debug">
+				<macros>
+					<stringMacro name="ORIGINAL_PROJECT_ROOT" type="VALUE_PATH_DIR" value="C:/SDK/SMC/DK_SMC_1235/boards/dk-smc-lm4fb1/sample_eth_lpc_boot/ccs"/>
+					<stringMacro name="SW_ROOT" type="VALUE_PATH_DIR" value="${ORIGINAL_PROJECT_ROOT}/../../../.."/>
+				</macros>
+				<externalSettings/>
+				<extensions>
+					<extension id="com.ti.ccstudio.binaryparser.CoffParser" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="com.ti.ccstudio.errorparser.CoffErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.LinkErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.AsmErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="out" artifactName="${ProjName}" buildProperties="" cleanCommand="${CG_CLEAN_CMD}" description="" id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.215937359" name="Debug" parent="com.ti.ccstudio.buildDefinitions.TMS470.Debug" postbuildStep="&quot;${CCE_INSTALL_ROOT}/utils/tiobj2bin/tiobj2bin&quot; &quot;${BuildArtifactFileName}&quot; &quot;${BuildArtifactFileBaseName}.bin&quot; &quot;${CG_TOOL_ROOT}/bin/armofd&quot; &quot;${CG_TOOL_ROOT}/bin/armhex&quot; &quot;${CCE_INSTALL_ROOT}/utils/tiobj2bin/mkhex4bin&quot;">
+					<folderInfo id="com.ti.ccstudio.buildDefinitions.TMS470.Debug.215937359." name="/" resourcePath="">
+						<toolChain id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.DebugToolchain.1789566432" name="TI Build Tools" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.DebugToolchain" targetTool="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerDebug.77754934">
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS.1029957124" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS" valueType="stringList">
+								<listOptionValue builtIn="false" value="DEVICE_CONFIGURATION_ID=Cortex M.TM4E129BNCZAD"/>
+								<listOptionValue builtIn="false" value="DEVICE_ENDIANNESS=little"/>
+								<listOptionValue builtIn="false" value="OUTPUT_FORMAT=ELF"/>
+								<listOptionValue builtIn="false" value="CCS_MBS_VERSION=5.5.0"/>
+								<listOptionValue builtIn="false" value="RUNTIME_SUPPORT_LIBRARY=libc.a"/>
+								<listOptionValue builtIn="false" value="OUTPUT_TYPE=executable"/>
+							</option>
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION.1491769978" name="Compiler version" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION" value="5.0.4" valueType="string"/>
+							<targetPlatform id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.targetPlatformDebug.1544076748" name="Platform" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.targetPlatformDebug"/>
+							<builder buildPath="${BuildDirectory}" id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.builderDebug.1285386928" keepEnvironmentInBuildfile="false" name="GNU Make" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.builderDebug"/>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.compilerDebug.2048563761" name="ARM Compiler" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.compilerDebug">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.101570777" name="Target processor version (--silicon_version, -mv)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.7M4" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.12692234" name="Designate code state, 16-bit (thumb) or 32-bit (--code_state)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.290559066" name="Specify floating point support (--float_support)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.FPv4SPD16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.28556084" name="Application binary interface. [See 'General' page to edit] (--abi)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.eabi" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN.1939324154" name="Little endian code [See 'General' page to edit] (--little_endian, -me)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL.1073542002" name="Optimization level (--opt_level, -O)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.OPT_LEVEL.2" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL.859208444" name="Debugging model" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEBUGGING_MODEL.SYMDEBUG__DWARF" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH.625877715" name="Add dir to #include search path (--include_path, -I)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/${ProjName}}&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC.1625090535" name="Enable support for GCC extensions (--gcc)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE.368869153" name="Pre-define NAME (--define, -D)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="ccs=&quot;ccs&quot;"/>
+									<listOptionValue builtIn="false" value="DEBUG"/>
+									<listOptionValue builtIn="false" value="PART_TM4E129BNCZAD"/>
+									<listOptionValue builtIn="false" value="TARGET_IS_SNOWFLAKE_RA0"/>
+									<listOptionValue builtIn="false" value="EMAC_PHY_ADDRESS=0x19"/>
+									<listOptionValue builtIn="false" value="EMAC_EXTERNAL_PHY_RMII"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING.1605477777" name="Treat diagnostic &lt;id&gt; as warning (--diag_warning, -pdsw)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING" valueType="stringList">
+									<listOptionValue builtIn="false" value="225"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER.1533329625" name="Emit diagnostic identifier numbers (--display_error_number, -pden)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.1768302529" name="Wrap diagnostic messages (--diag_wrap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.15780130" name="Place each function in a separate subsection (--gen_func_subsections, -ms)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.on" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL.669482860" name="Use unified assembly language (--ual)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL" value="true" valueType="boolean"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.136655611" name="C Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.1602860595" name="C++ Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.808092407" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.23496473" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS"/>
+							</tool>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerDebug.77754934" name="ARM Linker" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerDebug">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.OUTPUT_FILE.1638599717" name="Specify output file name (--output_file, -o)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.OUTPUT_FILE" value="&quot;${ProjName}.out&quot;" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.STACK_SIZE.1934012973" name="Set C system stack size (--stack_size, -stack)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.STACK_SIZE" value="512" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.MAP_FILE.1236916106" name="Input and output sections listed into &lt;file&gt; (--map_file, -m)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.MAP_FILE" value="&quot;app_TM4E129BNCZAD_ccs.map&quot;" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.HEAP_SIZE.1295510910" name="Heap size for C/C++ dynamic memory allocation (--heap_size, -heap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.HEAP_SIZE" value="0" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.LIBRARY.716484648" name="Include library file or command file as input (--library, -l)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.LIBRARY" valueType="libs">
+									<listOptionValue builtIn="false" value="&quot;libc.a&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.SEARCH_PATH.660470329" name="Add &lt;dir&gt; to library search path (--search_path, -i)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.SEARCH_PATH" valueType="libPaths">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/lib&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DISPLAY_ERROR_NUMBER.1827877840" name="Emit diagnostic identifier numbers (--display_error_number)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP.955024501" name="Wrap diagnostic messages (--diag_wrap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.XML_LINK_INFO.432982550" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.XML_LINK_INFO" value="&quot;${ProjName}_linkInfo.xml&quot;" valueType="string"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD_SRCS.310866139" name="Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD2_SRCS.1026970871" name="Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD2_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__GEN_CMDS.499002072" name="Generated Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__GEN_CMDS"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry excluding="third_party/uip-1.0/uip/uip.c|third_party/uip-1.0/uip/uip_arp.c" flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name=""/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+		<cconfiguration id="com.ti.ccstudio.buildDefinitions.TMS470.Release.644322372">
+			<storageModule buildSystemId="org.eclipse.cdt.managedbuilder.core.configurationDataProvider" id="com.ti.ccstudio.buildDefinitions.TMS470.Release.644322372" moduleId="org.eclipse.cdt.core.settings" name="Release">
+				<macros>
+					<stringMacro name="ORIGINAL_PROJECT_ROOT" type="VALUE_PATH_DIR" value="C:/SDK/SMC/DK_SMC_1235/boards/dk-smc-lm4fb1/sample_eth_lpc_boot/ccs"/>
+					<stringMacro name="SW_ROOT" type="VALUE_PATH_DIR" value="${ORIGINAL_PROJECT_ROOT}/../../../.."/>
+				</macros>
+				<externalSettings/>
+				<extensions>
+					<extension id="com.ti.ccstudio.binaryparser.CoffParser" point="org.eclipse.cdt.core.BinaryParser"/>
+					<extension id="com.ti.ccstudio.errorparser.CoffErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.LinkErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+					<extension id="com.ti.ccstudio.errorparser.AsmErrorParser" point="org.eclipse.cdt.core.ErrorParser"/>
+				</extensions>
+			</storageModule>
+			<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+				<configuration artifactExtension="out" artifactName="${ProjName}" buildProperties="" cleanCommand="${CG_CLEAN_CMD}" description="" id="com.ti.ccstudio.buildDefinitions.TMS470.Release.644322372" name="Release" parent="com.ti.ccstudio.buildDefinitions.TMS470.Release" postbuildStep="&quot;${CCE_INSTALL_ROOT}/utils/tiobj2bin/tiobj2bin&quot; &quot;${BuildArtifactFileName}&quot; &quot;${BuildArtifactFileBaseName}.bin&quot; &quot;${CG_TOOL_ROOT}/bin/armofd&quot; &quot;${CG_TOOL_ROOT}/bin/armhex&quot; &quot;${CCE_INSTALL_ROOT}/utils/tiobj2bin/mkhex4bin&quot;">
+					<folderInfo id="com.ti.ccstudio.buildDefinitions.TMS470.Release.644322372." name="/" resourcePath="">
+						<toolChain id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.ReleaseToolchain.1637375146" name="TI Build Tools" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.ReleaseToolchain" targetTool="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerRelease.625638639">
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS.1168343218" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_TAGS" valueType="stringList">
+								<listOptionValue builtIn="false" value="DEVICE_CONFIGURATION_ID=Cortex M.LM4FB15P9ZAD"/>
+								<listOptionValue builtIn="false" value="DEVICE_ENDIANNESS=little"/>
+								<listOptionValue builtIn="false" value="OUTPUT_FORMAT=ELF"/>
+								<listOptionValue builtIn="false" value="CCS_MBS_VERSION=5.5.0"/>
+								<listOptionValue builtIn="false" value="RUNTIME_SUPPORT_LIBRARY=libc.a"/>
+								<listOptionValue builtIn="false" value="OUTPUT_TYPE=executable"/>
+							</option>
+							<option id="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION.644649711" name="Compiler version" superClass="com.ti.ccstudio.buildDefinitions.core.OPT_CODEGEN_VERSION" value="5.0.3" valueType="string"/>
+							<targetPlatform id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.targetPlatformRelease.1759793114" name="Platform" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.targetPlatformRelease"/>
+							<builder buildPath="${BuildDirectory}" id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.builderRelease.2119656460" keepEnvironmentInBuildfile="false" name="GNU Make" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.builderRelease"/>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.compilerRelease.1869681170" name="ARM Compiler" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.compilerRelease">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.407663541" name="Target processor version (--silicon_version, -mv)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.SILICON_VERSION.7M4" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.1643774505" name="Designate code state, 16-bit (thumb) or 32-bit (--code_state)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.CODE_STATE.16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.860760535" name="Application binary interface. [See 'General' page to edit] (--abi)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.ABI.eabi" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.1545704456" name="Specify floating point support (--float_support)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.FLOAT_SUPPORT.FPv4SPD16" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING.1719202087" name="Treat diagnostic &lt;id&gt; as warning (--diag_warning, -pdsw)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WARNING" valueType="stringList">
+									<listOptionValue builtIn="false" value="225"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER.585713935" name="Emit diagnostic identifier numbers (--display_error_number, -pden)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.1679693266" name="Wrap diagnostic messages (--diag_wrap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH.2040229069" name="Add dir to #include search path (--include_path, -I)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.INCLUDE_PATH" valueType="includePath">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${workspace_loc:/${ProjName}}&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${SW_ROOT}/boards/dk-smc-lm4fb1&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${SW_ROOT}&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN.1926607970" name="Little endian code [See 'General' page to edit] (--little_endian, -me)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.LITTLE_ENDIAN" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.1836249770" name="Place each function in a separate subsection (--gen_func_subsections, -ms)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GEN_FUNC_SUBSECTIONS.on" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC.802481333" name="Enable support for GCC extensions (--gcc)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.GCC" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL.831884052" name="Use unified assembly language (--ual)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.UAL" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE.4397889" name="Pre-define NAME (--define, -D)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compilerID.DEFINE" valueType="definedSymbols">
+									<listOptionValue builtIn="false" value="ccs=&quot;ccs&quot;"/>
+									<listOptionValue builtIn="false" value="PART_TM4E129BNCZAD"/>
+									<listOptionValue builtIn="false" value="TARGET_IS_SNOWFLAKE_RA0"/>
+									<listOptionValue builtIn="false" value="EMAC_PHY_ADDRESS=2"/>
+									<listOptionValue builtIn="false" value="EMAC_EXTERNAL_PHY_RMII"/>
+								</option>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS.1473887412" name="C Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__C_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS.1953395540" name="C++ Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__CPP_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS.1539957461" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS.1740888388" name="Assembly Sources" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.compiler.inputType__ASM2_SRCS"/>
+							</tool>
+							<tool id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerRelease.625638639" name="ARM Linker" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exe.linkerRelease">
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.MAP_FILE.1915138346" name="Input and output sections listed into &lt;file&gt; (--map_file, -m)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.MAP_FILE" value="&quot;sample_eth_lpc_boot_ccs.map&quot;" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.STACK_SIZE.1312536959" name="Set C system stack size (--stack_size, -stack)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.STACK_SIZE" value="2048" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.HEAP_SIZE.2053635570" name="Heap size for C/C++ dynamic memory allocation (--heap_size, -heap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.HEAP_SIZE" value="0" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.OUTPUT_FILE.1176439910" name="Specify output file name (--output_file, -o)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.OUTPUT_FILE" value="&quot;${ProjName}.out&quot;" valueType="string"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DISPLAY_ERROR_NUMBER.1065435393" name="Emit diagnostic identifier numbers (--display_error_number)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DISPLAY_ERROR_NUMBER" value="true" valueType="boolean"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP.1656753133" name="Wrap diagnostic messages (--diag_wrap)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP" value="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.DIAG_WRAP.off" valueType="enumerated"/>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.SEARCH_PATH.874900001" name="Add &lt;dir&gt; to library search path (--search_path, -i)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.SEARCH_PATH" valueType="stringList">
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/lib&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${CG_TOOL_ROOT}/include&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.LIBRARY.2084850123" name="Include library file or command file as input (--library, -l)" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.LIBRARY" valueType="libs">
+									<listOptionValue builtIn="false" value="&quot;libc.a&quot;"/>
+									<listOptionValue builtIn="false" value="&quot;${SW_ROOT}/driverlib/ccs/Debug/driverlib.lib&quot;"/>
+								</option>
+								<option id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.XML_LINK_INFO.1162240934" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.linkerID.XML_LINK_INFO" value="&quot;${ProjName}_linkInfo.xml&quot;" valueType="string"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD_SRCS.111361508" name="Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD2_SRCS.461943084" name="Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__CMD2_SRCS"/>
+								<inputType id="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__GEN_CMDS.1998175228" name="Generated Linker Command Files" superClass="com.ti.ccstudio.buildDefinitions.TMS470_5.0.exeLinker.inputType__GEN_CMDS"/>
+							</tool>
+						</toolChain>
+					</folderInfo>
+					<sourceEntries>
+						<entry excluding="third_party/uip-1.0/uip/uip.c|third_party/uip-1.0/uip/uip_arp.c" flags="VALUE_WORKSPACE_PATH|RESOLVED" kind="sourcePath" name=""/>
+					</sourceEntries>
+				</configuration>
+			</storageModule>
+			<storageModule moduleId="org.eclipse.cdt.core.externalSettings"/>
+		</cconfiguration>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.LanguageSettingsProviders"/>
+	<storageModule moduleId="cdtBuildSystem" version="4.0.0">
+		<project id="sample_eth_lpc_boot.com.ti.ccstudio.buildDefinitions.TMS470.ProjectType.95519263" name="ARM" projectType="com.ti.ccstudio.buildDefinitions.TMS470.ProjectType"/>
+	</storageModule>
+	<storageModule moduleId="org.eclipse.cdt.core.language.mapping">
+		<project-mappings>
+			<content-type-mapping configuration="" content-type="org.eclipse.cdt.core.asmSource" language="com.ti.ccstudio.core.TIASMLanguage"/>
+			<content-type-mapping configuration="" content-type="org.eclipse.cdt.core.cHeader" language="com.ti.ccstudio.core.TIGCCLanguage"/>
+			<content-type-mapping configuration="" content-type="org.eclipse.cdt.core.cSource" language="com.ti.ccstudio.core.TIGCCLanguage"/>
+			<content-type-mapping configuration="" content-type="org.eclipse.cdt.core.cxxHeader" language="com.ti.ccstudio.core.TIGPPLanguage"/>
+			<content-type-mapping configuration="" content-type="org.eclipse.cdt.core.cxxSource" language="com.ti.ccstudio.core.TIGPPLanguage"/>
+		</project-mappings>
+	</storageModule>
+	<storageModule moduleId="scannerConfiguration"/>
+</cproject>
Only in f09_tmp/driverlib: adc.c
Only in f09_tmp/driverlib: aes.c
Only in f09_tmp/driverlib: can.c
Only in f09_tmp/driverlib: ccs
Only in f09_tmp/driverlib: cir.c
Only in f09_tmp/driverlib: comp.c
Only in f09_tmp/driverlib: cpu.c
Only in f09_tmp/driverlib: crc.c
Only in f09_tmp/driverlib: des.c
Binary files f09_tmp/driverlib/driverlib.lib and f09_bootloader_202/driverlib/driverlib.lib differ
Only in f09_tmp/driverlib: eeprom.c
Only in f09_tmp/driverlib: emac.c
Only in f09_tmp/driverlib: epi.c
Only in f09_tmp/driverlib: fan.c
Only in f09_tmp/driverlib: flash.c
Only in f09_tmp/driverlib: fpu.c
Only in f09_tmp/driverlib: gpio.c
Only in f09_tmp/driverlib: hibernate.c
Only in f09_tmp/driverlib: i2c.c
Only in f09_tmp/driverlib: interrupt.c
Only in f09_tmp/driverlib: kbscan.c
Only in f09_tmp/driverlib: lcd.c
Only in f09_tmp/driverlib: ledseq.c
Only in f09_tmp/driverlib: lpcB.c
Only in f09_tmp/driverlib: lpc.c
Only in f09_tmp/driverlib: Makefile
Only in f09_tmp/driverlib: mpu.c
Only in f09_tmp/driverlib: onewire.c
Only in f09_tmp/driverlib: peci.c
Only in f09_tmp/driverlib: port80.c
Only in f09_tmp/driverlib: ps2.c
Only in f09_tmp/driverlib: pwm.c
Only in f09_tmp/driverlib: qei.c
Only in f09_tmp/driverlib: rts.c
Only in f09_tmp/driverlib: shamd5.c
Only in f09_tmp/driverlib: ssi.c
Only in f09_tmp/driverlib: sw_crc.c
Only in f09_tmp/driverlib: sysctl.c
Only in f09_tmp/driverlib: sysexc.c
Only in f09_tmp/driverlib: systick.c
Only in f09_tmp/driverlib: timer.c
Only in f09_tmp/driverlib: uart.c
Only in f09_tmp/driverlib: udma.c
Only in f09_tmp/driverlib: usb.c
Only in f09_tmp/driverlib: watchdog.c
diff --unidirectional-new-file -ru f09_tmp/inc/hw_memmap.h f09_bootloader_202/inc/hw_memmap.h
--- f09_tmp/inc/hw_memmap.h	2017-08-29 10:03:23.866264682 +0800
+++ f09_bootloader_202/inc/hw_memmap.h	2017-08-23 13:37:40.671000000 +0800
@@ -73,6 +73,7 @@
 #define I2C1_BASE               0x40021000  // I2C1
 #define I2C2_BASE               0x40022000  // I2C2
 #define I2C3_BASE               0x40023000  // I2C3
+#define I2C8_BASE               0x400B8000  // I2C8
 #define GPIO_PORTE_BASE         0x40024000  // GPIO Port E
 #define GPIO_PORTF_BASE         0x40025000  // GPIO Port F
 #define GPIO_PORTG_BASE         0x40026000  // GPIO Port G
diff --unidirectional-new-file -ru f09_tmp/inc/hw_sysctl.h f09_bootloader_202/inc/hw_sysctl.h
--- f09_tmp/inc/hw_sysctl.h	2017-08-29 10:03:23.906264682 +0800
+++ f09_bootloader_202/inc/hw_sysctl.h	2017-08-23 13:37:40.699000000 +0800
@@ -1334,12 +1334,14 @@
 #define SYSCTL_RCGC1_TIMER2     0x00040000  // Timer 2 Clock Gating Control
 #define SYSCTL_RCGC1_TIMER1     0x00020000  // Timer 1 Clock Gating Control
 #define SYSCTL_RCGC1_TIMER0     0x00010000  // Timer 0 Clock Gating Control
+#define SYSCTL_RCGC1_I2C2       0x00008000  // I2C2 Clock Gating Control
 #define SYSCTL_RCGC1_I2C1       0x00004000  // I2C1 Clock Gating Control
 #define SYSCTL_RCGC1_I2C0       0x00001000  // I2C0 Clock Gating Control
 #define SYSCTL_RCGC1_QEI1       0x00000200  // QEI1 Clock Gating Control
 #define SYSCTL_RCGC1_QEI0       0x00000100  // QEI0 Clock Gating Control
 #define SYSCTL_RCGC1_SSI1       0x00000020  // SSI1 Clock Gating Control
 #define SYSCTL_RCGC1_SSI0       0x00000010  // SSI0 Clock Gating Control
+#define SYSCTL_RCGC1_UART4      0x00000010  // UART4 Clock Gating Control
 #define SYSCTL_RCGC1_UART2      0x00000004  // UART2 Clock Gating Control
 #define SYSCTL_RCGC1_UART1      0x00000002  // UART1 Clock Gating Control
 #define SYSCTL_RCGC1_UART0      0x00000001  // UART0 Clock Gating Control
@@ -1351,6 +1353,11 @@
 //*****************************************************************************
 #define SYSCTL_RCGC2_USB0       0x00010000  // USB0 Clock Gating Control
 #define SYSCTL_RCGC2_UDMA       0x00002000  // Micro-DMA Clock Gating Control
+#define SYSCTL_RCGC2_GPIOP      0x00002000  // Port P Clock Gating Control
+#define SYSCTL_RCGC2_GPION      0x00001000  // Port N Clock Gating Control
+#define SYSCTL_RCGC2_GPIOM      0x00000800  // Port M Clock Gating Control
+#define SYSCTL_RCGC2_GPIOL      0x00000400  // Port L Clock Gating Control
+#define SYSCTL_RCGC2_GPIOK      0x00000200  // Port K Clock Gating Control
 #define SYSCTL_RCGC2_GPIOJ      0x00000100  // Port J Clock Gating Control
 #define SYSCTL_RCGC2_GPIOH      0x00000080  // Port H Clock Gating Control
 #define SYSCTL_RCGC2_GPIOG      0x00000040  // Port G Clock Gating Control
diff --unidirectional-new-file -ru f09_tmp/.launches/bootloader.launch f09_bootloader_202/.launches/bootloader.launch
--- f09_tmp/.launches/bootloader.launch	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/.launches/bootloader.launch	2017-08-23 13:37:39.864000000 +0800
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<launchConfiguration type="com.ti.ccstudio.debug.launchType.device.debugging">
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.ATTR_CPUS_WITH_PROJECT" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&#13;&#10;&lt;cpus_with_project&gt;&#13;&#10;&lt;id id=&quot;Stellaris In-Circuit Debug Interface/CORTEX_M4_0&quot; isa=&quot;CORTEX_M4&quot;/&gt;&#13;&#10;&lt;/cpus_with_project&gt;"/>
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.ATTR_DEBUGGER_PROPERTIES.Stellaris In-Circuit Debug Interface/CORTEX_M4_0" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot; ?&gt;&#10;&lt;PropertyValues&gt;&#10;&#10;  &lt;property id=&quot;ConnectOnStartup&quot;&gt;&#10;    &lt;curValue&gt;1&lt;/curValue&gt;&#10;  &lt;/property&gt;&#10;&#10;  &lt;property id=&quot;EnableInstalledBreakpoint&quot;&gt;&#10;    &lt;curValue&gt;1&lt;/curValue&gt;&#10;  &lt;/property&gt;&#10;&#10;  &lt;property id=&quot;IgnoreSoftLaunchFailures&quot;&gt;&#10;    &lt;curValue&gt;0&lt;/curValue&gt;&#10;  &lt;/property&gt;&#10;&#10;&lt;/PropertyValues&gt;&#10;"/>
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.ATTR_PROGRAM.Stellaris In-Circuit Debug Interface/CORTEX_M4_0" value="${build_artifact:bootloader}"/>
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.ATTR_PROJECT.Stellaris In-Circuit Debug Interface/CORTEX_M4_0" value="bootloader"/>
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.ATTR_TARGET_CONFIG" value="${target_config_active_default:bootloader}"/>
+<stringAttribute key="com.ti.ccstudio.debug.debugModel.MRU_PROGRAM.Stellaris In-Circuit Debug Interface/CORTEX_M4_0" value="D:/share\projects\F20\source_code\Bootloader\f20_boot\Debug\bootloader.out"/>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_PATHS">
+<listEntry value="/bootloader"/>
+</listAttribute>
+<listAttribute key="org.eclipse.debug.core.MAPPED_RESOURCE_TYPES">
+<listEntry value="4"/>
+</listAttribute>
+<stringAttribute key="org.eclipse.debug.core.source_locator_id" value="com.ti.ccstudio.debug.sourceLocator"/>
+<stringAttribute key="org.eclipse.debug.core.source_locator_memento" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;sourceLookupDirector&gt;&#13;&#10;&lt;sourceContainers duplicates=&quot;false&quot;&gt;&#13;&#10;&lt;container memento=&quot;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;no&amp;quot;?&amp;gt;&amp;#13;&amp;#10;&amp;lt;default/&amp;gt;&amp;#13;&amp;#10;&quot; typeId=&quot;org.eclipse.debug.core.containerType.default&quot;/&gt;&#13;&#10;&lt;container memento=&quot;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; standalone=&amp;quot;no&amp;quot;?&amp;gt;&amp;#13;&amp;#10;&amp;lt;cpuSpecificContainer cpuName=&amp;quot;Stellaris In-Circuit Debug Interface/CORTEX_M4_0&amp;quot;&amp;gt;&amp;#13;&amp;#10;&amp;lt;childContainerEntry childMemento=&amp;quot;&amp;amp;lt;?xml version=&amp;amp;quot;1.0&amp;amp;quot; encoding=&amp;amp;quot;UTF-8&amp;amp;quot; standalone=&amp;amp;quot;no&amp;amp;quot;?&amp;amp;gt;&amp;amp;#13;&amp;amp;#10;&amp;amp;lt;default/&amp;amp;gt;&amp;amp;#13;&amp;amp;#10;&amp;quot; childType=&amp;quot;org.eclipse.debug.core.containerType.default&amp;quot;/&amp;gt;&amp;#13;&amp;#10;&amp;lt;childContainerEntry childMemento=&amp;quot;&amp;amp;lt;?xml version=&amp;amp;quot;1.0&amp;amp;quot; encoding=&amp;amp;quot;UTF-8&amp;amp;quot; standalone=&amp;amp;quot;no&amp;amp;quot;?&amp;amp;gt;&amp;amp;#13;&amp;amp;#10;&amp;amp;lt;project name=&amp;amp;quot;bootloader&amp;amp;quot; referencedProjects=&amp;amp;quot;true&amp;amp;quot;/&amp;amp;gt;&amp;amp;#13;&amp;amp;#10;&amp;quot; childType=&amp;quot;org.eclipse.debug.core.containerType.project&amp;quot;/&amp;gt;&amp;#13;&amp;#10;&amp;lt;/cpuSpecificContainer&amp;gt;&amp;#13;&amp;#10;&quot; typeId=&quot;com.ti.ccstudio.debug.containerType.cpu.specific&quot;/&gt;&#13;&#10;&lt;/sourceContainers&gt;&#13;&#10;&lt;/sourceLookupDirector&gt;&#13;&#10;"/>
+<stringAttribute key="org.eclipse.dsf.launch.MEMORY_BLOCKS" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&#13;&#10;&lt;memoryBlockExpressionList context=&quot;reserved-for-future-use&quot;/&gt;&#13;&#10;"/>
+</launchConfiguration>
diff --unidirectional-new-file -ru f09_tmp/macros.ini_initial f09_bootloader_202/macros.ini_initial
--- f09_tmp/macros.ini_initial	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/macros.ini_initial	2017-08-23 13:37:40.980000000 +0800
@@ -0,0 +1 @@
+SW_ROOT = ../../../..
diff --unidirectional-new-file -ru f09_tmp/main.c f09_bootloader_202/main.c
--- f09_tmp/main.c	2017-08-29 10:03:22.850264682 +0800
+++ f09_bootloader_202/main.c	2017-08-23 13:37:40.647000000 +0800
@@ -1,45 +1,1121 @@
-/*
- *  ======== main.c ========
- */
-
-#include <xdc/std.h>
-
-#include <xdc/runtime/Error.h>
-#include <xdc/runtime/System.h>
-
-#include <ti/sysbios/BIOS.h>
-
-#include <ti/sysbios/knl/Task.h>
-
-/*
- *  ======== taskFxn ========
- */
-Void taskFxn(UArg a0, UArg a1)
-{
-    System_printf("enter taskFxn()\n");
-
-    Task_sleep(10);
-
-    System_printf("exit taskFxn()\n");
-}
-
-/*
- *  ======== main ========
- */
-Int main()
-{ 
-    Task_Handle task;
-    Error_Block eb;
-
-    System_printf("enter main()\n");
-
-    Error_init(&eb);
-    task = Task_create(taskFxn, NULL, &eb);
-    if (task == NULL) {
-        System_printf("Task_create() failed!\n");
-        BIOS_exit(0);
-    }
-
-    BIOS_start();    /* does not return */
-    return(0);
-}
+//*****************************************************************************
+//
+// main.c - main entry for BMC Ethernet boot loader example.
+//
+// Copyright (c) 2008-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "inc/hw_gpio.h"
+#include "inc/hw_ints.h"
+#include "inc/hw_memmap.h"
+#include "inc/hw_nvic.h"
+#include "inc/hw_sysctl.h"
+#include "inc/hw_types.h"
+#include "driverlib/flash.h"
+#include "driverlib/fpu.h"
+#include "driverlib/gpio.h"
+#include "driverlib/interrupt.h"
+#include "driverlib/pin_map.h"
+#include "driverlib/rom.h"
+#include "driverlib/sysctl.h"
+#include "driverlib/watchdog.h"
+#include "driverlib/eeprom.h"
+#include "driverlib/rom_map.h"
+#include "third_party/uip-1.0/uip/uip.h"
+#include "bmc_blcfg.h"
+#include "driverlib/eeprom.h"
+
+
+//*****************************************************************************
+//
+//! \addtogroup example_list
+//! <h1>BMC combined boot loader example (bmc_bl)</h1>
+//!
+//! The boot loader is a small piece of code that can be programmed at the
+//! beginning of flash to act as an application loader as well as an update
+//! mechanism for an application by utilzing Ethernet or LPC. 
+//!
+//! The application uses configuration options defined in the bmc_blcfg.h file
+//! to determine application location, update flag area in flash and the range
+//! of flash it has access to during an update.
+//!
+//! The boot loader treats the update area as data owned by the application.
+//! Thus the application should clear the update flag on execution or the
+//! update will be run again on the next reset.
+//!
+//! This application was designed to run on a Snowflake BGA212 SLED +
+//! RUNNERII + IGLOO. The PHY1 on RUNNERII is used for Ethernet traffic.
+//!
+//
+//*****************************************************************************
+
+//*****************************************************************************
+//
+// The error routine that is called if the driver library encounters an error.
+//
+//*****************************************************************************
+#ifdef DEBUG
+void
+__error__(char *pcFilename, unsigned long ulLine)
+{
+}
+#endif
+
+//*****************************************************************************
+//
+// External references
+//
+//*****************************************************************************
+extern void entry(void);
+extern uint32_t CheckImage(uint32_t ui32Address);
+
+//
+// External references owned by the bl_enet module. These are used to
+// set TFTP information (IP address and filename).
+//
+extern uip_ipaddr_t g_sTFTPAddr;
+extern char g_pcFilename[128];
+
+//
+// Funtion to start the TFTP update.
+//
+extern void TFTPUpdate(void);
+
+//
+// Function to configure and start the UART update.
+//
+extern void ConfigureUARTDevice(void);
+extern void UART_Updater(void);
+
+//
+// Function to configure and start the UART update.
+//
+extern void ConfigureI2CDevice(void);
+extern void I2C_Updater(void);
+
+//
+// The prototype for the function that is used to call the application.
+//
+void CallApplication(uint32_t ui32StartAddr);
+
+extern uint8_t g_ui8flashclear;
+extern uint8_t dhcpexist;
+
+extern int Hal_eeprom_write( uint8_t *buffer, uint16_t offset ,  uint16_t len);
+extern void  Hal_eeprom_read( uint8_t *buffer, uint16_t offset ,  uint16_t len);
+
+#pragma DATA_SECTION(FW_CHECK, ".temp")
+const uint8_t FW_CHECK[] = "BRIDGEICBOOTLDR";
+
+
+//*****************************************************************************
+//
+// This function parses the expected update flag area of flash for the signal
+// that it should run the TFTP update.
+//
+//*****************************************************************************
+static bool
+ENETCheckUpdate(void)
+{
+
+    
+    //Jerry130806 read the tftp update flag ,ip addr and image name from the internal EEPROM
+    uint32_t pui32Words[2],ui32Idx,ui32Data,ui32delData;
+    char pcChars[EEPROM_UPDATE_DATA_SIZE - (sizeof(uint32_t) * 2)];
+    
+    //ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
+    //ROM_EEPROMInit();
+    
+    EEPROMRead(pui32Words,EEPROM_ADDR_UPDATE,0x08);
+    
+    //DPRINTF(("TFTP flag = 0x%x \n",pui32Words[0]&0xFF));
+    if((pui32Words[0]&0xFF) == 0x00000001)
+    {
+    	*((uint32_t *)(&g_sTFTPAddr[0])) = pui32Words[1];
+    	
+    	EEPROMRead(&ui32delData,EEPROM_ADDR_UPDATE,0x04);
+    	//ui32delData = ui32delData & 0xFFFFFF00;   //bit[0:7] tftp update flag
+    	//ROM_EEPROMProgram(&ui32delData,EEPROM_ADDR_UPDATE,0x04);  //Clear the flag
+    	//DPRINTF(("ip=%x ",pui32Words[1]));
+    	
+    	for(ui32Idx = 0; ui32Idx < (EEPROM_UPDATE_DATA_SIZE - 8); ui32Idx+=4)
+      {
+            EEPROMRead(&ui32Data,EEPROM_ADDR_UPDATE + 8 + ui32Idx,0x04);
+            //DPRINTF(("\n\nui32Data = %x +++++\n",ui32Data));
+            pcChars[ui32Idx] = (char)(ui32Data & 0xff);
+            pcChars[ui32Idx + 1] = (char)((ui32Data >> 8) & 0xff);
+            pcChars[ui32Idx + 2] = (char)((ui32Data >> 16) & 0xff);
+            pcChars[ui32Idx + 3] = (char)((ui32Data >> 24) & 0xff);
+      }
+      for(ui32Idx = 0; ui32Idx < (EEPROM_UPDATE_DATA_SIZE -
+                                    (sizeof(uint32_t) * 2)); ui32Idx++)
+      {
+            g_pcFilename[ui32Idx] = pcChars[ui32Idx];
+            //DPRINTF(("name=%x ",g_pcFilename[ui32Idx]));
+      }
+  
+      return(true);
+    	
+    }	
+    return(false);
+    
+    
+
+/*    
+    uint32_t pui32Words[2], ui32Idx, ui32Data;
+    char pcChars[FLASH_UPDATE_DATA_SIZE - (sizeof(uint32_t) * 2)];
+
+    //
+    // Setup for an update if a 'true' value was set in the RunUpdate location.
+    //
+    ////DPRINTF(("ENETCheckUpdate =%x ",HWREG(FLASH_ADDR_UPDATE)));
+    ////DPRINTF(("!! ENETCheckUpdate =%x ",HWREG(FLASH_ADDR_UPDATE+4)));
+    if( (HWREG(FLASH_ADDR_UPDATE) &0xFF)== 0x00000001)
+    {
+        //
+        // Grab the word data.
+        //
+        pui32Words[0] = HWREG(FLASH_ADDR_UPDATE);
+        pui32Words[1] = HWREG(FLASH_ADDR_UPDATE + 4);
+        
+        //
+        // Grab the character data.
+        //
+        for(ui32Idx = 0; ui32Idx < (FLASH_UPDATE_DATA_SIZE - 8); ui32Idx+=4)
+        {
+            ui32Data = HWREG(FLASH_ADDR_UPDATE + 8 + ui32Idx);
+            pcChars[ui32Idx] = (char)(ui32Data & 0xff);
+            pcChars[ui32Idx + 1] = (char)((ui32Data >> 8) & 0xff);
+            pcChars[ui32Idx + 2] = (char)((ui32Data >> 16) & 0xff);
+            pcChars[ui32Idx + 3] = (char)((ui32Data >> 24) & 0xff);
+        }
+
+        //
+        // Load the data in the globals for TFTP use.
+        //
+        *((uint32_t *)(&g_sTFTPAddr[0])) = pui32Words[1];
+        for(ui32Idx = 0; ui32Idx < (FLASH_UPDATE_DATA_SIZE -
+                                    (sizeof(uint32_t) * 2)); ui32Idx++)
+        {
+            g_pcFilename[ui32Idx] = pcChars[ui32Idx];
+        }
+
+        //
+        // Signal the update.
+        //
+        return(true);
+    }
+
+    //
+    // Flag not set, don't update.
+    //
+    return(false);
+    
+*/
+    
+}
+
+//*****************************************************************************
+//
+// Helper function to setup Ethernet pins.
+//
+//*****************************************************************************
+static void
+PinSetEthernetMII(uint32_t ui32Port, uint8_t ui8Pins)
+{
+    //
+    // These are HW controlled pins so make sure DIR is clear
+    // and AFSEL is set.
+    //
+    HWREG(ui32Port + GPIO_O_DIR) = HWREG(ui32Port + GPIO_O_DIR) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_AFSEL) = HWREG(ui32Port + GPIO_O_AFSEL) | ui8Pins;
+
+    //
+    // Set the output drive strength. These are required to be
+    // setup as 8MA. Clear all other drive strengths and set 8MA.
+    //
+    HWREG(ui32Port + GPIO_O_DR2R) = HWREG(ui32Port + GPIO_O_DR2R) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_DR4R) = HWREG(ui32Port + GPIO_O_DR4R) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_DR8R) = HWREG(ui32Port + GPIO_O_DR8R) | ui8Pins;
+    HWREG(ui32Port + GPIO_O_SLR) = HWREG(ui32Port + GPIO_O_SLR) & ~(ui8Pins);
+
+    //
+    // Set the pin type. These pins need a digital push-pull configuration.
+    // Clear other configuration options and set DEN.
+    //
+    HWREG(ui32Port + GPIO_O_ODR) = HWREG(ui32Port + GPIO_O_ODR) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_PUR) = HWREG(ui32Port + GPIO_O_PUR) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_PDR) = HWREG(ui32Port + GPIO_O_PDR) & ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_AMSEL) = HWREG(ui32Port + GPIO_O_AMSEL) &
+                                     ~(ui8Pins);
+    HWREG(ui32Port + GPIO_O_DEN) = HWREG(ui32Port + GPIO_O_DEN) | ui8Pins;
+}
+
+//*****************************************************************************
+//
+// Setup RMII signal pins.
+//
+//*****************************************************************************
+static void
+ETH_BootInit(void)
+{
+    //
+    // Configure pins for EMAC RMII use (on RUNNERII daughter).
+    // GPIOs peripherals set to run-mode are:
+    //
+
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
+    ROM_SysCtlDelay(3);
+
+    //
+    // Configure the external clock pin necessary for the RMII interface.
+    // This is always PM4 on Snowflake.
+    //
+
+    ROM_GPIOPinConfigure(GPIO_PM4_EN0RREF_CLK);
+    PinSetEthernetMII(GPIO_PORTM_BASE, GPIO_PIN_4);
+
+    //
+    // Configure the MDIO interface (MDIO/MDC) on PF2 & PF3.
+    //
+    ROM_GPIOPinConfigure(GPIO_PF2_EN0MDC);
+    ROM_GPIOPinConfigure(GPIO_PF3_EN0MDIO);
+    PinSetEthernetMII(GPIO_PORTF_BASE, GPIO_PIN_2 | GPIO_PIN_3);
+
+
+#if (EMAC_PHY_ADDRESS == 0x01)
+    //
+    // Set the EPHY0 pins for RMII use.
+    //      Pin   Function
+    //      --------------
+    //		PM5 = EPHY0_RESET#
+    //      PP0 = INTRN
+    //      PG3 = TX_EN
+    //      PG4 = TX_D0
+    //      PG5 = TX_D1
+    //      PG7 = RX_DV/CRS,
+    //      PQ5 = RX_D0
+    //      PQ6 = RX_D1.
+    //
+
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
+    ROM_SysCtlDelay(3);
+
+
+    //
+    // Configure the GPIO used to reset the PHY and hold it in reset for now.
+    //
+    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTM_BASE, GPIO_PIN_5);
+    ROM_GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_5, 0);
+
+    ROM_GPIOPinConfigure(GPIO_PP0_EN0INTRN);
+    PinSetEthernetMII(GPIO_PORTP_BASE, GPIO_PIN_0);
+
+    ROM_GPIOPinConfigure(GPIO_PG3_EN0TXEN);
+    PinSetEthernetMII(GPIO_PORTG_BASE, GPIO_PIN_3);
+
+    ROM_GPIOPinConfigure(GPIO_PG4_EN0TXD0);
+    ROM_GPIOPinConfigure(GPIO_PG5_EN0TXD1);
+    ROM_GPIOPinConfigure(GPIO_PG7_EN0RXDV);
+    PinSetEthernetMII(GPIO_PORTG_BASE, (GPIO_PIN_4 | GPIO_PIN_5 |
+                                        GPIO_PIN_7));
+    ROM_GPIOPinConfigure(GPIO_PQ5_EN0RXD0);
+    ROM_GPIOPinConfigure(GPIO_PQ6_EN0RXD1);
+    PinSetEthernetMII(GPIO_PORTQ_BASE, GPIO_PIN_5 | GPIO_PIN_6);
+
+    //
+    // Bring EPHY1 out of reset.
+    //
+    ROM_GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_5, GPIO_PIN_5);
+
+#elif (EMAC_PHY_ADDRESS == 0x02)
+
+    //
+    // Set the EPHY1 pins for RMII use.
+    //      Pin   Function
+    //      --------------
+    //		PQ7 = EPHY0_RESET#
+    //      PK4 = INTRN
+    //      PR7 = TX_EN
+    //      PS4 = TX_D0
+    //      PS5 = TX_D1
+    //      PS7 = RX_DV,
+    //      PT0 = RX_D0
+    //      PT1 = RX_D1.
+    //
+
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOR);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOS);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOT);
+    ROM_SysCtlDelay(3);
+
+    //
+    // Configure the GPIO used to reset the PHY and hold it in reset for now.
+    //
+    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTQ_BASE, GPIO_PIN_7);
+    ROM_GPIOPinWrite(GPIO_PORTQ_BASE, GPIO_PIN_7, 0);
+
+    ROM_GPIOPinConfigure(GPIO_PK4_EN0INTRN);
+    PinSetEthernetMII(GPIO_PORTK_BASE, GPIO_PIN_4);
+    ROM_GPIOPinConfigure(GPIO_PR7_EN0TXEN);
+    PinSetEthernetMII(GPIO_PORTR_BASE, GPIO_PIN_7);
+    ROM_GPIOPinConfigure(GPIO_PS4_EN0TXD0);
+    ROM_GPIOPinConfigure(GPIO_PS5_EN0TXD1);
+    ROM_GPIOPinConfigure(GPIO_PS7_EN0RXDV);
+    PinSetEthernetMII(GPIO_PORTS_BASE, (GPIO_PIN_4 | GPIO_PIN_5 |
+                                        GPIO_PIN_7));
+    ROM_GPIOPinConfigure(GPIO_PT0_EN0RXD0);
+    ROM_GPIOPinConfigure(GPIO_PT1_EN0RXD1);
+    PinSetEthernetMII(GPIO_PORTT_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+
+    //
+    // Bring EPHY1 out of reset.
+    //
+    ROM_GPIOPinWrite(GPIO_PORTQ_BASE, GPIO_PIN_7, GPIO_PIN_7);
+#elif (EMAC_PHY_ADDRESS == 0x19)    //Jerry130806 Add this setting to config S1M PHY
+
+    //
+    // Set the EPHY0 pins for RMII use.
+    //      Pin   Function
+    //      --------------
+	//		PM4 = EN0RREF_CLK
+	//		PF2 = MDC
+	//		PF3 = MDIO
+    //      PG3 = TX_EN
+    //      PG4 = TX_D0
+    //      PG5 = TX_D1
+    //      PQ5 = RX_D0
+    //      PQ6 = RX_D1
+	//      PG7 = RX_DV/CRS,
+	//		NA = EPHY0_RESET#
+    //      NA = INTRN
+    //
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
+    ROM_SysCtlDelay(3);
+
+    //
+    // Configure the GPIO used to reset the PHY0 and hold it in reset for now.
+    //
+    ROM_GPIOPinTypeGPIOOutput(GPIO_PORTM_BASE, GPIO_PIN_5);
+    ROM_GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_5, 0);
+
+    //
+    // Configure the GPIO used to the PHY0 input interrupt
+    //
+//    ROM_GPIOPinConfigure(GPIO_PP0_EN0INTRN);
+//    PinSetEthernetMII(GPIO_PORTP_BASE, GPIO_PIN_0);
+
+
+    //
+    // Configure the GPIO used to the PHY0 for TXD0/TXD1/RXDV/TXEN
+    //
+    ROM_GPIOPinConfigure(GPIO_PG3_EN0TXEN);
+    PinSetEthernetMII(GPIO_PORTG_BASE, GPIO_PIN_3);
+
+    ROM_GPIOPinConfigure(GPIO_PG4_EN0TXD0);
+    ROM_GPIOPinConfigure(GPIO_PG5_EN0TXD1);
+    ROM_GPIOPinConfigure(GPIO_PG7_EN0RXDV);
+    PinSetEthernetMII(GPIO_PORTG_BASE, (GPIO_PIN_4 | GPIO_PIN_5 |
+                                            GPIO_PIN_7));
+    ROM_GPIOPinConfigure(GPIO_PQ5_EN0RXD0);
+    ROM_GPIOPinConfigure(GPIO_PQ6_EN0RXD1);
+    PinSetEthernetMII(GPIO_PORTQ_BASE, GPIO_PIN_5 | GPIO_PIN_6);
+
+    //
+    // Bring EPHY0 out of reset.
+    //
+    GPIOPinWrite(GPIO_PORTM_BASE, GPIO_PIN_5, GPIO_PIN_5);
+#endif
+}
+
+
+//*****************************************************************************
+//
+// This function is used to pass control to the application code.
+// It will set the NVIC to point at the user app's vector table, load up the
+// user app's stack pointer, and then jump to the application.
+//
+//*****************************************************************************
+#if defined(codered) || defined(gcc) || defined(sourcerygxx)
+static void __attribute__((naked))
+Branch(uint32_t ui32StartAddr)
+{
+    //
+    // Set the vector table to the beginning of the app in flash.
+    //
+    HWREG(NVIC_VTABLE) = ui32StartAddr;
+
+    //
+    // Load the stack pointer from the application's vector table.
+    //
+    __asm("    ldr     r1, [r0]\n"
+          "    mov     sp, r1");
+
+    //
+    // Load the initial PC from the application's vector table and branch to
+    // the application's entry point.
+    //
+    __asm("    ldr     r0, [r0, #4]\n"
+          "    bx      r0\n");
+}
+#elif defined(ewarm)
+static void
+Branch(uint32_t ui32StartAddr)
+{
+    //
+    // Set the vector table to the beginning of the app in flash.
+    //
+    HWREG(NVIC_VTABLE) = ui32StartAddr;
+
+    //
+    // Load the stack pointer from the application's vector table.
+    //
+    __asm("    ldr     r1, [r0]\n"
+          "    mov     sp, r1");
+
+    //
+    // Load the initial PC from the application's vector table and branch to
+    // the application's entry point.
+    //
+    __asm("    ldr     r0, [r0, #4]\n"
+          "    bx      r0\n");
+}
+#elif defined(rvmdk) || defined(__ARMCC_VERSION)
+__asm static void
+Branch(uint32_t ui32StartAddr)
+{
+    //
+    // Set the vector table address to the beginning of the application.
+    //
+    ldr     r1, =0xe000ed08
+    str     r0, [r1]
+
+    //
+    // Load the stack pointer from the application's vector table.
+    //
+    ldr     r1, [r0]
+    mov     sp, r1
+
+    //
+    // Load the initial PC from the application's vector table and branch to
+    // the application's entry point.
+    //
+    ldr     r0, [r0, #4]
+    bx      r0
+}
+#elif defined(ccs)
+static void
+Branch(uint32_t ui32StartAddr)
+{
+
+    //
+    // Set the vector table to the beginning of the app in flash.
+    //
+    HWREG(NVIC_VTABLE) = ui32StartAddr;
+
+
+    //
+    // Load the stack pointer from the application's vector table.
+    //
+    __asm("    ldr     r1, [r0]\n"
+          "    mov     sp, r1\n");
+
+
+    //
+    // Load the initial PC from the application's vector table and branch to
+    // the application's entry point.
+    //
+    __asm("    ldr     r0, [r0, #4]\n"
+          "    bx      r0\n");
+
+
+}
+#else
+#error Undefined compiler!
+#endif
+
+// clear all Peripheral
+void clearPeripheral()
+{
+
+	if (SysCtlPeripheralReady(SYSCTL_PERIPH_I2C8)){
+		SysCtlPeripheralReset(SYSCTL_PERIPH_I2C8);
+		SysCtlPeripheralDisable(SYSCTL_PERIPH_I2C8);
+	}
+}
+
+//*****************************************************************************
+//
+// This public function initiates the branch to applciation code. It performs
+// a basic validation test on the application address stack pointer and
+// vector table. If these values seem logical a compiler-specific branch
+// helper function is called otherwise a core reset is initiated.
+//
+//*****************************************************************************
+void
+CallApplication(uint32_t ui32StartAddr)
+{
+    uint32_t ui32Val;
+//    uint32_t ui32failReason,ui32flashclear,ui32retrycount,ui32clear =0x00;
+
+
+
+//    EEPROMRead(&ui32failReason,EEPROM_ADDR_UPDATE,0x04);
+//    EEPROMRead(&ui32flashclear,EEPROM_FLASH_CLEAR_FLAG,0x04);
+//    EEPROMRead(&ui32retrycount,EEPROM_DHCP_RETRY_FLAG,0x04);
+       
+   // DPRINTF(("DCHP %x,%x\n",ui32retrycount,dhcpexist));
+   //DPRINTF(("TFTP %x ,%x\n",((ui32failReason >> 16)&0xFF),(ui32flashclear&0xFF)));
+    DPRINTF(("Branching to application start address (0x%08x)\n",ui32StartAddr));
+
+//    if(((ui32retrycount & 0xFF)!=0) && ((ui32retrycount & 0xFF) < UIP_DHCP_RETRY) && (dhcpexist != 0))        
+//    {	
+//    	DPRINTF(("DHCP FAIL! Reboot\n"));   
+//    	SysCtlReset();
+//    }         
+//    //If TFTP Fail and Flash has been clear,reboot to bootloader 
+//    if((ui32flashclear & 0xFF)==0x01)
+//    {	
+//    	if(((ui32failReason >> 16) &0xFF)==0x02)
+//    	{
+//    		DPRINTF(("TFTP FAIL! Reboot\n"));   
+//    		SysCtlReset();     
+//    	}	
+//    }
+    
+    
+	
+    //EEPROMProgram(&ui32clear,EEPROM_FLASH_CLEAR_FLAG,0x04);
+    //EEPROMProgram(&ui32clear,EEPROM_DHCP_RETRY_FLAG,0x04);
+    
+    ROM_SysCtlDelay(100000);
+
+
+    clearPeripheral();
+
+    //
+    // Sanity check the application address. Check the stack pointer.
+    //
+    ui32Val = HWREG(ui32StartAddr);
+
+    //
+    // Simplistic check that the stack pointer appears to be in SRAM and that
+    // it is four-byte aligned.
+    //
+    if((!(ui32Val > 0x20000000) || !(ui32Val < 0x20040000) ||
+       !((ui32Val & 0x00000003) == 0x00000000)))
+    {
+
+    	//
+        // That image does not appear to be valid. Perform a software
+        // reset request to allow a possible recovery.
+        //
+        ///HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ;
+
+    	//only do the core reset , doesn't reset the peripherals
+    	HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+    }
+
+    //
+    // Extract the reset vector address from the vector table.
+    //
+    ui32Val = HWREG(ui32StartAddr + 4);
+
+    //
+    // Ensure that the reset vector is in flash and that it has the LSB set
+    // (indicating that it is Thumb code).
+    //
+    if(!(ui32Val & 0x00000ffe) || !((ui32Val & 0x00000001) == 0x00000001))
+    {
+       
+    	//
+        // That image does not appear to be valid. Perform a software
+        // reset request to allow a possible recovery.
+        //
+        /// HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_SYSRESETREQ;
+
+    	//only do the core reset , doesn't reset the peripherals
+    	HWREG(NVIC_APINT) = NVIC_APINT_VECTKEY | NVIC_APINT_VECT_RESET;
+    }
+
+    //
+    // Enable the Watchdog peripheral
+    //
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_WDOG0);
+
+    //
+    // Enable processor interrupts.
+    //
+    ROM_IntMasterEnable();
+
+    //
+    // Enable the watchdog interrupt.
+    //
+    ROM_IntEnable(INT_WATCHDOG);
+
+    //
+    // Set the load value for the Watchdog timer
+    //
+    ROM_WatchdogReloadSet(WATCHDOG0_BASE, 400000000);
+
+    //
+    // Enable the Watchdog reset to the CPU
+    //
+    ROM_WatchdogResetEnable(WATCHDOG0_BASE);
+
+    //
+    // Enable the Watchdog. App is now responsible for servicing
+    // the Watchdog
+    //
+    ROM_WatchdogEnable(WATCHDOG0_BASE);
+
+    //
+    // Use the helper function to branch to the application.
+    //
+    Branch(ui32StartAddr);
+
+}
+
+//*****************************************************************************
+//
+// Flash protect setting
+//
+//*****************************************************************************
+void
+FlashProtect(void)
+{
+    uint32_t ui32Count;
+    tFlashProtection ui32ProtectionStatus;
+
+    //
+    // Get the protection status for address 0x0 as this bootloader flash
+    //
+    ui32ProtectionStatus = ROM_FlashProtectGet(0x00);
+
+    //
+    // If the flash is read/write then it has not been protected yet
+    //
+    if (ui32ProtectionStatus == FlashReadWrite)
+    {
+        for(ui32Count = 0x00; ui32Count<FLASH_ADDR_UPDATE;
+        					  ui32Count+=FLASH_BLOCK_PROTECT_SIZE)
+        {
+            //
+            // Protect the 2kB block of bootloader flash
+            //
+            ROM_FlashProtectSet(ui32Count, FlashReadOnly);
+        }
+
+        //
+        // Save the protection
+        //
+        ROM_FlashProtectSave();
+    }
+}
+
+
+//*****************************************************************************
+//
+// This function parses the expected update flag area of flash for the signal
+// that it should run the LPC update.
+//
+//*****************************************************************************
+static bool
+LPCCheckUpdate(void)
+{
+		uint32_t pui32Words;
+    
+    //ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
+    //ROM_EEPROMInit();
+    
+    EEPROMRead(&pui32Words,EEPROM_ADDR_UPDATE,0x04);
+    
+    ////pui32Words = HWREG(FLASH_ADDR_UPDATE);
+    DPRINTF(("LPC flag = 0x%x.\n",pui32Words)); 
+    if((pui32Words&0xFF) == 0x00000002)
+    	return(true);
+    else
+    	return(false);	
+}
+
+//*****************************************************************************
+//
+// This function parses the expected update flag area of flash for the signal
+// that it should run the UART update.
+//
+//*****************************************************************************
+static bool
+UARTCheckUpdate(void)
+{
+		uint32_t pui32Words;
+
+    EEPROMRead(&pui32Words,EEPROM_ADDR_UPDATE,0x04);
+
+    ////pui32Words = HWREG(FLASH_ADDR_UPDATE);
+    DPRINTF(("UART flag = 0x%x.\n",pui32Words));
+    if((pui32Words&0xFF) == 0x00000003)
+    	return(true);
+    else
+    	return(false);
+}
+
+//*****************************************************************************
+//
+// This function parses the expected update flag area of flash for the signal
+// that it should run the I2C update.
+//
+//*****************************************************************************
+static bool
+I2CCheckUpdate(void)
+{
+		uint32_t pui32Words;
+
+    EEPROMRead(&pui32Words,EEPROM_ADDR_UPDATE,0x04);
+
+    ////pui32Words = HWREG(FLASH_ADDR_UPDATE);
+    DPRINTF(("I2C flag = 0x%x.\n",pui32Words));
+    if((pui32Words&0xFF) == 0x00000004)
+    	return(true);
+    else
+    	return(false);
+}
+
+unsigned char int2bcd(int value)
+{
+	return ((value / 10) << 4) | (value % 10);
+}
+
+void CheckFWVersion()
+{
+	uint32_t version;
+	
+	Hal_eeprom_read((uint8_t *)&version,bootver_offet,2);
+	if ( version  != (BOOT_FIRMWARE_VERSION) )
+	{	
+		version =  BOOT_MAJOR_VERSION << 8 | int2bcd(BOOT_MINOR_VERSION) ;
+		Hal_eeprom_write((uint8_t *)&version,bootver_offet,2);	
+	}
+}
+
+#define I2CBOOT_SYSCTL_CLOCK    (SYSCTL_OSC_INT | SYSCTL_USE_PLL |            \
+                                 SYSCTL_CFG_VCO_480)
+#define I2CBOOT_CLOCK_HZ        120000000
+//*****************************************************************************
+//
+// Main entry point for application.
+//
+//*****************************************************************************
+int
+main(void)
+{
+    uint32_t ui32Reset;
+
+    
+
+    uint32_t ui32WDflag = 0;
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
+    EEPROMInit();
+
+    //
+    // If watchdog is enabled, reset and disable it
+    //
+    if (ROM_SysCtlPeripheralReady(WATCHDOG0_BASE))
+    {
+        //
+        // Reset Watchdog0
+        //
+        ROM_SysCtlPeripheralReset(SYSCTL_PERIPH_WDOG0);
+
+        //
+        // Disable Watchdog0
+        //
+        ROM_SysCtlPeripheralDisable(SYSCTL_PERIPH_WDOG0);
+    }
+
+#ifdef DEBUG
+    //
+    // Configure Console I/O on UART4, always using PIOSC.
+    //
+    //UART4 - debug console
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART4);
+    ROM_GPIOPinConfigure(GPIO_PK0_U4RX);
+    ROM_GPIOPinConfigure(GPIO_PK1_U4TX);
+    ROM_GPIOPinTypeUART(GPIO_PORTK_BASE, GPIO_PIN_0 | GPIO_PIN_1);
+    ROM_UARTClockSourceSet(UART4_BASE, UART_CLOCK_PIOSC);
+    UARTStdioConfig(4, 921600, 16000000);
+   // UARTStdioConfig(4, 115200, 16000000);
+    DPRINTF(("\n\n + F09 TWinlakes Ethernet & LPC Flash Boot Loader 2017/08/22 ver 2.02 svn:64162\n"));
+#endif
+
+    DPRINTF(("signature %x %x %x %x %x %x\n",FW_CHECK[0],FW_CHECK[1],FW_CHECK[2],FW_CHECK[3],FW_CHECK[4],FW_CHECK[5]));
+    
+
+    //---------------------------------------------------------------------------
+    //Mini140825 Configure UART0 for UART update
+    /*
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_UART0);
+    ROM_GPIOPinConfigure(GPIO_PA0_U0RX);
+    ROM_GPIOPinConfigure(GPIO_PA1_U0TX);
+	*/
+//---------------------------------------------------------------------------
+
+
+//---------------------------------------------------------------------------
+
+    //Jerry131007 light the heartbeat  
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOS);
+    ROM_GPIODirModeSet(GPIO_PORTS_BASE, GPIO_PIN_5, GPIO_DIR_MODE_OUT);
+    ROM_GPIOPadConfigSet(GPIO_PORTS_BASE, GPIO_PIN_5, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);
+    ROM_GPIOPinWrite(GPIO_PORTS_BASE,GPIO_PIN_5,0);
+//---------------------------------------------------------------------------
+    //Mini140825 ready pin set to high
+    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
+    ROM_GPIODirModeSet(GPIO_PORTF_BASE, GPIO_PIN_6, GPIO_DIR_MODE_OUT);
+    ROM_GPIOPadConfigSet(GPIO_PORTF_BASE, GPIO_PIN_6, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD_WPU);
+    ROM_GPIOPinWrite(GPIO_PORTF_BASE,GPIO_PIN_6,GPIO_PIN_6);
+
+
+
+
+
+
+
+
+
+
+    //test
+	//ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOT);
+	//ROM_GPIODirModeSet(GPIO_PORTT_BASE, GPIO_PIN_0, GPIO_DIR_MODE_OUT);
+	//ROM_GPIOPadConfigSet(GPIO_PORTT_BASE, GPIO_PIN_0, GPIO_STRENGTH_2MA,GPIO_PIN_TYPE_STD);
+	//ROM_GPIOPinWrite(GPIO_PORTT_BASE,GPIO_PIN_0,0);
+
+
+
+
+
+
+
+
+
+
+    //
+    // The FPU should be enabled because some compilers will use floating-
+    // point registers, even for non-floating-point code.  If the FPU is not
+    // enabled this will cause a fault.  This also ensures that floating-
+    // point operations could be added to this application and would work
+    // correctly and use the hardware floating-point unit.  Finally, lazy
+    // stacking is enabled for interrupt handlers.  This allows floating-
+    // point instructions to be used within interrupt handlers, but at the
+    // expense of extra stack usage.
+    //
+    HWREG(NVIC_CPAC) = ((HWREG(NVIC_CPAC) &
+                         ~(NVIC_CPAC_CP10_M | NVIC_CPAC_CP11_M)) |
+                        NVIC_CPAC_CP10_FULL | NVIC_CPAC_CP11_FULL);
+    HWREG(NVIC_FPCC) |= NVIC_FPCC_ASPEN | NVIC_FPCC_LSPEN;
+
+    //
+    // Protect the bootloader flash if this is first birthday
+    //
+    //FlashProtect();
+
+    //
+    // Reset caused by Watchdog?
+    //
+    ui32Reset = ROM_SysCtlResetCauseGet();
+
+    CheckFWVersion();
+
+    /* Jerry130731 check if the BMC reset was caused by runtime watchdog timeout
+    If reset was caused by watchdog then store a flag and SEL in runtime code */
+    if( (ui32Reset & SYSCTL_CAUSE_WDOG0) == SYSCTL_CAUSE_WDOG0 )
+    {	
+
+
+    	EEPROMRead(&ui32WDflag,EEPROM_ADDR_WD_FLAG,0x04);
+
+    	DPRINTF(("reset by wd %x\n",ui32WDflag));
+    	if((ui32WDflag&0xFF) == 0xff)
+    		ui32WDflag = 0x01;
+    	else if((ui32WDflag&0xFF) < WDTRETRY)
+    		ui32WDflag++;
+
+    	EEPROMProgram(&ui32WDflag, EEPROM_ADDR_WD_FLAG, 0x04);
+
+    	if((ui32WDflag&0xFF) < WDTRETRY)
+    	{
+    		ROM_SysCtlDelay(100000);
+    		CallApplication(APP_START_ADDRESS);
+    		while(true)
+    		{
+    		}
+    	}
+//    	ui32WDflag = HWREG(FLASH_ADDR_UPDATE);
+//    	FlashErase(FLASH_ADDR_UPDATE);
+//    	ui32WDflag = (ui32WDflag & 0x0000FFFF) | 0x10<<24;
+//    	FlashProgram(&ui32WDflag, FLASH_ADDR_UPDATE, 4);
+    	
+    }
+    //
+    // Clear watchddog reset cause
+    //
+    ROM_SysCtlResetCauseClear(SYSCTL_CAUSE_WDOG0);
+
+    //
+    //
+	//brenden add eeprom relate code
+	//
+	//
+
+
+//    DPRINTF(("flag=%d.\n",HWREG(FLASH_ADDR_UPDATE)));
+	
+    //
+    // Check if APP wants to update via Ethernet.
+    // Branch to TFTP bootloader.
+    //
+    if(ENETCheckUpdate() == true)
+    {
+        ////DPRINTF(("Update flag set in Flash memory.\n"));
+
+        ETH_BootInit();
+
+        //
+        // Start the update execution. Does not return.
+        //
+        DPRINTF(("Start TFTP update\n"));
+        
+        TFTPUpdate();
+    }
+
+    //
+    // APP did not want to update over etherent.
+    // APP WAS reset by watchdog OR there is no valid image in the flash.
+    // Brach to LPC bootloader.
+    //
+//    else if (((ui32Reset & SYSCTL_CAUSE_WDOG0) == SYSCTL_CAUSE_WDOG0)
+//            || CheckImage(APP_START_ADDRESS) != 0)
+      //else if ((    LPCCheckUpdate() == true)     //HWREG(FLASH_ADDR_UPDATE) == LPC_UPDATE
+      //         || CheckImage(APP_START_ADDRESS) != 0)
+    else if(LPCCheckUpdate() == true)
+    {
+        //
+        // Valid detected, branch to the LPC loader.
+        //
+        DPRINTF(("user chose lpc to do fw update\n"));
+        DPRINTF(("Branching to LPC Boot Loader (entry)\n"));
+
+        entry();
+
+        //
+        // In theory, this should never return, but if we get here, dump a
+        // diagnostic trace and spin in a loop.
+        //
+        DPRINTF(("Error: Unexpected return from LPC Boot Loader (entry)\n"));
+        while(true)
+        {
+        }
+    }
+
+    //
+    // FW update from UART
+    else if((UARTCheckUpdate() == true))
+    {
+
+    	// Selects the UART as the port for communicating with the boot loader.
+        DPRINTF(("user chose uart to do fw update.\n"));
+        ConfigureUARTDevice();
+        //
+        // Start the update execution. Does not return.
+        //
+
+        DPRINTF(("Start UART update\n"));
+        UART_Updater();
+    }
+    // FW update from I2C
+    else if((I2CCheckUpdate() == true))
+    {
+
+    	// Selects the UART as the port for communicating with the boot loader.
+        DPRINTF(("user chose I2C to do fw update.\n"));
+        ConfigureI2CDevice();
+        //
+        // Start the update execution. Does not return.
+        //
+
+        DPRINTF(("Start I2C update\n"));
+        I2C_Updater();
+    }
+    else if(CheckImage(APP_START_ADDRESS) != 0)
+    {
+    	//
+    	// Valid detected, branch to the LPC loader.
+    	//
+    	DPRINTF(("there is no valid image.\n"));
+    	DPRINTF(("Branching to LPC Boot Loader (entry)\n"));
+    	entry();
+
+    	//
+    	// In theory, this should never return, but if we get here, dump a
+    	// diagnostic trace and spin in a loop.
+    	//
+    	DPRINTF(("Error: Unexpected return from LPC Boot Loader (entry)\n"));
+    	while(true)
+    	{
+    	}
+    }
+    //
+    // APP did not want to update over Ethernet and was NOT reset by watchdog.
+    // However, there appears to be a valid image in the flash.
+    // Go the the user APP
+    //
+    else if(CheckImage(APP_START_ADDRESS) == 0)
+    {
+        //
+        // Pass control to the application.
+        //
+        DPRINTF(("There is a valid image in the flash.\n"));
+
+        CallApplication(APP_START_ADDRESS);
+    }
+
+    //
+    // Execution never reaches here.
+    //
+    while(true)
+    {
+    }
+}
Only in f09_tmp: makefile.defs
diff --unidirectional-new-file -ru f09_tmp/.project f09_bootloader_202/.project
--- f09_tmp/.project	2017-08-29 10:03:23.938264682 +0800
+++ f09_bootloader_202/.project	2017-08-23 13:42:23.835000000 +0800
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <projectDescription>
-	<name>f20_tmp</name>
+	<name>f09_bootloader</name>
 	<comment></comment>
 	<projects>
 	</projects>
@@ -18,11 +18,16 @@
 		</buildCommand>
 	</buildSpec>
 	<natures>
-		<nature>org.eclipse.rtsc.xdctools.buildDefinitions.XDC.xdcNature</nature>
 		<nature>com.ti.ccstudio.core.ccsNature</nature>
 		<nature>org.eclipse.cdt.core.cnature</nature>
 		<nature>org.eclipse.cdt.managedbuilder.core.managedBuildNature</nature>
 		<nature>org.eclipse.cdt.core.ccnature</nature>
 		<nature>org.eclipse.cdt.managedbuilder.core.ScannerConfigNature</nature>
 	</natures>
+	<variableList>
+		<variable>
+			<name>SW_ROOT</name>
+			<value>file:/C:/DK-SMC/boards/dk-smc-lm4fb1/sample_eth_lpc_boot/ccs</value>
+		</variable>
+	</variableList>
 </projectDescription>
diff --unidirectional-new-file -ru f09_tmp/sample_eth_lpc_boot_ccs.cmd f09_bootloader_202/sample_eth_lpc_boot_ccs.cmd
--- f09_tmp/sample_eth_lpc_boot_ccs.cmd	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/sample_eth_lpc_boot_ccs.cmd	2017-08-23 13:37:40.585000000 +0800
@@ -0,0 +1,77 @@
+/******************************************************************************
+ *
+ * sample_eth_lpc_boot_ccs.cmd - CCS linker configuration file for sample_eth_lpc_boot.
+ *
+ * Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+ * Software License Agreement
+ * 
+ * Texas Instruments (TI) is supplying this software for use solely and
+ * exclusively on TI's microcontroller products. The software is owned by
+ * TI and/or its suppliers, and is protected under applicable copyright
+ * laws. You may not combine this software with "viral" open-source
+ * software in order to form a larger program.
+ * 
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+ * NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+ * NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+ * CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+ * DAMAGES, FOR ANY REASON WHATSOEVER.
+ * 
+ * This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+ * 
+ * This is part of an ALPHA release.
+ * The software in this release is not intended for use in a production project.
+ *
+ *****************************************************************************/
+
+--retain=g_pfnVectors
+
+/* The following command line options are set as part of the CCS project.    */
+/* If you are building using the command line, or for some reason want to    */
+/* define them here, you can uncomment and modify these lines as needed.     */
+/* If you are using CCS for building, it is probably better to make any such */
+/* modifications in your CCS project and leave this file alone.              */
+/*                                                                           */
+/* --heap_size=0                                                             */
+/* --stack_size=256                                                          */
+/* --library=rtsv7M3_T_le_eabi.lib                                           */
+
+/* The starting address of the application.  Normally the interrupt vectors  */
+/* must be located at the beginning of the application.                      */
+#define APP_BASE 0x00000000
+#define RAM_BASE 0x20000000
+
+/* System memory map */
+
+MEMORY
+{
+    /* Application stored in and executes from internal flash */
+    //FLASH1 (RX) : origin = APP_BASE, length = 0x00100000
+    FLASH1 (RX) : origin = APP_BASE, length = 0x00004000
+    FLASH2 (RX) : origin = 0x00004000, length = 0x00000400
+    /* Application uses internal RAM for data */
+    SRAM (RWX) : origin = 0x20000000, length = 0x00040000
+}
+
+/* Section allocation in memory */
+
+SECTIONS
+{
+    .intvecs:   > APP_BASE
+    .text   :   > FLASH1
+    .const  :   > FLASH1
+    .cinit  :   > FLASH1
+    .pinit  :   > FLASH1
+    .init_array : > FLASH1
+    .temp  :   > FLASH2
+
+
+    .vtable :   > RAM_BASE
+    .data   :   > SRAM
+    .bss    :   > SRAM
+    .sysmem :   > SRAM
+    .stack  :   > SRAM
+}
+
+__STACK_TOP = __stack + 2048;
diff --unidirectional-new-file -ru f09_tmp/.settings/org.eclipse.core.resources.prefs f09_bootloader_202/.settings/org.eclipse.core.resources.prefs
--- f09_tmp/.settings/org.eclipse.core.resources.prefs	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/.settings/org.eclipse.core.resources.prefs	2017-08-23 13:37:41.001000000 +0800
@@ -0,0 +1,10 @@
+eclipse.preferences.version=1
+encoding//Debug/driverlib/subdir_rules.mk=UTF-8
+encoding//Debug/driverlib/subdir_vars.mk=UTF-8
+encoding//Debug/makefile=UTF-8
+encoding//Debug/objects.mk=UTF-8
+encoding//Debug/sources.mk=UTF-8
+encoding//Debug/subdir_rules.mk=UTF-8
+encoding//Debug/subdir_vars.mk=UTF-8
+encoding//Debug/utils/subdir_rules.mk=UTF-8
+encoding//Debug/utils/subdir_vars.mk=UTF-8
diff --unidirectional-new-file -ru f09_tmp/startup_ccs.c f09_bootloader_202/startup_ccs.c
--- f09_tmp/startup_ccs.c	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/startup_ccs.c	2017-08-23 13:37:40.978000000 +0800
@@ -0,0 +1,292 @@
+//*****************************************************************************
+//
+// startup_ccs.c - Startup code for use with TI's Code Composer Studio.
+//
+// Copyright (c) 2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#include <stdint.h>
+#include "inc/hw_nvic.h"
+#include "inc/hw_types.h"
+#include "bmc_blcfg.h"
+
+//*****************************************************************************
+//
+// Forward declaration of the default fault handlers.
+//
+//*****************************************************************************
+void ResetISR(void);
+static void NmiSR(void);
+static void FaultISR(void);
+static void IntDefaultHandler(void);
+
+//*****************************************************************************
+//
+// External declaration for the reset handler that is to be called when the
+// processor is started
+//
+//*****************************************************************************
+extern void _c_int00(void);
+
+//*****************************************************************************
+//
+// Linker variable that marks the top of the stack.
+//
+//*****************************************************************************
+extern uint32_t __STACK_TOP;
+
+//*****************************************************************************
+//
+// External declaration for the interrupt handler used by the application.
+//
+//*****************************************************************************
+extern void SysTickIntHandler(void);
+
+//*****************************************************************************
+//
+// External declaration for the interrupt handler used oem LPC handler
+//
+//*****************************************************************************
+#ifdef OEM_HOOK
+    extern void LPCIntHandler(void);
+#endif
+
+//*****************************************************************************
+//
+// The vector table.  Note that the proper constructs must be placed on this to
+// ensure that it ends up at physical address 0x0000.0000 or at the start of
+// the program if located at a start address other than 0.
+//
+//*****************************************************************************
+#pragma DATA_SECTION(g_pfnVectors, ".intvecs")
+void (* const g_pfnVectors[])(void) =
+{
+    (void (*)(void))((uint32_t)&__STACK_TOP),
+                                            // The initial stack pointer
+    ResetISR,                               // The reset handler
+    NmiSR,                                  // The NMI handler
+    FaultISR,                               // The hard fault handler
+    IntDefaultHandler,                      // The MPU fault handler
+    IntDefaultHandler,                      // The bus fault handler
+    IntDefaultHandler,                      // The usage fault handler
+    0,                                      // Reserved
+    0,                                      // Reserved
+    0,                                      // Reserved
+    0,                                      // Reserved
+    IntDefaultHandler,                      // SVCall handler
+    IntDefaultHandler,                      // Debug monitor handler
+    0,                                      // Reserved
+    IntDefaultHandler,                      // The PendSV handler
+    SysTickIntHandler,                      // The SysTick handler
+    IntDefaultHandler,                      // GPIO Port A
+    IntDefaultHandler,                      // GPIO Port B
+    IntDefaultHandler,                      // GPIO Port C
+    IntDefaultHandler,                      // GPIO Port D
+    IntDefaultHandler,                      // GPIO Port E
+    IntDefaultHandler,                      // UART0 Rx and Tx
+    IntDefaultHandler,                      // UART1 Rx and Tx
+    IntDefaultHandler,                      // SSI0 Rx and Tx
+    IntDefaultHandler,                      // I2C0 Master and Slave
+    IntDefaultHandler,                      // PWM Fault
+    IntDefaultHandler,                      // PWM Generator 0
+    IntDefaultHandler,                      // PWM Generator 1
+    IntDefaultHandler,                      // PWM Generator 2
+    IntDefaultHandler,                      // Quadrature Encoder 0
+    IntDefaultHandler,                      // ADC Sequence 0
+    IntDefaultHandler,                      // ADC Sequence 1
+    IntDefaultHandler,                      // ADC Sequence 2
+    IntDefaultHandler,                      // ADC Sequence 3
+    IntDefaultHandler,                      // Watchdog timer
+    IntDefaultHandler,                      // Timer 0 subtimer A
+    IntDefaultHandler,                      // Timer 0 subtimer B
+    IntDefaultHandler,                      // Timer 1 subtimer A
+    IntDefaultHandler,                      // Timer 1 subtimer B
+    IntDefaultHandler,                      // Timer 2 subtimer A
+    IntDefaultHandler,                      // Timer 2 subtimer B
+    IntDefaultHandler,                      // Analog Comparator 0
+    IntDefaultHandler,                      // Analog Comparator 1
+    IntDefaultHandler,                      // Analog Comparator 2
+    IntDefaultHandler,                      // System Control (PLL, OSC, BO)
+    IntDefaultHandler,                      // FLASH Control
+    IntDefaultHandler,                      // GPIO Port F
+    IntDefaultHandler,                      // GPIO Port G
+    IntDefaultHandler,                      // GPIO Port H
+    IntDefaultHandler,                      // UART2 Rx and Tx
+    IntDefaultHandler,                      // SSI1 Rx and Tx
+    IntDefaultHandler,                      // Timer 3 subtimer A
+    IntDefaultHandler,                      // Timer 3 subtimer B
+    IntDefaultHandler,                      // I2C1 Master and Slave
+    IntDefaultHandler,                      // CAN0
+    IntDefaultHandler,                      // CAN1
+    IntDefaultHandler,                      // Ethernet
+    IntDefaultHandler,                      // Hibernate
+    IntDefaultHandler,                      // USB0
+    IntDefaultHandler,                      // PWM Generator 3
+    IntDefaultHandler,                      // uDMA Software Transfer
+    IntDefaultHandler,                      // uDMA Error
+    IntDefaultHandler,                      // ADC1 Sequence 0
+    IntDefaultHandler,                      // ADC1 Sequence 1
+    IntDefaultHandler,                      // ADC1 Sequence 2
+    IntDefaultHandler,                      // ADC1 Sequence 3
+    IntDefaultHandler,                      // External Bus Interface 0
+    IntDefaultHandler,                      // GPIO Port J
+    IntDefaultHandler,                      // GPIO Port K
+    IntDefaultHandler,                      // GPIO Port L
+    IntDefaultHandler,                      // SSI2 Rx and Tx
+    IntDefaultHandler,                      // SSI3 Rx and Tx
+    IntDefaultHandler,                      // UART3 Rx and Tx
+    IntDefaultHandler,                      // UART4 Rx and Tx
+    IntDefaultHandler,                      // UART5 Rx and Tx
+    IntDefaultHandler,                      // UART6 Rx and Tx
+    IntDefaultHandler,                      // UART7 Rx and Tx
+    IntDefaultHandler,                      // I2C2 Master and Slave
+    IntDefaultHandler,                      // I2C3 Master and Slave
+    IntDefaultHandler,                      // Timer 4 subtimer A
+    IntDefaultHandler,                      // Timer 4 subtimer B
+    IntDefaultHandler,                      // Timer 5 subtimer A
+    IntDefaultHandler,                      // Timer 5 subtimer B
+    IntDefaultHandler,                      // FPU
+    IntDefaultHandler,                      // PECI 0
+#ifdef OEM_HOOK
+    LPCIntHandler,							// LPC 0
+#else
+    IntDefaultHandler,                      // LPC 0
+#endif
+    IntDefaultHandler,                      // I2C4 Master and Slave
+    IntDefaultHandler,                      // I2C5 Master and Slave
+    IntDefaultHandler,                      // GPIO Port M
+    IntDefaultHandler,                      // GPIO Port N
+    IntDefaultHandler,                      // Fan 0
+    IntDefaultHandler,                      // Tamper
+    IntDefaultHandler,                      // GPIO Port P (Summary or P0)
+    IntDefaultHandler,                      // GPIO Port P1
+    IntDefaultHandler,                      // GPIO Port P2
+    IntDefaultHandler,                      // GPIO Port P3
+    IntDefaultHandler,                      // GPIO Port P4
+    IntDefaultHandler,                      // GPIO Port P5
+    IntDefaultHandler,                      // GPIO Port P6
+    IntDefaultHandler,                      // GPIO Port P7
+    IntDefaultHandler,                      // GPIO Port Q (Summary or Q0)
+    IntDefaultHandler,                      // GPIO Port Q1
+    IntDefaultHandler,                      // GPIO Port Q2
+    IntDefaultHandler,                      // GPIO Port Q3
+    IntDefaultHandler,                      // GPIO Port Q4
+    IntDefaultHandler,                      // GPIO Port Q5
+    IntDefaultHandler,                      // GPIO Port Q6
+    IntDefaultHandler,                      // GPIO Port Q7
+    IntDefaultHandler,                      // GPIO Port R
+    IntDefaultHandler,                      // GPIO Port S
+    IntDefaultHandler,                      // SHA/MD5 0
+    IntDefaultHandler,                      // AES 0
+    IntDefaultHandler,                      // DES3DES 0
+    IntDefaultHandler,                      // LCD Controller 0
+    IntDefaultHandler,                      // Timer 6 subtimer A
+    IntDefaultHandler,                      // Timer 6 subtimer B
+    IntDefaultHandler,                      // Timer 7 subtimer A
+    IntDefaultHandler,                      // Timer 7 subtimer B
+    IntDefaultHandler,                      // I2C6 Master and Slave
+    IntDefaultHandler,                      // I2C7 Master and Slave
+    IntDefaultHandler,                      // HIM Scan Matrix Keyboard 0
+    IntDefaultHandler,                      // One Wire 0
+    IntDefaultHandler,                      // HIM PS/2 0
+    IntDefaultHandler,                      // HIM LED Sequencer 0
+    IntDefaultHandler,                      // HIM Consumer IR 0
+    IntDefaultHandler,                      // I2C8 Master and Slave
+    IntDefaultHandler,                      // I2C9 Master and Slave
+    IntDefaultHandler                       // GPIO Port T
+};
+
+//*****************************************************************************
+//
+// This is the code that gets called when the processor first starts execution
+// following a reset event.  Only the absolutely necessary set is performed,
+// after which the application supplied entry() routine is called.  Any fancy
+// actions (such as making decisions based on the reset cause register, and
+// resetting the bits in that register) are left solely in the hands of the
+// application.
+//
+//*****************************************************************************
+void
+ResetISR(void)
+{
+    //
+    // Jump to the CCS C initialization routine.  This will enable the
+    // floating-point unit as well, so that does not need to be done here.
+    //
+    __asm("    .global _c_int00\n"
+          "    b.w     _c_int00");
+}
+
+//*****************************************************************************
+//
+// This is the code that gets called when the processor receives a NMI.  This
+// simply enters an infinite loop, preserving the system state for examination
+// by a debugger.
+//
+//*****************************************************************************
+static void
+NmiSR(void)
+{
+    //
+    // Enter an infinite loop.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+// This is the code that gets called when the processor receives a fault
+// interrupt.  This simply enters an infinite loop, preserving the system state
+// for examination by a debugger.
+//
+//*****************************************************************************
+static void
+FaultISR(void)
+{
+    //
+    // Enter an infinite loop.
+    //
+    while(1)
+    {
+    }
+}
+
+//*****************************************************************************
+//
+// This is the code that gets called when the processor receives an unexpected
+// interrupt.  This simply enters an infinite loop, preserving the system state
+// for examination by a debugger.
+//
+//*****************************************************************************
+static void
+IntDefaultHandler(void)
+{
+    //
+    // Go into an infinite loop.
+    //
+    while(1)
+    {
+    }
+}
diff --unidirectional-new-file -ru f09_tmp/targetConfigs/readme.txt f09_bootloader_202/targetConfigs/readme.txt
--- f09_tmp/targetConfigs/readme.txt	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/targetConfigs/readme.txt	2017-08-23 13:37:40.597000000 +0800
@@ -0,0 +1,9 @@
+The 'targetConfigs' folder contains target-configuration (.ccxml) files, automatically generated based
+on the device and connection settings specified in your project on the Properties > General page.
+
+Please note that in automatic target-configuration management, changes to the project's device and/or
+connection settings will either modify an existing or generate a new target-configuration file. Thus,
+if you manually edit these auto-generated files, you may need to re-apply your changes. Alternatively,
+you may create your own target-configuration file for this project and manage it manually. You can
+always switch back to automatic target-configuration management by checking the "Manage the project's
+target-configuration automatically" checkbox on the project's Properties > General page.
\ No newline at end of file
diff --unidirectional-new-file -ru "f09_tmp/targetConfigs/Tiva TM4E129BNCZAD.ccxml" "f09_bootloader_202/targetConfigs/Tiva TM4E129BNCZAD.ccxml"
--- "f09_tmp/targetConfigs/Tiva TM4E129BNCZAD.ccxml"	1970-01-01 08:00:00.000000000 +0800
+++ "f09_bootloader_202/targetConfigs/Tiva TM4E129BNCZAD.ccxml"	2017-08-23 13:37:40.600000000 +0800
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<configurations XML_version="1.2" id="configurations_0">
+    <configuration XML_version="1.2" id="configuration_0">
+        <instance XML_version="1.2" desc="Stellaris In-Circuit Debug Interface" href="connections/Stellaris_ICDI_Connection.xml" id="Stellaris In-Circuit Debug Interface" xml="Stellaris_ICDI_Connection.xml" xmlpath="connections"/>
+        <connection XML_version="1.2" id="Stellaris In-Circuit Debug Interface">
+            <instance XML_version="1.2" href="drivers/stellaris_cs_dap.xml" id="drivers" xml="stellaris_cs_dap.xml" xmlpath="drivers"/>
+            <instance XML_version="1.2" href="drivers/stellaris_cortex_m4.xml" id="drivers" xml="stellaris_cortex_m4.xml" xmlpath="drivers"/>
+            <platform XML_version="1.2" id="platform_0">
+                <instance XML_version="1.2" desc="Tiva TM4E129BNCZAD" href="devices/tm4e129bnczad.xml" id="Tiva TM4E129BNCZAD" xml="tm4e129bnczad.xml" xmlpath="devices"/>
+            </platform>
+        </connection>
+    </configuration>
+</configurations>
Only in f09_tmp/third_party: no_license.txt
Only in f09_tmp/third_party/uip-1.0: apps
Only in f09_tmp/third_party/uip-1.0: doc
Only in f09_tmp/third_party/uip-1.0: lib
Only in f09_tmp/third_party/uip-1.0: README
Only in f09_tmp/third_party/uip-1.0/uip: Makefile.include
Only in f09_tmp/third_party/uip-1.0/uip: psock.c
Only in f09_tmp/third_party/uip-1.0/uip: uip-fw.c
Only in f09_tmp/third_party/uip-1.0/uip: uiplib.c
Only in f09_tmp/third_party/uip-1.0/uip: uip-neighbor.c
Only in f09_tmp/third_party/uip-1.0/uip: uip-split.c
Only in f09_tmp/third_party/uip-1.0/uip: uip_timer.c
Only in f09_tmp/third_party/uip-1.0: uip-1.0-changelog.txt
Only in f09_tmp/third_party/uip-1.0: unix
Only in f09_tmp: tm4e129bnczad.cmd
diff --unidirectional-new-file -ru f09_tmp/uip-conf.h f09_bootloader_202/uip-conf.h
--- f09_tmp/uip-conf.h	1970-01-01 08:00:00.000000000 +0800
+++ f09_bootloader_202/uip-conf.h	2017-08-23 13:37:40.653000000 +0800
@@ -0,0 +1,111 @@
+//*****************************************************************************
+//
+// uip-conf.h - uIP configuration for the boot loader.
+//
+// Copyright (c) 2007-2013 Texas Instruments Incorporated.  All rights reserved.
+// Software License Agreement
+// 
+// Texas Instruments (TI) is supplying this software for use solely and
+// exclusively on TI's microcontroller products. The software is owned by
+// TI and/or its suppliers, and is protected under applicable copyright
+// laws. You may not combine this software with "viral" open-source
+// software in order to form a larger program.
+// 
+// THIS SOFTWARE IS PROVIDED "AS IS" AND WITH ALL FAULTS.
+// NO WARRANTIES, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT
+// NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. TI SHALL NOT, UNDER ANY
+// CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR CONSEQUENTIAL
+// DAMAGES, FOR ANY REASON WHATSOEVER.
+// 
+// This is part of revision 1235 of the DK-SMC-SNOWFLAKE Firmware Package.
+// 
+// This is part of an ALPHA release.
+// The software in this release is not intended for use in a production project.
+//
+//*****************************************************************************
+
+#ifndef __UIP_CONF_H__
+#define __UIP_CONF_H__
+
+//*****************************************************************************
+//
+// This typedef defines the 8-bit type used throughout uIP.
+//
+//*****************************************************************************
+typedef uint8_t u8_t;
+
+//*****************************************************************************
+//
+// This typedef defines the 16-bit type used throughout uIP.
+//
+//*****************************************************************************
+typedef uint16_t u16_t;
+
+//*****************************************************************************
+//
+// This typedef defines the dataype used for keeping statistics in uIP.
+//
+//*****************************************************************************
+typedef uint16_t uip_stats_t;
+
+//*****************************************************************************
+//
+// Turn off TCP support.
+//
+//*****************************************************************************
+#define UIP_CONF_TCP            0
+
+//*****************************************************************************
+//
+// Turn on UDP support.
+//
+//*****************************************************************************
+#define UIP_CONF_UDP            1
+
+//*****************************************************************************
+//
+// Only support a single UDP connection.
+//
+//*****************************************************************************
+#define UIP_CONF_UDP_CONNS      1
+
+//*****************************************************************************
+//
+// Only support a single entry in the ARP table.
+//
+//*****************************************************************************
+#define UIP_CONF_ARPTAB_SIZE    1
+
+//*****************************************************************************
+//
+// Set the size of the uIP packet data buffer.
+//
+//*****************************************************************************
+#define UIP_CONF_BUFFER_SIZE    700
+
+//*****************************************************************************
+//
+// Enable UDP broadcast support.
+//
+//*****************************************************************************
+#define UIP_CONF_BROADCAST      1
+
+//*****************************************************************************
+//
+// Define a data type for the UDP application state.  This is not used, but
+// must be defined for uIP.
+//
+//*****************************************************************************
+typedef uint32_t uip_udp_appstate_t;
+
+//*****************************************************************************
+//
+// The name of the function to be called when UDP packets arrive, or when the
+// UDP periodic timer expires.
+//
+//*****************************************************************************
+extern char DHCPCThread(void);
+#define UIP_UDP_APPCALL        DHCPCThread
+
+#endif // __UIP_CONF_H__
Only in f09_tmp/utils: cir_nec.c
Only in f09_tmp/utils: cir_nec.h
Only in f09_tmp/utils: cir_rc5.c
Only in f09_tmp/utils: cir_rc5.h
Only in f09_tmp/utils: cir_rc6.c
Only in f09_tmp/utils: cir_rc6.h
Only in f09_tmp/utils: cmdline.c
Only in f09_tmp/utils: cmdline.h
Only in f09_tmp/utils: cpu_usage.c
Only in f09_tmp/utils: cpu_usage.h
Only in f09_tmp/utils: flash_pb.c
Only in f09_tmp/utils: flash_pb.h
Only in f09_tmp/utils: fswrapper.c
Only in f09_tmp/utils: fswrapper.h
Only in f09_tmp/utils: isqrt.c
Only in f09_tmp/utils: isqrt.h
Only in f09_tmp/utils: locator.c
Only in f09_tmp/utils: locator.h
Only in f09_tmp/utils: lwiplib.c
Only in f09_tmp/utils: lwiplib.h
Only in f09_tmp/utils: ptpdlib.c
Only in f09_tmp/utils: ptpdlib.h
Only in f09_tmp/utils: random.c
Only in f09_tmp/utils: random.h
Only in f09_tmp/utils: ringbuf.c
Only in f09_tmp/utils: ringbuf.h
Only in f09_tmp/utils: scheduler.c
Only in f09_tmp/utils: scheduler.h
Only in f09_tmp/utils: sine.c
Only in f09_tmp/utils: sine.h
Only in f09_tmp/utils: smbus.c
Only in f09_tmp/utils: smbus.h
Only in f09_tmp/utils: softi2c.c
Only in f09_tmp/utils: softi2c.h
Only in f09_tmp/utils: softssi.c
Only in f09_tmp/utils: softssi.h
Only in f09_tmp/utils: softuart.c
Only in f09_tmp/utils: softuart.h
Only in f09_tmp/utils: speexlib.c
Only in f09_tmp/utils: speexlib.h
Only in f09_tmp/utils: spi_flash.c
Only in f09_tmp/utils: spi_flash.h
Only in f09_tmp/utils: swupdate.c
Only in f09_tmp/utils: swupdate.h
Only in f09_tmp/utils: tftp.c
Only in f09_tmp/utils: tftp.h
diff --unidirectional-new-file -ru f09_tmp/utils/uartstdio.c f09_bootloader_202/utils/uartstdio.c
--- f09_tmp/utils/uartstdio.c	2017-08-29 10:03:23.950264682 +0800
+++ f09_bootloader_202/utils/uartstdio.c	2017-08-23 13:37:40.621000000 +0800
@@ -39,6 +39,7 @@
 #include "driverlib/sysctl.h"
 #include "driverlib/uart.h"
 #include "utils/uartstdio.h"
+#include "bmc_blcfg.h"
 
 //*****************************************************************************
 //
@@ -141,9 +142,9 @@
 // The list of possible base addresses for the console UART.
 //
 //*****************************************************************************
-static const uint32_t g_ui32UARTBase[3] =
+static const uint32_t g_ui32UARTBase[5] =
 {
-    UART0_BASE, UART1_BASE, UART2_BASE
+    UART0_BASE, UART1_BASE, UART2_BASE, UART3_BASE, UART4_BASE
 };
 
 #ifdef UART_BUFFERED
@@ -170,9 +171,9 @@
 // The list of UART peripherals.
 //
 //*****************************************************************************
-static const uint32_t g_ui32UARTPeriph[3] =
+static const uint32_t g_ui32UARTPeriph[5] =
 {
-    SYSCTL_PERIPH_UART0, SYSCTL_PERIPH_UART1, SYSCTL_PERIPH_UART2
+    SYSCTL_PERIPH_UART0, SYSCTL_PERIPH_UART1, SYSCTL_PERIPH_UART2 ,SYSCTL_PERIPH_UART3, SYSCTL_PERIPH_UART4
 };
 
 //*****************************************************************************
@@ -340,7 +341,7 @@
     // Check the arguments.
     //
     ASSERT((ui32PortNum == 0) || (ui32PortNum == 1) ||
-           (ui32PortNum == 2));
+           (ui32PortNum == 2) || (ui32PortNum == 3) || (ui32PortNum == 4));
 
 #ifdef UART_BUFFERED
     //
Only in f09_tmp/utils: ustdlib.c
Only in f09_tmp/utils: ustdlib.h
